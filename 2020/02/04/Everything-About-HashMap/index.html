<!DOCTYPE html>





<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6093907171303162",
    enable_page_level_ads: true
  });
</script>
<script data-ad-client="ca-pub-6093907171303162" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="REN WEI'S BLOG" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Find Everything about HashMap IN There.">
<meta name="keywords" content="Analyst of SourceCode">
<meta property="og:type" content="article">
<meta property="og:title" content="Everything About HashMap">
<meta property="og:url" content="http://yoursite.com/2020/02/04/Everything-About-HashMap/index.html">
<meta property="og:site_name" content="REN WEI&#39;S BLOG">
<meta property="og:description" content="Find Everything about HashMap IN There.">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://img1.sycdn.imooc.com/5d56493300011c0e19151612.png">
<meta property="og:updated_time" content="2020-03-13T17:38:09.142Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Everything About HashMap">
<meta name="twitter:description" content="Find Everything about HashMap IN There.">
<meta name="twitter:image" content="https://img1.sycdn.imooc.com/5d56493300011c0e19151612.png">
  <link rel="canonical" href="http://yoursite.com/2020/02/04/Everything-About-HashMap/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Everything About HashMap | REN WEI'S BLOG</title>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-140000048-1"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-140000048-1');
    }
  </script>








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">REN WEI'S BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-projects">
      
    

    <a href="/Projects" rel="section"><i class="menu-item-icon fa fa-fw fa-Projects"></i> <br>Projects</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-book">
      
    

    <a href="/Book" rel="section"><i class="menu-item-icon fa fa-fw fa-Book"></i> <br>Book</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/04/Everything-About-HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Ren">
      <meta itemprop="description" content="If not Me, Who? If not now, When?">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="REN WEI'S BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Everything About HashMap

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-02-04 18:51:33" itemprop="dateCreated datePublished" datetime="2020-02-04T18:51:33+08:00">2020-02-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-14 01:38:09" itemprop="dateModified" datetime="2020-03-14T01:38:09+08:00">2020-03-14</time>
              </span>
            
          

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/04/Everything-About-HashMap/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/02/04/Everything-About-HashMap/" itemprop="commentCount"></span></a>
  </span>
  
  
            <div class="post-description">Find Everything about HashMap IN There.</div>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-为什么用HashMap？"><a href="#1-为什么用HashMap？" class="headerlink" title="1.为什么用HashMap？"></a>1.为什么用HashMap？</h2><ul>
<li>HashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射。</li>
<li>HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改。数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到. 链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</li>
<li>用LinkedList代替数组结构可以么?</li>
</ul>
<p>当然是可以的，稍微说明一下，此题的意思是，源码中是这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry[] table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line"></span><br><span class="line">Entry就是一个链表节点。 那下面这样表示，是否可行?</span><br><span class="line"></span><br><span class="line">List&lt;Entry&gt; table = <span class="keyword">new</span> LinkedList&lt;Entry&gt;();</span><br></pre></td></tr></table></figure>
<p>答案很明显，是可以的。</p>
<p>既然是可以的,为什么HashMap不用LinkedList,而选用数组?<br>因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</p>
<ul>
<li>那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList?<br>因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。 而ArrayList的扩容机制是1.5倍扩容，那ArrayList为什么是1.5倍扩容这就不在本文说明了。</li>
<li>HashMap是非synchronized，所以HashMap很快。</li>
<li>HashMap可以接受null键和值，而Hashtable则不能（原因就是<code>equlas()</code>方法需要对象，因为HashMap是后出的API经过处理才可以）</li>
<li>当链表转为红黑树后，什么时候退化为链表?<br>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</li>
</ul>
<h2 id="2-HashMap的工作原理是什么？"><a href="#2-HashMap的工作原理是什么？" class="headerlink" title="2.HashMap的工作原理是什么？"></a>2.HashMap的工作原理是什么？</h2><p>HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node。
　　</p>
<ul>
<li>以下是HashMap初始化 ，简单模拟数据结构<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Node[] table=<span class="keyword">new</span> Node[<span class="number">16</span>]  散列桶初始化，table</span><br><span class="line"></span><br><span class="line">　　 <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　hash;<span class="comment">//hash值</span></span><br><span class="line"></span><br><span class="line">     key;<span class="comment">//键</span></span><br><span class="line"></span><br><span class="line">　　　　value;<span class="comment">//值</span></span><br><span class="line"></span><br><span class="line">　　　　node next;<span class="comment">//用于指向链表的下一层（产生冲突，用拉链法）</span></span><br><span class="line"></span><br><span class="line">　　 &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="put过程（JDK1-8版）"><a href="#put过程（JDK1-8版）" class="headerlink" title="put过程（JDK1.8版）"></a><code>put</code>过程（JDK1.8版）</h4><ul>
<li>对Key用HashCode()求Hash值，然后再计算下标</li>
<li>如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）</li>
<li>如果碰撞了，以链表的方式链接到后面</li>
<li>如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表</li>
<li>如果节点已经存在就替换旧值</li>
<li>如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）</li>
</ul>
<p><strong>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</strong></p>
<h4 id="Get过程-考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？"><a href="#Get过程-考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？" class="headerlink" title="Get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)"></a><code>Get过程</code>(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)</h4><p>当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。</p>
<p>　　</p>
<h2 id="3-有什么方法可以减少碰撞？"><a href="#3-有什么方法可以减少碰撞？" class="headerlink" title="3.有什么方法可以减少碰撞？"></a>3.有什么方法可以减少碰撞？</h2><ul>
<li>扰动函数可以减少碰撞，原理是如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这就意味着存链表结构减小，这样取值的话就不会频繁调用equal方法，这样就能提高HashMap的性能。（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。）</li>
<li>使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。为什么String, Interger这样的wrapper类适合作为键？因为String是final的，而且已经重写了equals()和hashCode()方法了。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。</li>
</ul>
<h2 id="4-HashMap中hash函数怎么是是实现的"><a href="#4-HashMap中hash函数怎么是是实现的" class="headerlink" title="4.HashMap中hash函数怎么是是实现的?"></a>4.HashMap中hash函数怎么是是实现的?</h2><p>　　我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式，我们来看看JDK1.8的源码是怎么做的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     h=key.hashCode()；返回散列值也就是hashcode</span><br><span class="line">      <span class="comment">// ^ ：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="comment">//其中n是数组的长度，即Map的数组部分初始化长度</span></span><br><span class="line">     <span class="keyword">return</span>  (n-<span class="number">1</span>)&amp;(h ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>高16位异或低16位以后，进行取模运算</strong><br>1.高16bit不变，低16bit和高16bit做了一个异或(得到的HashCode转化为32位的二进制，前16位和后16位低16bit和高16bit做了一个异或)<br>2.(n·1)&amp;hash=-&gt;得到下标</p>
<ul>
<li>为什么扩容是2的次幂?</li>
</ul>
<p>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法<br>这个算法实际就是取模，hash%length。 但是，大家都知道这种运算不如位移运算快。<br>因此，源码中做了优化hash&amp;(length-1)。 也就是说hash%length==hash&amp;(length-1)</p>
<h2 id="5-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"><a href="#5-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？" class="headerlink" title="5.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"></a>5.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</h2><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p>
<h2 id="6-对红黑树的见解？"><a href="#6-对红黑树的见解？" class="headerlink" title="6.对红黑树的见解？"></a>6.对红黑树的见解？</h2><ul>
<li>节点是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li><strong>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</strong></li>
</ul>
<h2 id="7-解决hash-碰撞还有那些办法？"><a href="#7-解决hash-碰撞还有那些办法？" class="headerlink" title="7.解决hash 碰撞还有那些办法？"></a>7.解决hash 碰撞还有那些办法？</h2><p><strong>比较出名的有四种 (1)开放定址法 (2)链地址法 (3)再哈希法 (4)公共溢出区域法</strong></p>
<ul>
<li>开放定址法<br>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li>
<li>链地址法<br>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li>
<li>再哈希法<br>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li>
<li>建立公共溢出区<br>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li>
</ul>
<p><strong>下面给一个线性探查法的例子</strong>　</p>
<p><strong>问题：已知一组关键字为(26，36，41，38，44，15，68，12，06，51)，用除余法构造散列函数，用线性探查法解决冲突构造这组关键字的散列表</strong></p>
<p> <strong>解答：为了减少冲突，通常令装填因子α由除余法因子是13的散列函数计算出的上述关键字序列的散列地址为(0，10，2，12，5，2，3，12，6，12)。</strong></p>
<ul>
<li>前5个关键字插入时，其相应的地址均为开放地址，故将它们直接插入T[0]，T[10)，T[2]，T[12]和T[5]中。</li>
<li>当插入第6个关键字15时，其散列地址2(即h(15)=15％13=2)已被关键字41(15和41互为同义词)占用。故探查h1=(2+1)％13=3，此地址开放，所以将15放入T[3]中。</li>
<li>当插入第7个关键字68时，其散列地址3已被非同义词15先占用，故将其插入到T[4]中。</li>
<li>当插入第8个关键字12时，散列地址12已被同义词38占用，故探查hl=(12+1)％13=0，而T[0]亦被26占用，再探查h2=(12+2)％13=1，此地址开放，可将12插入其中。</li>
<li>类似地，第9个关键字06直接插入T[6]中；而最后一个关键字51插人时，因探查的地址12，0，1，…，6均非空，故51插入T[7]中。</li>
</ul>
<h2 id="8-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#8-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h2><p>　　默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为 <strong>&lt;原下标+原容量&gt;</strong> 的位置　　</p>
<h2 id="9-重新调整HashMap大小存在什么问题吗？"><a href="#9-重新调整HashMap大小存在什么问题吗？" class="headerlink" title="9.重新调整HashMap大小存在什么问题吗？"></a>9.重新调整HashMap大小存在什么问题吗？</h2><ul>
<li>当扩容重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。因为直接插入的效率更高。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap）。</li>
<li>为什么多线程会导致死循环，它是怎么发生的？<br>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。1.扩容：创建一个新的Entry空数组，长度是原数组的2倍。2.ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。</li>
</ul>
<blockquote>
<p> <strong>HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</strong></p>
</blockquote>
<blockquote>
<p>在HashMap1.7之前是头插法，在扩容的过程中，可能会造成一个resize()的方法，然后调用transfer()方法，把里面的Entry进行了Rehash，在过程中，可能会造成链表的循环，在一下次Get()中出现死循环，或者出现没有加锁，所以数据不安全</p>
</blockquote>
<h2 id="10-HashTable"><a href="#10-HashTable" class="headerlink" title="10.HashTable"></a>10.HashTable</h2><p>数组 + 链表方式存储<br>默认容量： 11(质数为宜)</p>
<h4 id="Put"><a href="#Put" class="headerlink" title="Put:"></a><code>Put:</code></h4><ul>
<li>对key的hashCode()做hash运算，计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树(JDK1.8中的改动)； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。</li>
<li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li>
<li>若在链表中找到了，则替换旧值，若未找到则继续</li>
<li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li>
<li><strong>将新元素加到链表头部,对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全</strong>。<h4 id="Get"><a href="#Get" class="headerlink" title="Get:"></a><code>Get:</code></h4>对key的hashCode()做hash运算，计算index; 如果在bucket里的第一个节点里直接命中，则直接返回； 如果有冲突，则通过key.equals(k)去查找对应的Entry;<br>• 若为树，则在树中通过key.equals(k)查找，O(logn)；<br>• 若为链表，则在链表中通过key.equals(k)查找，O(n)。</li>
</ul>
<h2 id="11-HashMap-，HashTable-区别"><a href="#11-HashMap-，HashTable-区别" class="headerlink" title="11.HashMap ，HashTable 区别"></a>11.HashMap ，HashTable 区别</h2><ul>
<li>默认容量不同。扩容不同</li>
<li>线程安全性，HashTable 安全  </li>
<li>效率不同 HashTable 要慢因为加锁</li>
</ul>
<h2 id="12-可以使用CocurrentHashMap来代替Hashtable吗？"><a href="#12-可以使用CocurrentHashMap来代替Hashtable吗？" class="headerlink" title="12.可以使用CocurrentHashMap来代替Hashtable吗？"></a>12.可以使用CocurrentHashMap来代替Hashtable吗？</h2><p>我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p>
<h2 id="13-CocurrentHashMap（1-8）"><a href="#13-CocurrentHashMap（1-8）" class="headerlink" title="13.CocurrentHashMap（1.8）"></a>13.CocurrentHashMap（1.8）</h2><ul>
<li>其中抛弃了原有的 Segment 分段锁，而采用了<code>CAS + synchronized</code>来保证并发安全性。</li>
<li>其中的 val next 都用了 <code>volatile</code>修饰，保证了可见性</li>
<li>最大特点是引入了 CAS（借助 Unsafe 来实现【native code】）<br>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li>
<li><p>CAS 会出现的问题：ABA<br>解决：对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。<br>####<code>Put过程</code></p>
</li>
<li><p>根据 key 计算出 hashcode 。判断是否需要进行初始化。</p>
</li>
<li>通过 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li><p>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</p>
<h4 id="Get过程"><a href="#Get过程" class="headerlink" title="Get过程"></a><code>Get过程</code></h4></li>
<li><p>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p>
</li>
<li>如果是红黑树那就按照树的方式获取值。</li>
<li>都不满足那就按照链表的方式遍历获取值。</li>
</ul>
<h2 id="14-TreeMap"><a href="#14-TreeMap" class="headerlink" title="14.TreeMap"></a>14.TreeMap</h2><p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和HashMap不同，它的get、put、remove之类操作都是O(logn)的复杂度，具体顺序可以由指定的Comparator来决定，或者根据键的自然顺序来判断</p>
<h2 id="15-hash算法是干嘛的？还知道哪些hash算法？"><a href="#15-hash算法是干嘛的？还知道哪些hash算法？" class="headerlink" title="15.hash算法是干嘛的？还知道哪些hash算法？"></a>15.hash算法是干嘛的？还知道哪些hash算法？</h2><p>Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。<br>比较出名的算法有SHA,MD4、MD5等</p>
<p>说说String中hashcode的实现?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>String类中的hashCode计算方法还是比较简单的，就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。</li>
<li>哈希计算公式可以计为<figure class="highlight plain"><figcaption><span>+ s[1]*31^(n-2) + ... + s[n-1]```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 那为什么以31为质数呢?</span><br><span class="line">主要是因为31是一个奇质数，所以```31*i=32*i-i=(i&lt;&lt;5)-i```，这种位移与减法结合的计算相比一般的运算快很多。</span><br><span class="line"></span><br><span class="line">## 16.健可以为Null值么?</span><br><span class="line"></span><br><span class="line">可以，key为null的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。</span><br><span class="line"></span><br><span class="line">## 17.一般用什么作为HashMap的key?</span><br><span class="line"></span><br><span class="line">一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。</span><br><span class="line">• (1) 因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</span><br><span class="line">• (2) 因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的覆写了hashCode()以及equals()方法。</span><br><span class="line"></span><br><span class="line">## Hashcode</span><br><span class="line">* 一、hashCode简介</span><br><span class="line">public int hashCode()：``hashCode``是根类Obeject中的方法。默认情况下，Object中的``hashCode() ``返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。</span><br><span class="line">* 二、hashCode注意点</span><br><span class="line">关于hashCode方法，一致的约定是：</span><br><span class="line">1、重写了``euqls``方法的对象必须同时重写``hashCode()``方法。</span><br><span class="line">2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</span><br><span class="line">3、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</span><br><span class="line">* 三、hashCode作用</span><br><span class="line">从Object角度看，JVM每new一个Object，它都会将这个Object丢到一个Hash表中去，这样的话，下次做Object的比较或者取这个对象的时候（读取过程），它会根据对象的HashCode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。若HashCode相同再去调用equal。</span><br><span class="line">HashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。</span><br><span class="line">* 四、为什么重写</span><br><span class="line">实际开发的过程中在hashmap或者hashset里如果不重写的hashcode和equals方法的话会导致我们存对象的时候，把对象存进去了，取的时候却取不到想要的对象。</span><br><span class="line">重写了hashcode和equals方法可以迅速的在hashmap中找到键的位置；</span><br><span class="line">#### **重写hashcode是为了保证相同的对象会有相同的hashcode；**</span><br><span class="line">#### **重写equals是为了保证在发生冲突的情况下取得到Entry对象（也可以理解是key或是元素）**；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存在一个table数组，里面每个元素都是一个node链表，当添加一个元素（key-value）时，就首先计算元素key的hash值，通过table的长度和key的hash值进行与运算得到一个index，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就把这个元素添加到同一hash值的node链表的链尾，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度大于等于8时，链表就可能转换为红黑树，这样大大提高了查找的效率。</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191102133424361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM1ODMzMTE=,size_16,color_FFFFFF,t_70&quot; alt=&quot;存储结构&quot; /&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&amp;lt;K,V&amp;gt; next; //可以看得出这是一个链表</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li>
</ul>
<li>HashMap内部包含一个Node类型的数组table，Node由Map.Entry继承而来。</li><br><li>Node存储着键值对。它包含四个字段，从next字段我们可以看出node是一个链表。</li><br><li>table数组中的每个位置都可以当做一个桶，一个桶存放一个链表。</li><br><li>HashMap使用拉链法来解决冲突，同一个存放散列值相同的Node。</li><br><h4 id="数据域">数据域</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;  </span><br><span class="line"><span class="comment">// 初始化容量，初始化有16个桶</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &amp;lt;&amp;lt; <span class="number">4</span>; <span class="comment">// aka 16  </span></span><br><span class="line"><span class="comment">// 最大容量  1 073 741 824, 10亿多</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &amp;lt;&amp;lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 当put()一个元素到某个桶，其链表长度达到8时有可能将链表转换为红黑树  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;  </span><br><span class="line"><span class="comment">// 在hashMap扩容时，如果发现链表长度小于等于6，则会由红黑树重新退化为链表。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;  </span><br><span class="line"><span class="comment">// 在转变成红黑树树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换，否者直接扩容。这是为了避免在HashMap建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;  </span><br><span class="line"><span class="comment">// 存储元素的数组  </span></span><br><span class="line"><span class="keyword">transient</span> Node&amp;lt;k,v&amp;gt;[] table;</span><br><span class="line"><span class="comment">// 存放元素的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 被修改的次数fast-fail机制   </span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 临界值 当实际大小(容量*填充比)超过临界值时，会进行扩容   </span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 填充比</span></span><br><span class="line">final float loadFactor;&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;h4 id="构造函数"&gt;构造函数&lt;/h4&gt;</span><br><span class="line">&lt;pre <span class="class"><span class="keyword">class</span></span>=<span class="string">"java"</span>&gt;&lt;code&gt;<span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &amp;lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(&amp;quot;Illegal initial capacity: &amp;quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &amp;gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &amp;lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(&amp;quot;Illegal load factor: &amp;quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// tableSizeFor(initialCapacity)方法计算出接近initialCapacity</span></span><br><span class="line">        <span class="comment">// 参数的2^n来作为初始化容量。</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&amp;lt;? extends K, ? extends V&amp;gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li><p>HashMap构造函数允许用户传入容量不是2的n次方，因为它可以自动地将传入的容量转换为2的n次方。</p><br></li></ul><br>### <code>Put()</code>源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// “扰动函数”。参考 https://www.cnblogs.com/zhengwang/p/8136164.html</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; <span class="number">16</span>);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] tab; HashMap.Node&amp;lt;K,V&amp;gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 未初始化则初始化table</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 通过table的长度和hash与运算得到一个index，</span></span><br><span class="line">        <span class="comment">// 然后判断table数组下标为index处是否已经存在node。</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp;amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果table数组下标为index处为空则新创建一个node放在该处</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 运行到这代表table数组下标为index处已经存在node，即发生了碰撞</span></span><br><span class="line">            HashMap.Node&amp;lt;K,V&amp;gt; e; K k;</span><br><span class="line">            <span class="comment">// 检查这个node的key是否跟插入的key是否相同。</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                    ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 检查这个node是否已经是一个红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果这个node已经是一个红黑树则继续往树种添加节点</span></span><br><span class="line">                e = ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 在这里循环遍历node链表</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断是否到达链表尾</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 到达链表尾，直接把新node插入链表，插入链表尾部，在jdk8之前是头插法</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &amp;gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            <span class="comment">// 如果node链表的长度大于等于8则可能把这个node转换为红黑树</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 检查这个node的key是否跟插入的key是否相同。</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当插入key存在，则更新value值并返回旧value</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改次数++</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 如果当前大小大于门限，门限原本是初始容量*0.75</span></span><br><span class="line">        <span class="keyword">if</span> (++size &amp;gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>下面简单说下put()流程：<br><ol><br><li>判断键值对数组table[]是否为空或为null，否则以默认大小resize()；</li><br><li>根据键key计算hash值与table的长度进行与运算得到插入的数组索引 index，如果tab[index] == null，直接根据key-value新建node添加，否则转入3</li><br><li>判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可),分别处理</li><br></ol></li>

<p><li>为啥头插法为什么要换成尾插：jdk1.7时候用头插法可能是考虑到了一个所谓的热点数据的点(新插入的数据可能会更早用到)；找到链表尾部的时间复杂度是 O(n)，或者需要使用额外的内存地址来保存链表尾部的位置，头插法可以节省插入耗时。但是在扩容时会改变链表中元素原本的顺序，以至于在<strong>并发场景下导致链表成环</strong>的问题。</li></p>
<p><li>从putVal()源码可以看出，HashMap并没有对null的键值对做限制（hash值设为0），即HashMap允许插入键尾null的键值对。但在JDK1.8之前HashMap使用第0个node存放键为null的键值对。</li></p>
<p><li>确定node下标：通过table的长度和key的hash进行与运算得到一个index。</li></p>
<p><li>在转变成红黑树树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换，否者直接扩容。这是为了避免在HashMap建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</li><br></p></ul><p></p>
<h2 id="大多数人不知道的：HashMap链表成环的原因和解决方案"><a href="#大多数人不知道的：HashMap链表成环的原因和解决方案" class="headerlink" title="大多数人不知道的：HashMap链表成环的原因和解决方案"></a><a href="https://www.cnblogs.com/wen-he/p/11496050.html" target="_blank" rel="noopener">大多数人不知道的：HashMap链表成环的原因和解决方案</a></h2><h3 id="get-操作源码解析"><a href="#get-操作源码解析" class="headerlink" title="get()操作源码解析"></a>get()操作源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HashMap.Node&amp;lt;K,V&amp;gt; getNode(<span class="keyword">int</span> hash, Object key) &#123;</span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] tab; HashMap.Node&amp;lt;K,V&amp;gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="comment">// table不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;amp;&amp;amp; (n = tab.length) &amp;gt; <span class="number">0</span> &amp;amp;&amp;amp;</span><br><span class="line">                <span class="comment">// 通过table的长度和hash与运算得到一个index，table</span></span><br><span class="line">                <span class="comment">// 下标位index处的元素不为空，即元素为node链表</span></span><br><span class="line">                (first = tab[(n - <span class="number">1</span>) &amp;amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 首先判断node链表中中第一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;amp;&amp;amp; <span class="comment">// always check first node</span></span><br><span class="line">                    <span class="comment">// 分别判断key为null和key不为null的情况</span></span><br><span class="line">                    ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// key相等则返回第一个</span></span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">// 第一个节点key不同且node链表不止包含一个节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断node链表是否转为红黑树。</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">                    <span class="comment">// 则在红黑树中进行查找。</span></span><br><span class="line">                    <span class="keyword">return</span> ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 循环遍历node链表中的节点，判断key是否相等</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key在table中不存在则返回null。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>get(key)方法首先获取key的hash值，</li>
<li>计算hash &amp; (table.len - 1)得到在链表数组中的位置，</li>
<li>先判断node链表（桶）中的第一个节点的key是否与参数key相等，</li>
<li>不等则判断是否已经转为红黑树，若转为红黑树则在红黑树中查找，</li>
<li>如没有转为红黑树就遍历后面的链表找到相同的key值返回对应的Value值即可。</li>
</ul>
<h3 id="resize-操作源码解析"><a href="#resize-操作源码解析" class="headerlink" title="resize()操作源码解析"></a>resize()操作源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化或者扩容之后的元素调整</span></span><br><span class="line">    <span class="keyword">final</span> HashMap.Node&amp;lt;K,V&amp;gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">// 获取旧table</span></span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">// 旧table容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">// 旧table扩容临界值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">// 定义新table容量和临界值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果原table不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果table容量达到最大值，则修改临界值为Integer.MAX_VALUE</span></span><br><span class="line">            <span class="comment">// MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;</span></span><br><span class="line">            <span class="comment">// Integer.MAX_VALUE = 1 &amp;lt;&amp;lt; 31 - 1;</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &amp;gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// Map达到最大容量，这时还要向map中放数据，则直接设置临界值为整数的最大值</span></span><br><span class="line">                <span class="comment">// 在容量没有达到最大值之前不会再resize。</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">// 结束操作</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面就是扩容操作（2倍）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &amp;lt;&amp;lt; <span class="number">1</span>) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;</span><br><span class="line">                    oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">// 临界值也变为两倍</span></span><br><span class="line">                newThr = oldThr &amp;lt;&amp;lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &amp;gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 进入此if证明创建HashMap时用的带参构造：public HashMap(int initialCapacity)</span></span><br><span class="line"><span class="comment">             * 或 public HashMap(int initialCapacity, float loadFactor)</span></span><br><span class="line"><span class="comment">             * 注：带参的构造中initialCapacity（初始容量值）不管是输入几都会通过</span></span><br><span class="line"><span class="comment">             * tableSizeFor(initialCapacity)方法计算出接近initialCapacity</span></span><br><span class="line"><span class="comment">             * 参数的2^n来作为初始化容量。</span></span><br><span class="line"><span class="comment">             * 所以实际创建的容量并不等于设置的初始容量。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">// 进入此if证明创建map时用的无参构造：</span></span><br><span class="line">            <span class="comment">// 然后将参数newCap（新的容量）、newThr(新的扩容阀界值)进行初始化</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 进入这代表有两种可能。</span></span><br><span class="line">            <span class="comment">// 1. 说明old table容量大于0但是小于16.</span></span><br><span class="line">            <span class="comment">// 2. 创建HashMap时用的带参构造，根据loadFactor计算临界值。</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改临界值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;&amp;quot;rawtypes&amp;quot;,&amp;quot;unchecked&amp;quot;&#125;)</span><br><span class="line">        <span class="comment">// 根据新的容量生成新的 table</span></span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] newTab = (HashMap.Node&amp;lt;K,V&amp;gt;[])<span class="keyword">new</span> HashMap.Node[newCap];</span><br><span class="line">        <span class="comment">// 替换成新的table</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">// 如果oldTab不为null说明是扩容，否则直接返回newTab</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 遍历原来的table */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; oldCap; ++j) &#123;</span><br><span class="line">                HashMap.Node&amp;lt;K,V&amp;gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 判断这个桶（链表）中就只有一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// 根据新的容量重新计算在table中的位置index，并把当前元素赋值给他。</span></span><br><span class="line">                        newTab[e.hash &amp;amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">// 判断这个链表是否已经转为红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">                        <span class="comment">// 在split函数中可能由于红黑树的长度小于等于UNTREEIFY_THRESHOLD（6）</span></span><br><span class="line">                        <span class="comment">// 则把红黑树重新转为链表</span></span><br><span class="line">                        ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">// 运行到这里证明桶中有多个节点。</span></span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">// 对桶进行遍历</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp;amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashMap-的工作原理是什么"><a href="#HashMap-的工作原理是什么" class="headerlink" title="HashMap 的工作原理是什么?"></a>HashMap 的工作原理是什么?</h2><p>HashMap基于hashing原理，我们通过put()和get()方法存储和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来存储值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会存储在链表的第一个节点，链接原先的对象节点，HashMap在每个链表节点中存储键值对对象。</p>
<h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？"></a>快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？</h2><ul>
<li>1、快速失败（fail-fast）<br>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行修改（增加、删除、修改），则会抛出Concurrent Modification Exception.<br>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。<br>注意：这里异常的抛出条件是检测到modCount!=expectedmodCount这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。<br>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</li>
<li>2、安全失败（fail-safe）<br>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<br>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。<br>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception,但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的<br>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li>
</ul>
<p><img src="https://img1.sycdn.imooc.com/5d56493300011c0e19151612.png" alt="源码导读"></p>
<p><a href="https://blog.csdn.net/weixin_44460333/article/details/86770169" target="_blank" rel="noopener">HashMap？ConcurrentHashMap？相信看完这篇没人能难住你</a></p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Analyst-of-SourceCode/" rel="tag"># Analyst of SourceCode</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/01/16/Algorithms-Part-I-Princeton-Online/" rel="next" title="Algorithms, Part I | Princeton Online">
                  <i class="fa fa-chevron-left"></i> Algorithms, Part I | Princeton Online
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/02/05/The-Difference-between-Process-and-Thread/" rel="prev" title="The Difference between Process and Thread">
                  The Difference between Process and Thread <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-为什么用HashMap？"><span class="nav-number">1.</span> <span class="nav-text">1.为什么用HashMap？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-HashMap的工作原理是什么？"><span class="nav-number">2.</span> <span class="nav-text">2.HashMap的工作原理是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#put过程（JDK1-8版）"><span class="nav-number">2.0.1.</span> <span class="nav-text">put过程（JDK1.8版）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Get过程-考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？"><span class="nav-number">2.0.2.</span> <span class="nav-text">Get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-有什么方法可以减少碰撞？"><span class="nav-number">3.</span> <span class="nav-text">3.有什么方法可以减少碰撞？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-HashMap中hash函数怎么是是实现的"><span class="nav-number">4.</span> <span class="nav-text">4.HashMap中hash函数怎么是是实现的?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"><span class="nav-number">5.</span> <span class="nav-text">5.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-对红黑树的见解？"><span class="nav-number">6.</span> <span class="nav-text">6.对红黑树的见解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-解决hash-碰撞还有那些办法？"><span class="nav-number">7.</span> <span class="nav-text">7.解决hash 碰撞还有那些办法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><span class="nav-number">8.</span> <span class="nav-text">8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-重新调整HashMap大小存在什么问题吗？"><span class="nav-number">9.</span> <span class="nav-text">9.重新调整HashMap大小存在什么问题吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-HashTable"><span class="nav-number">10.</span> <span class="nav-text">10.HashTable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Put"><span class="nav-number">10.0.1.</span> <span class="nav-text">Put:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Get"><span class="nav-number">10.0.2.</span> <span class="nav-text">Get:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-HashMap-，HashTable-区别"><span class="nav-number">11.</span> <span class="nav-text">11.HashMap ，HashTable 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-可以使用CocurrentHashMap来代替Hashtable吗？"><span class="nav-number">12.</span> <span class="nav-text">12.可以使用CocurrentHashMap来代替Hashtable吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-CocurrentHashMap（1-8）"><span class="nav-number">13.</span> <span class="nav-text">13.CocurrentHashMap（1.8）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Get过程"><span class="nav-number">13.0.1.</span> <span class="nav-text">Get过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-TreeMap"><span class="nav-number">14.</span> <span class="nav-text">14.TreeMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-hash算法是干嘛的？还知道哪些hash算法？"><span class="nav-number">15.</span> <span class="nav-text">15.hash算法是干嘛的？还知道哪些hash算法？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据域"><span class="nav-number">15.0.1.</span> <span class="nav-text">数据域</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大多数人不知道的：HashMap链表成环的原因和解决方案"><span class="nav-number">16.</span> <span class="nav-text">大多数人不知道的：HashMap链表成环的原因和解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#get-操作源码解析"><span class="nav-number">16.1.</span> <span class="nav-text">get()操作源码解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resize-操作源码解析"><span class="nav-number">16.2.</span> <span class="nav-text">resize()操作源码解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-的工作原理是什么"><span class="nav-number">17.</span> <span class="nav-text">HashMap 的工作原理是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><span class="nav-number">18.</span> <span class="nav-text">快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">William Ren</p>
  <div class="site-description" itemprop="description">If not Me, Who? If not now, When?</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/Williamren97" title="GitHub &rarr; https://github.com/Williamren97" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:Williamren97@gmail.com" title="E-Mail &rarr; mailto:Williamren97@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://www.linkedin.com/in/%E5%81%89-%E4%BB%BB-984941166/" title="Linkedin &rarr; https://www.linkedin.com/in/%E5%81%89-%E4%BB%BB-984941166/" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkedin"></i>Linkedin</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://twitter.com/WilliamRen10" title="Twitter &rarr; https://twitter.com/WilliamRen10" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://www.douban.com/people/renwei97/" title="Douban &rarr; https://www.douban.com/people/renwei97/" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>Douban</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://steamcommunity.com/profiles/76561198366135828" title="Steam &rarr; https://steamcommunity.com/profiles/76561198366135828" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>Steam</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">William Ren</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}
</script>






  

  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'lyytoY9PhsHWSRFu2rvamD0C-gzGzoHsz',
    appKey: 'iqotmhQC2IjjG6MQB1rOkiBt',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
