<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>REN WEI&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-23T16:51:36.582Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>William Ren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019-2In TaiwanTech</title>
    <link href="http://yoursite.com/2020/02/17/2019-2In-TaiwanTech/"/>
    <id>http://yoursite.com/2020/02/17/2019-2In-TaiwanTech/</id>
    <published>2020-02-17T10:10:48.000Z</published>
    <updated>2020-02-23T16:51:36.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大四上學期的成績單"><a href="#大四上學期的成績單" class="headerlink" title="大四上學期的成績單"></a>大四上學期的成績單</h2><p><img src="https://i.loli.net/2020/02/17/M5U9XmiwQfFJ3bZ.png" alt="1082.png"></p><p>後面再補內容，已經錯過實習和秋招了。現在抓緊搞搞春招。</p><blockquote><p>學校的課實在太多，30學分忙8過來</p></blockquote><p>回家以后发现钙hub也打不开了…..除了科学上网的解决方法，另外一种就是<a href="https://blog.csdn.net/ustccw/article/details/84543284" target="_blank" rel="noopener">设置静态IP地址</a></p><p>图床也加载不出来了，这里推荐<a href="https://sm.ms/" target="_blank" rel="noopener">SM SM的图床服务</a></p><h2 id="新年新FLAG"><a href="#新年新FLAG" class="headerlink" title="新年新FLAG"></a>新年新FLAG</h2><h4 id="专业技术"><a href="#专业技术" class="headerlink" title="专业技术"></a>专业技术</h4><ul><li><p>按照zuochengyun大哥的建议读JDK重要包的源代码,</p><figure class="highlight plain"><figcaption><span>java.util. java.io```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```java.lang.reflect, java.net, java.net.* java.nio.* java.util.concurrent.*</span><br></pre></td></tr></table></figure></li><li><p>Spring源码,</p></li><li><p>学习分布式缓存技术.</p></li><li><p>PASS THE FRM Certification RANK1</p></li></ul><h4 id="语言水平"><a href="#语言水平" class="headerlink" title="语言水平"></a>语言水平</h4><ul><li>日语达到N3水平<blockquote><p><a href="https://www.zhihu.com/question/59051017/answer/161476178" target="_blank" rel="noopener">如何自学备考日语N3？</a></p></blockquote></li><li>TOEFL破百</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大四上學期的成績單&quot;&gt;&lt;a href=&quot;#大四上學期的成績單&quot; class=&quot;headerlink&quot; title=&quot;大四上學期的成績單&quot;&gt;&lt;/a&gt;大四上學期的成績單&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/17/M5
      
    
    </summary>
    
    
      <category term="TaiwanTech" scheme="http://yoursite.com/tags/TaiwanTech/"/>
    
  </entry>
  
  <entry>
    <title>Principle of JVM</title>
    <link href="http://yoursite.com/2020/02/08/Principle-of-JVM/"/>
    <id>http://yoursite.com/2020/02/08/Principle-of-JVM/</id>
    <published>2020-02-07T18:08:41.000Z</published>
    <updated>2020-02-17T10:19:31.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM原理速记复习Java虚拟机总结思维导图面试必备"><a href="#JVM原理速记复习Java虚拟机总结思维导图面试必备" class="headerlink" title="JVM原理速记复习Java虚拟机总结思维导图面试必备"></a>JVM原理速记复习Java虚拟机总结思维导图面试必备</h1><p><div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"></div></p><p><img src="https://images.cnblogs.com/cnblogs_com/neverth/1592425/o_191116143745Java%E8%99%9A%E6%8B%9F%E6%9C%BA-min.png" alt="JVM"><br><br></p><h1 id="java虚拟机">Java虚拟机</h1><br><h2 id="一运行时数据区域">一、运行时数据区域</h2><br><h3 id="线程私有">线程私有</h3><br><ul><br><li><p>程序计数器</p><br><ul><br><li>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是Native方法则为空），是唯一一个没有规定OOM（OutOfMemoryError）的区域。</li><br></ul></li><br><li><p>Java虚拟机栈</p><br><ul><br><li>每个Java方法在执行的同时会创建一个栈桢用于存储局部变量表、操作数栈、动态链接、方法出口等信息。从方法调用直到执行完成的过程，对应着一个栈桢在Java虚拟机栈中入栈和出栈的过程。（局部变量包含基本数据类型、对象引用reference和returnAddress类型）</li><br></ul></li><br><li><p>本地方法栈</p><br><ul><br><li>本地方法栈与Java虚拟机栈类似，它们之间的区别只不过是本地方法栈为Native方法服务。</li><br></ul></li><br></ul><br><h3 id="线程公有">线程公有</h3><br><ul><br><li><p>Java堆（GC区）（Java Head）</p><br><ul><br><li>几乎所有的对象实例都在这里分配内存，是垃圾收集器管理的主要区域。分为新生代和老年代。对于新生代又分为Eden空间、From Survivor空间、To Survivor空间。</li><br></ul></li><br><li><p>JDK1.7 方法区（永久代）</p><br><ul><br><li>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br><br>对这块区域进行垃圾回收的主要目的是对常量池的回收和对类的卸载，但是一般难以实现。<br><br>HotSpot虚拟机把它当做永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素的影响，并且每次Full GC之后永久代的大小都会改变，所以经常抛出OOM异常。<br><br>从JDK1.8开始，移除永久代，并把方法区移至元空间。</li><br><li><p>运行时常量池</p><br><ul><br><li>是方法区的一部分<br><br>Class文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。<br><br>允许动态生成，例如String类的intern()</li><br></ul></li><br></ul></li><br><li><p>JDK1.8 元空间</p><br><ul><br><li>原本存在方法区（永久代）的数据，一部分移到了Java堆里面，一部分移到了本地内存里面（即元空间）。元空间存储类的元信息，静态变量和常量池等放入堆中。</li><br></ul></li><br><li><p>直接内存</p><br><ul><br><li>在NIO中，会使用Native函数库直接分配堆外内存。</li><br></ul></li><br></ul><br><h2 id="二hotspot虚拟机">二、HotSpot虚拟机</h2><br><h3 id="对象的创建">对象的创建</h3><br><ul><br><li>当虚拟机遇到一条new指令时</li><br></ul><br><ol><br><li>检查参数能否在常量池中找到符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始过，没有的话先执行相应的类加载过程。</li><br><li>在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。</li><br><li>内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</li><br><li>对对象头进行必要的设置。</li><br><li>执行构造方法按照程序员的意愿进行初始化。</li><br></ol><br><h3 id="对象的内存布局">对象的内存布局</h3><br><ul><br><li><ol><br><li>对象头</li><br></ol><br><ul><br><li><ol><br><li>第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向实现戳等。</li><br></ol></li><br><li><ol><br><li>第二部分是类型指针，即对象指向它的类元数据的指针（如果使用直接对象指针访问），虚拟机通过这个指针来确定这个对象是哪个类的实例。</li><br></ol></li><br><li><ol><br><li>如果对象是一个Java数组的话，还需要第三部分记录数据长度的数据。</li><br></ol></li><br></ul></li><br><li><ol><br><li>实例数据</li><br></ol><br><ul><br><li>是对象真正存储的有效信息，也就是在代码中定义的各种类型的字段内容。</li><br></ul></li><br><li><ol><br><li>对齐填充</li><br></ol><br><ul><br><li>不是必然存在的，仅仅起着占位符的作用。<br><br>HotSpot需要对象的大小必须是8字节的整数倍。</li><br></ul></li><br></ul><br><h3 id="对象的访问定位">对象的访问定位</h3><br><ul><br><li><p>句柄访问</p><br><ul><br><li>在Java堆中划分出一块内存作为句柄池。<br><br>Java栈上的对象引用reference中存储的就是对象的句柄地址，而句柄中包含了到对象实例数据的指针和到对象类型数据的指针。<br><br>对象实例数据在Java堆中，对象类型数据在方法区（永久代）中。<br><br>优点：在对象被移动时只会改变句柄中的实例数据指针，而对象引用本身不需要修改。</li><br></ul></li><br><li><p>直接指针访问（HotSpot使用）</p><br><ul><br><li>Java栈上的对象引用reference中存储的就是对象的直接地址。<br><br>在堆中的对象实例数据就需要包含到对象类型数据的指针。<br><br>优点：节省了一次指针定位的时间开销，速度更快。</li><br></ul></li><br></ul><br><h2 id="三垃圾收集">三、垃圾收集</h2><br><h3 id="概述">概述</h3><br><ul><br><li>垃圾收集主要是针对Java堆和方法区。<br><br>程序计数器、Java虚拟机栈个本地方法栈三个区域属于线程私有，线程或方法结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</li><br></ul><br><h3 id="判断对象是否可以被回收">判断对象是否可以被回收</h3><br><ul><br><li><p>第一次标记（缓刑）</p><br><ul><br><li><p>引用计数算法</p><br><ul><br><li>给对象添加一个引用计数器，当对象增加一个引用时引用计数值++，引用失效时引用计数值–，引用计数值为0时对象可以被回收。</li><br></ul></li><br></ul></li><br></ul><br><p>但是它难以解决对象之间的相互循环引用的情况，此时这个两个对象引用计数值为1，但是永远无法用到这两个对象。</p><ul><li><p>可达性分析算法（Java使用）</p><ul><li>以一系列GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连是，则证明此对象不可用，可以被回收。<p>GC Roots对象包括</p><br><ol><br><li>虚拟机栈（栈桢中的本地变量表）中引用的对象。</li><br><li>方法区中共类静态属性引用的对象。</li><br><li>方法区中常量引用的对象。</li><br><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li><br></ol><br><ul><br><li><p>第二次标记</p><br><ul><br><li>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过。<br><br>如果对象在finalize方法中重新与引用链上的任何一个对象建立关联则将不会被回收。</li><br><li><p>finalize()</p><br><ul><br><li>任何一个对象的finalize()方法都只会被系统调用一次。<br><br>它的出现是一个妥协，运行代价高昂，不确定性大，无法保证各个对象的调用顺序。<br><br>finalize()能做的所有工作使用try-finally或者其他方式都可以做的更好，完全可以忘记在这个函数的存在。</li><br></ul></li><br></ul></li><br></ul><br><h3 id="方法区的回收">方法区的回收</h3><br><ul><br><li>在方法区进行垃圾回收的性价比一般比较低。<br><br>主要回收两部分，废弃常量和无用的类。</li><br></ul><br><p>满足无用的类三个判断条件才仅仅代表可以进行回收，不是必然关系，可以使用-Xnoclassgc参数控制。</p><br><ol><br><li>该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><br><li>加载该类的ClassLoader已经被回收。</li><br><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问到该类的方法。</li><br></ol><br><h3 id="引用类型">引用类型</h3><br><ul><br><li><ol><br><li>强引用</li><br></ol><br><ul><br><li>使用new一个新对象的方式来创建强引用。<br><br>只要强引用还存在，被引用的对象则永远不会被回收。</li><br></ul></li><br><li><ol><br><li>软引用</li><br></ol><br><ul><br><li>使用SoftReference类来实现软引用。<br><br>用来描述一些还有用但是并非必须的对象，被引用的对象在将要发生内存溢出异常之前会被回收。</li><br></ul></li><br><li><ol><br><li>弱引用</li><br></ol><br><ul><br><li>使用WeakReference类来实现弱引用。<br><br>强度比软引用更弱一些，被引用的对象在下一次垃圾收集时会被回收。</li><br></ul></li><br><li><ol><br><li>虚引用</li><br></ol><br><ul><br><li>使用PhantomReference类来实现虚引用。<br><br>最弱的引用关系，不会对被引用的对象生存时间构成影响，也无法通过虚引用来取得一个对象实例。<br><br>唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li><br></ul></li><br></ul><br><h3 id="垃圾收集算法">垃圾收集算法</h3><br><ul><br><li><ol><br><li>标记 - 清除</li><br></ol><br><ul><br><li>首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象并取消标记。</li><br></ul></li><br></ul><br><p>不足：</p><br><ol><br><li>效率问题，标记和清除两个过程的效率都不高。</li><br><li>空间问题，标记清除之后会产生大量不连续的内存碎片，没有连续内存容纳较大对象而不得不提前触发另一次垃圾收集。</li><br></ol><br><ul><br><li><ol><br><li>标记 - 整理</li><br></ol><br><ul><br><li>和标记 - 清除算法一样，但标记之后让所有存活对象都向一段移动，然后直接清理掉端边界以外的内存。<br><br>解决了标记 - 清除算法的空间问题，但需要移动大量对象，还是存在效率问题。</li><br></ul></li><br><li><ol><br><li>复制</li><br></ol><br><ul><br><li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用多的内存空间一次清理掉。<br><br>代价是将内存缩小为原来的一般，太高了。</li><br></ul></li><br></ul><br><p>现在商业虚拟机都采用这种算法用于新生代。<br><br>因为新生代中的对象98%都是朝生暮死，所以将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间。<br><br>当回收时，如果另外一块Survivor空间没有足够的空间存放存活下来的对象时，这些对象将直接通过分配担保机制进入老年代。</p><br><ul><br><li><ol><br><li>分代收集</li><br></ol><br><ul><br><li>一般把Java堆分为新生代和老年代。<br><br>在新生代中使用复制算法，在老年代中使用标记 -清除 或者 标记 - 整理 算法来进行回收。</li><br></ul></li><br></ul><br><h3 id="hotspot的算法实现">HotSpot的算法实现</h3><br><ul><br><li><p>枚举根节点（GC Roots）</p><br><ul><br><li>目前主流Java虚拟机使用的都是准确式GC。<br><br>GC停顿的时候，虚拟机可以通过OopMap数据结构（映射表）知道，在对象内的什么偏移量上是什么类型的数据，而且特定的位置记录着栈和寄存器中哪些位置是引用。因此可以快速且准确的完成GC Roots枚举。</li><br></ul></li><br><li><p>安全点</p><br><ul><br><li>为了节省GC的空间成本，并不会为每条指令都生成OopMap，只是在“特定的位置”记录OopMap，这些位置称为安全点。</li><br></ul></li><br></ul><br><p>程序执行只有到达安全点时才能暂停，到达安全点有两种方案。</p><br><ol><br><li>抢断式中断（几乎不使用）。GC时，先把所有线程中断，如果有线程不在安全点，就恢复该线程，让他跑到安全点。</li><br><li>主动式中断（主要使用）。GC时，设置一个标志，各个线程执行到安全点时轮询这个标志，发现标志为直则挂起线程。</li><br></ol><br><p>但是当线程sleep或blocked时无法响应JVM的中断请求走到安全点中断挂起，所以引出安全区域。</p><br><ul><br><li><p>安全区域</p><br><ul><br><li>安全区域是指在一段代码片段之中，引用关系不会发生变化，是扩展的安全点。</li><br></ul></li><br></ul><br><p>线程进入安全区域时表示自己进入了安全区域，这个发生GC时，JVM就不需要管这个线程。<br><br>线程离开安全区域时，检查系统是否完成GC过程，没有就等待可以离开安全区域的信号为止，否者继续执行。</p><br><h3 id="垃圾收集器">垃圾收集器</h3><br><ul><br><li><p>新生代</p><br><ul><br><li><ol><br><li>serial收集器</li><br></ol><br><ul><br><li>它是单线程收集器，只会使用一个线程进行垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程。</li><br></ul></li><br></ul></li><br></ul><br><p>优点：对比其他单线程收集器简单高效，对于单个CPU环境来说，没有线程交互的开销，因此拥有最高的单线程收集效率。</p><br><p>它是Client场景下默认新生代收集器，因为在该场景下内存一般来说不会很大。</p></li><li><ol start="2"><li>parnew收集器</li></ol></li><li><p>它是Serial收集器的多线程版本，公用了相当多的代码。</p><p>在单CPU环境中绝对不会有比Serial收集器更好的效果，甚至在2个CPU环境中也不能百分之百超越。</p><br><p>它是Server场景下默认的新生代收集器，主要因为除了Serial收集器，只用它能与CMS收集器配合使用。</p></li><li><ol start="3"><li>parallel scavenge收集器</li></ol></li><li><p>“吞吐优先”收集器，与ParNew收集器差不多。</p><p>但是其他收集器的目标是尽可能缩短垃圾收集时用户线程停顿的时间，而它的目标是达到一个可控制的吞吐量。这里的吞吐量指CPU用于运行用户程序的时间占总时间的比值。</p><br><ul><br><li><p>老年代</p><br><ul><br><li><ol><br><li>serial old收集器</li><br></ol><br><ul><br><li>是Serial收集器老年代版本。</li><br></ul></li><br></ul></li><br></ul><br><p>也是给Client场景下的虚拟机使用的。</p></li><li><ol start="5"><li>parallel old收集器</li></ol></li><li><p>是Parallel Scavenge收集器的老年代版本。</p><p>在注重吞吐量已经CPU资源敏感的场合，都可以优先考虑Parallel Scavenge和Parallel Old收集器。</p></li><li><ol start="6"><li>cms收集器</li></ol></li><li><p>Concurrent Mark Sweep收集器是一种以获取最短回收停顿时间为目标的收集器。</p></li><li><p>运作过程</p><ul><li><ol><li>初始标记（最短）。仍需要暂停用户线程。只是标记一下GC Roots能直接关联到的对象，速度很快<br><ol><br><li>并发标记（耗时最长）。进行GC Roots Tracing（根搜索算法）的过程。</li><br><li>重新标记。修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比初始标记长但远小于并发标记时间。</li><br><li>并发清除</li><br></ol><p>1 和4 两个步骤并没有带上并发两个字，即这两个步骤仍要暂停用户线程。</p></li></ol></li></ul></li><li><p>优缺点</p><ul><li>并发收集、低停顿。<br><ol><br><li>CMS收集器对CPU资源非常敏感。虽然不会导致用户线程停顿，但是占用CPU资源会使应用程序变慢。</li><br><li>无法处理浮动垃圾。在并发清除阶段新垃圾还会不断的产生，所以GC时要控制“-XX:CMSinitiatingOccupancyFraction参数”预留足够的内存空间给这些垃圾，当预留内存无法满足程序需要时就会出现”Concurrent Mode Failure“失败，临时启动Serial Old收集。</li><br><li>由于使用标记 - 清除算法，收集之后会产生大量空间碎片。</li><br></ol><br><ul><br><li><ol><br><li>g1收集器</li><br></ol><br><ul><br><li>Garbage First是一款面向服务端应用的垃圾收集器</li><br><li><p>运作过程</p><br><ul><br><li><ol><br><li>初始标记</li><br></ol></li><br></ul></li><br></ul></li><br></ul><br><ol><br><li>并发标记</li><br><li>最终标记</li><br><li>删选标记</li><br></ol><br><h2 id="五类加载机制">五、类加载机制</h2><br><h3 id="概述-1">概述</h3><br><ul><br><li>虚拟机把描述类的数据从Class问价加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。<br><br>Java应用程序的高度灵活性就是依赖运行期动态加载和动态连接实现的。</li><br></ul><br><h3 id="类的生命周期">类的生命周期</h3><br><ul><br><li>加载 -&gt; 连接（验证 -&gt; 准备 -&gt; 解析） -&gt; 初始化 -&gt; 使用 - &gt;卸载</li><br></ul><br><h3 id="类初始化时机">类初始化时机</h3><br><ul><br><li><p>主动引用</p><br><ul><br><li>虚拟机规范中没有强制约束何时进行加载，但是规定了有且只有五种情况必须对类进行初始化（加载、验证、准备都会随之发生）</li><br></ul></li><br></ul><br><ol><br><li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时没有初始化。</li><br><li>反射调用时没有初始化。</li><br><li>发现其父类没有初始化则先触发其父类的初始化。</li><br><li>包含psvm（mian（）方法）的那个类。</li><br><li>动态语言支持时，REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄。</li><br></ol><br><ul><br><li><p>被动引用</p><br><ul><br><li>除上面五种情况之外，所有引用类的方式都不会触发初始化，称为被动引用。</li><br></ul></li><br></ul><br><ol><br><li>通过子类引用父类的静态字段，不会导致子类的初始化。</li><br><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承Object的子类，其中包含数组的属性和方法，用户只能使用public的length和clone()。</li><br><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li><br></ol><br><h3 id="类加载过程">类加载过程</h3><br><ul><br><li><ol><br><li>加载</li><br></ol><br><ul><br><li><ol><br><li>通过类的全限定名来获取定义此类的二进制字节流。</li><br></ol></li><br></ul></li><br></ul><br><ol><br><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><br><li>在内存中生成一个代表这个类的java.lang.Class对象（HotSpot将其存放在方法区中），作为方法区这个类的各种数据的访问入口。</li><br></ol><br><ul><br><li><ol><br><li>验证</li><br></ol><br><ul><br><li>为了确保Class文件的字节类中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。可以通过-Xverify:none关闭大部分类验证。</li><br></ul></li><br></ul><br><ol><br><li>文件格式验证。确保输入字节流能正确的解析并存储于方法区，后面的3个验证全部基于方法区的存储结构进行，不会再操作字节流。</li><br><li>元数据验证。对字节码描述信息进行语义分析，确保其符合Java语法规范。（Java语法验证）</li><br><li>字节码验证。最复杂，通过数据流和控制流分析，确定程序语义时合法的、符合逻辑的。可以通过参数关闭。（验证指令跳转范围，类型转换有效等）</li><br><li>符号引用验证。将符号引用转化为直接引用，发生在第三个阶段——解析阶段中发生。</li><br></ol><br><ul><br><li><ol><br><li>准备</li><br></ol><br><ul><br><li>类变量是被static修饰的变量，准备阶段为类变量分配内存并设置零值（final直接设置初始值），使用的是方法区的内存。</li><br></ul></li><br><li><ol><br><li>解析</li><br></ol><br><ul><br><li>将常量池内的符号引用替换为直接引用的过程。<br><br>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的动态绑定。<br><br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、和调用点限定符。</li><br></ul></li><br><li><ol><br><li>初始化</li><br></ol><br><ul><br><li><p>初始化阶段才真正执行类中定义的Java程序代码，是执行类构造器<clinit>()方法的过程。<br><br>在准备阶段，类变量已经给过零值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。</clinit></p><br><ul><br><li><p><clinit>()</clinit></p><br><ul><br><li>类构造器方法。是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的的语句合并产生的。</li><br></ul></li><br></ul></li><br></ul></li><br></ul><br><ol><br><li>不需要显式调用父类构造器，JVM会保证在子类clinit执行之前，父类的clinit已经执行完成。</li><br><li>接口中不能使用静态语句块但仍可以有类变量的赋值操作。当没有使用父接口中定义的变量时子接口的c</li></ol></li></ul></li></ul></li></ul><p><li>接口中不能使用静态语句块但仍可以有类变量的赋值操作。当没有使用父接口中定义的变量时子接口的clinit不需要先执行父接口的clinit方法。接口的实现类也不会执行接口的clinit方法。</li></p><p><li><p>虚拟机会保证clinit在多线程环境中被正确的加锁、同步。其他线性唤醒之后不会再进入clinit方法，同一个类加载器下，一个类型只会初始化一次。</p></li></p><ul><li><p>&lt;init&gt;()</p><ul><li>对象构造器方法。Java对象被创建时才会进行实例化操作，对非静态变量解析初始化。</li><br><li><p>会显式的调用父类的init方法，对象实例化过程中对实例域的初始化操作全部在init方法中进行。</p></li><br><br><h3 id="类加载-器">类（加载） 器</h3><ul><br><li><p>类与类加载器</p><br><ul><br><li>类加载器实现类的加载动作。<br><br>类加载器和这个类本身一同确立这个类的唯一性，每个类加载器都有独立的类命名空间。在同一个类加载器加载的情况下才会有两个类相等。<br><br>相等包括类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()、instanceof关键字。</li><br></ul></li><br><li><p>类加载器分类</p><br><ul><br><li><p>启动类加载器</p><br><ul><br><li>由C++语言实现，是虚拟机的一部分。负责将JAVA_HOME/lib目录中，或者被-Xbootclasspath参数指定的路径，但是文件名要能被虚拟机识别，名字不符合无法被启动类加载器加载。启动类加载器无法被Java程序直接引用。</li><br></ul></li><br><li><p>扩展类加载器</p><br><ul><br><li>由Java语言实现，负责加载JAVA_HOME/lib/ext目录，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li><br></ul></li><br><li><p>应用程序类加载器</p><br><ul><br><li>由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称他为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，一般情况下这个就是程序中默认的类加载器。</li><br></ul></li><br><li><p>自定义类加载器</p><br><ul><br><li>由用户自己实现。</li><br></ul></li><br></ul></li><br></ul><br><ol><br><li>如果不想打破双亲委派模型，那么只需要重写findClass方法即可。</li><br><li>否则就重写整个loadClass方法。</li><br></ol><br><ul><br><li><p>双亲委派模型</p><br><ul><br><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。父子不会以继承的关系类实现，而是都是使用组合关系来服用父加载器的代码。<br><br>在java.lang.ClassLoader的loadClass()方法中实现。</li><br><li><p>工作过程</p><br><ul><br><li>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成（它的搜索范围中没有找到所需要的类）时才尝试自己加载</li><br></ul></li><br><li><p>好处</p><br><ul><br><li>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，从而使得基础类库得到同意。</li><br></ul></li><br></ul></li><br></ul><br><h2 id="四内存分配与回收策略">四、内存分配与回收策略</h2><br><h3 id="minor-gc-和-full-gc">Minor GC 和 Full GC</h3><br><ul><br><li><p>Minor GC</p><br><ul><br><li>发生在新生代的垃圾收集动作，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行速度快。</li><br><li><p>时机</p><br><ul><br><li>Eden不足</li><br></ul></li><br></ul></li><br><li><p>Full GC</p><br><ul><br><li>发生在老年区的GC，出现Full GC时往往伴随着Minor GC，比Minor GC慢10倍以上。</li><br><li><p>时机</p><br><ul><br><li><ol><br><li>调用System.gc()</li><br></ol><br><ul><br><li>只是建议虚拟机执行Full GC，但是虚拟机不一定真正去执行。<br><br>不建议使用这种方式，而是让虚拟机管理内存。</li><br></ul></li><br><li><ol><br><li>老年代空间不足</li><br></ol><br><ul><br><li>常见场景就是大对象和长期存活对象进入老年代。<br><br>尽量避免创建过大的对象以及数组，调大新生代大小，让对象尽量咋新生代中被回收，不进入老年代。</li><br></ul></li><br><li><ol><br><li>JDK1.7 之前方法区空间不足</li><br></ol><br><ul><br><li>当系统中要加载的类、反射的类和常量较多时，永久代可能会被占满，在未配置CMS GC的情况下也会执行Full GC，如果空间仍然不够则会抛出OOM异常。<br><br>可采用增大方法区空间或转为使用CMS GC。</li><br></ul></li><br><li><ol><br><li>空间分配担保失败</li><br></ol><br><ul><br><li>发生Minor GC时分配担保的两个判断失败</li><br></ul></li><br><li><ol><br><li>Concurrent Mode Failure</li><br></ol><br><ul><br><li>CMS GC 并发清理阶段用户线程还在执行，不断有新的浮动垃圾产生，当预留空间不足时报Concurrent Mode Failure错误并触发Full GC。</li><br></ul></li><br></ul></li><br></ul></li><br></ul><br><h3 id="内存分配策略">内存分配策略</h3><br><ul><br><li><ol><br><li>对象优先在Eden分配</li><br></ol><br><ul><br><li>大多数情况下，对象在新生代Eden上分配，当Eden空间不够时，发起Minor GC，当另外一个Survivor空间不足时则将存活对象通过分配担保机制提前转移到老年代。</li><br></ul></li><br><li><ol><br><li>大对象直接进入老年代</li><br></ol><br><ul><br><li>配置参数-XX:PretenureSizeThreshold，大于此值得对象直接在老年代分配，避免在Eden和Survivor之间的大量内存复制。</li><br></ul></li><br><li><ol><br><li>长期存活对象进入老年代</li><br></ol><br><ul><br><li>虚拟机为每个对象定义了一个Age计数器，对象在Eden出生并经过Minor GC存活转移到另一个Survivor空间中时Age++，增加到默认16则转移到老年代。</li><br></ul></li><br><li><ol><br><li>动态对象年龄绑定</li><br></ol><br><ul><br><li>虚拟机并不是永远要求对象的年龄必须到达MaxTenuringThreshold才能晋升老年代，如果在Survivor中相同年龄所有对象大小总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。</li><br></ul></li><br><li><ol><br><li>空间分配担保</li><br></ol><br><ul><br><li>在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代的所有对象，如果条件成立，那么Minor GC可以认为是安全的。<br><br>可以通过HandlePromotionFailure参数设置允许冒险，此时虚拟机将与历代晋升到老年区对象的平均大小比较，仍小于则要进行一次Full GC。<br><br>在JDK1.6.24之后HandlePromotionFailure已无作用，即虚拟机默认为true。</li><br></ul></li><br></ul></ul></li></ul>]]></content>
    
    <summary type="html">
    
      JVM原理速记复习Java虚拟机总结思维导图面试必备
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Everything about ArrayList</title>
    <link href="http://yoursite.com/2020/02/08/Everything-about-ArrayList/"/>
    <id>http://yoursite.com/2020/02/08/Everything-about-ArrayList/</id>
    <published>2020-02-07T16:53:26.000Z</published>
    <updated>2020-02-17T10:21:40.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-ArrayList底层实现原理源码详细分析Jdk8"><a href="#Java-ArrayList底层实现原理源码详细分析Jdk8" class="headerlink" title="Java ArrayList底层实现原理源码详细分析Jdk8"></a>Java ArrayList底层实现原理源码详细分析Jdk8</h1><p><li>ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。</li></p><p><li><strong>ArrayList不是线程安全的</strong>，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。</li></p><p><li>ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。</li><br></p><h4 id="存储结构">存储结构</h4><br><pre class="java"><code>// 当前数据对象存放地方，当前对象不参与序列化<br>// 这个关键字最主要的作用就是当序列化时，被transient修饰的内容将不会被序列化<br>transient Object[] elementData;</code></pre><br><ul><br><li><p>Object类型数组。</p><br><h4 id="数据域">数据域</h4></li><br></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化ID</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">  <span class="comment">// 默认初始容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 一个空数组，方便使用，主要用于带参构造函数初始化和读取序列化对象等。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 和官方文档写的一样，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和EMPTY_ELEMENTDATA 的区别</span></span><br><span class="line"><span class="comment">   * 仅仅是为了区别用户带参为0的构造和默认构造的惰性初始模式对象。</span></span><br><span class="line"><span class="comment">   * 当用户带参为0的构造，第一次add时，数组容量grow到1。</span></span><br><span class="line"><span class="comment">   * 当用户使用默认构造时，第一次add时，容量直接grow到DEFAULT_CAPACITY（10）。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前数据对象存放地方，当前对象不参与序列化</span></span><br><span class="line">  <span class="comment">// 这个关键字最主要的作用就是当序列化时，被transient修饰的内容将不会被序列化</span></span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">  <span class="comment">// 当前数组中元素的个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// 数组最大可分配容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">  <span class="comment">// 集合数组修改次数的标识（由AbstractList继承下来）（fail-fast机制）</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>ArrayList的无参构造函数。<strong>初始化的时候并没有真正的创建10个空间，这是惰性初始模式对象。</strong></li><br><li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和EMPTY_ELEMENTDATA 的区别仅仅是为了区别用户带参为0的构造和默认构造的惰性初始模式对象。</li><br><li>modCount用来记录ArrayList结构发生变化的次数。用于<a href="#q1">Fail-Fast机制</a></li><br></ul><br><br><h4 id="构造函数">构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 只有这个地方会引用DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">     <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 使用 EMPTY_ELEMENTDATA，在其他的多个地方可能会引用EMPTY_ELEMENTDATA</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(&amp;quot;Illegal Capacity: &amp;quot;+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&amp;lt;? extends E&amp;gt; c)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 把传入集合传化成[]数组并浅拷贝给elementData</span></span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="comment">// 转化后的数组长度赋给当前ArrayList的size,并判断是否为0</span></span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//c.toArray可能不会返回 Object[]，可以查看 java 官方编号为 6260652 的 bug</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             <span class="comment">// 若 c.toArray() 返回的数组类型不是 Object[]，则利用 Arrays.copyOf(); 来构造一个大小为 size 的 Object[] 数组</span></span><br><span class="line">             <span class="comment">// 此时elementData是指向传入集合的内存，还需要创建新的内存区域深拷贝给elementData</span></span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 传入数组size为零替换空数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><br><li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和EMPTY_ELEMENTDATA 的区别仅仅是为了区别用户带参为0的构造和默认构造的惰性初始模式对象。</li><br><li>注意<strong>深拷贝和浅拷贝</strong>。</li><br><li><p>带参为0的构造会惰性初始化，不为0的构造则不会惰性初始化。</p><br><h4 id="add源码解析">add()源码解析</h4></li><br></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确保数组已使用长度（size）加1之后足够存下 下一个数据</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">// 数组的下一个index存放传入元素。</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="comment">// 始终返回true。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里就是DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和</span></span><br><span class="line">        <span class="comment">// EMPTY_ELEMENTDATA 最主要的区别。</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">// 默认构造第一次add返回10。</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 带参为0构造第一次add返回 1 （0 + 1）。</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自增修改计数</span></span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">// 当前数组容量小于需要的最小容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &amp;gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 准备扩容数组</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">// 获得当前数组容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">// 新数组容量为1.5倍的旧数组容量</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &amp;lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 若 newCapacity 依旧小于 minCapacity</span></span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">            <span class="comment">// 判断是需要的容量是否超过最大的数组容量。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &amp;gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        <span class="comment">// 在Arrays.copyOf()中会将原数组整个赋值到扩容的数组中。</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>扩容操作需要调用Arrays.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建ArrayList对象时就指定大概的容量大小，减少扩容操作的次数。</li><br></ul><br><h4 id="addint-index-e-element源码分析">add(int index, E element)源码分析</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个本地方法，由C语言实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  // 源数组</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span>  srcPos, // 源数组要复制的起始位置</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, // 目标数组（将原数组复制到目标数组）</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> destPos, // 目标数组起始位置（从目标数组的哪个下标开始复制操作）</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length   // 复制源数组的长度</span></span></span><br><span class="line"><span class="function"><span class="params">                                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断索引是否越界</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">// 确保数组已使用长度（size）加1之后足够存下 下一个数据</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">// 运行到这里代表数组容量满足。</span></span><br><span class="line">        <span class="comment">// 数组从传入形参index处开始复制，复制size-index个元素（即包括index在内后面的元素全部复制），</span></span><br><span class="line">        <span class="comment">// 从数组的index + 1处开始粘贴。</span></span><br><span class="line">        <span class="comment">// 这时，index 和 index + 1处元素数值相同。</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        <span class="comment">// 把index处的元素替换成新的元素。</span></span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">// 数组内元素长度加一。</span></span><br><span class="line">        size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>需要调用System.arraycopy()将包括index在内后面的元素都复制到index + 1位置上，该操作的时间复杂度为O(N)，可以看出ArrayList数组头增加元素的代价是非常高的。</li><br></ul><br><h4 id="removeint-index源码分析">remove(int index)源码分析</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查index</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &amp;gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 和 add(int index, E element)原理想通。</span></span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        <span class="comment">// 引用计数为0，会自动进行垃圾回收。</span></span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="comment">// 返回旧元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>需要调用System.arraycopy()将包括index + 1在内后面的元素都复制到index位置上，该操作的时间复杂度为O(N)，可以看出ArrayList数组头增加元素的代价是非常高的。</li><br></ul><br><h4 id="q1">Fail-Fast机制</h4><br><p>fail-fast 机制，即快速失败机制，是java集合(Collection)中的一种错误检测机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出ConcurrentModificationException异常。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。</p><br><ul><br><li>结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组大小，仅仅只是设置元素的值不算结构发生变化。</li><br><li>在进行序列化或者迭代操作时，需要比较操作前后modCount是否改变，如果改变了需要跑出ConcurrentModificationException</li><br></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&amp;<span class="title">lt</span></span>;E&amp;gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;</span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 期待的修改值等于当前修改次数（modCount）</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 检查 expectedModCount是否等于modCount，不相同则抛出ConcurrentModificationException</span></span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">/** 省略此处代码 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lastRet &amp;lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">/** 省略此处代码 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount == <span class="keyword">this</span>.expectedModCount)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><p>一个单线程环境下的fail-fast的例子</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&amp;lt;String&amp;gt; list = <span class="keyword">new</span> ArrayList&amp;lt;&amp;gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &amp;lt; <span class="number">10</span> ; i++ ) &#123;</span><br><span class="line">            list.add(i + &amp;quot;&amp;quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       Iterator&amp;lt;String&amp;gt; iterator = list.iterator();</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                 list.remove(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            i ++;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><br><h4 id="序列化">序列化</h4><br><p>ArrayList 实现了 java.io.Serializable 接口，但是自己定义了序列化和反序列化。因为ArrayList基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没有<strong>必要全部进行序列化</strong>。因此 elementData 数组使用 transient 修饰，可以防止被自动序列化。</p><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        <span class="comment">// 将当前类的非静态(non-static)和非瞬态(non-transient)字段写入流</span></span><br><span class="line">        <span class="comment">// 在这里也会将size字段写入。</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        <span class="comment">// 序列化数组包含元素数量，为了向后兼容</span></span><br><span class="line">        <span class="comment">// 两次将size写入流</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="comment">// 按照顺序写入，只写入到数组包含元素的结尾，并不会把数组的所有容量区域全部写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否触发Fast-Fail</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置数组引用空数组。</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        <span class="comment">// 将流中的的非静态(non-static)和非瞬态(non-transient)字段读取到当前类</span></span><br><span class="line">        <span class="comment">// 包含 size</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            <span class="comment">// 根据size计算容量。</span></span><br><span class="line">            <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">            <span class="comment">// SharedSecrets 一个“共享机密”存储库，它是一种机制，</span></span><br><span class="line">            <span class="comment">// 用于调用另一个包中的实现专用方法，而不使用反射。TODO</span></span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">            <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><p>ArrayList中为什么size要序列化两次？</p><br><blockquote><br><p>在代码中s.defaultWriteObject();中size应该也被序列化了，为什么下边还要再单独序列化一次呢？<br><br>这样写是出于兼容性考虑。<br><br>旧版本的JDK中，ArrayList的实现有所不同，会对length字段进行序列化。<br><br>而新版的JDK中，对优化了ArrayList的实现，不再序列化length字段。<br><br>这个时候，如果去掉s.writeInt(size)，那么新版本JDK序列化的对象，在旧版本中就无法正确读取，<br><br>因为缺少了length字段。<br><br>因此这种写法看起来多此一举，实际上却保证了兼容性。</p><br></blockquote><br><br>### 小结<br><ul><br><li>ArrayList基于数组方式实现，无容量的限制（会扩容）</li><br><li>添加元素时可能要扩容（所以最好预判一下），删除元素时不会减少容量（若希望减少容量可以使用trimToSize()），删除元素时，将删除掉的位置元素置为null，下次gc就会回收这些元素所占的内存空间。</li><br><li>线程不安全</li><br><li>add(int index, E element)：添加元素到数组中指定位置的时候，需要将该位置及其后边所有的元素都整块向后复制一位</li><br><li>get(int index)：获取指定位置上的元素时，可以通过索引直接获取（O(1)）</li><br><li>remove(Object o)需要遍历数组</li><br><li>remove(int index)不需要遍历数组，只需判断index是否符合条件即可，效率比remove(Object o)高</li><br><li>contains(E)需要遍历数组</li><br></ul><p><a href="https://www.cnblogs.com/renjiaqi/p/10403725.html" target="_blank" rel="noopener">面试必会之ArrayList源码分析&amp;手写ArrayList</a></p>]]></content>
    
    <summary type="html">
    
      Java ArrayList底层实现原理源码详细分析Jdk8
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>The data structure and algorithm behind the MySQL index</title>
    <link href="http://yoursite.com/2020/02/05/The-data-structure-and-algorithm-behind-the-MySQL-index/"/>
    <id>http://yoursite.com/2020/02/05/The-data-structure-and-algorithm-behind-the-MySQL-index/</id>
    <published>2020-02-05T15:14:29.000Z</published>
    <updated>2020-02-27T09:15:26.658Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>文章主要内容分为三个部分。</p><p></p><p></p><p>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。</p><p></p><p></p><p>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</p><p></p><p></p><p>第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。<br><a id="more"></a><br></p><p></p><p></p><h1><a name="nav-2"></a>数据结构及算法基础</h1><p></p><p></p><h2><a name="nav-2-1"></a>索引的本质</h2><p></p><p></p><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p></p><p></p><p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是<a href="http://en.wikipedia.org/wiki/Linear_search" target="_blank">顺序查找</a>（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm" target="_blank">二分查找</a>（binary search）、<a href="http://en.wikipedia.org/wiki/Binary_search_tree" target="_blank">二叉树查找</a>（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于<a href="http://en.wikipedia.org/wiki/Binary_search_tree" target="_blank">二叉查找树</a>上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p></p><p></p><p>看一个例子：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/1.png"></p><p></p><p></p><p align="center">图1</p><p></p><p></p><p>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在(O(log_2n))的复杂度内获取到相应数据。</p><p></p><p></p><p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种<a href="http://en.wikipedia.org/wiki/Red-black_tree" target="_blank">红黑树</a>（red-black tree）实现的，原因会在下文介绍。</p><p></p><p></p><h2><a name="nav-2-2"></a>B-Tree和B+Tree</h2><p></p><p></p><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p><p></p><p></p><h3>B-Tree</h3><p></p><p></p><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p><p></p><p></p><p>d为大于1的一个正整数，称为B-Tree的度。</p><p></p><p></p><p>h为一个正整数，称为B-Tree的高度。</p><p></p><p></p><p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p><p></p><p></p><p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p><p></p><p></p><p>所有叶节点具有相同的深度，等于树高h。</p><p></p><p></p><p>key和指针互相间隔，节点两端是指针。</p><p></p><p></p><p>一个节点中的key从左到右非递减排列。</p><p></p><p></p><p>所有节点组成树结构。</p><p></p><p></p><p>每个指针要么为null，要么指向另外一个节点。</p><p></p><p></p><p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于(v(key_1))，其中(v(key_1))为node的第一个key的值。</p><p></p><p></p><p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于(v(key_m))，其中(v(key_m))为node的最后一个key的值。</p><p></p><p></p><p>如果某个指针在节点node的左右相邻key分别是(key_i)和(key_{i+1})且不为null，则其指向节点的所有key小于(v(key_{i+1}))且大于(v(key_i))。</p><p></p><p></p><p>图2是一个d=2的B-Tree示意图。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/2.png"></p><p></p><p></p><p align="center">图2</p><p></p><p></p><p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre <span class="class"><span class="keyword">class</span></span>=<span class="string">"prettyprint linenums"</span>&gt;BTree_Search(node, key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    foreach(node.key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.key[i] == key) <span class="keyword">return</span> node.data[i];</span><br><span class="line">            <span class="keyword">if</span>(node.key[i] &amp;gt; key) <span class="keyword">return</span> BTree_Search(point[i]-&amp;gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BTree_Search(point[i+<span class="number">1</span>]-&amp;gt;node);</span><br><span class="line">&#125;</span><br><span class="line">data = BTree_Search(root, my_key);&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p></p><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为(log_d((N+1)/2))，检索一个key，其查找节点个数的渐进复杂度为(O(log_dN))。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><p></p><p></p><p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p><p></p><p></p><h3>B+Tree</h3><p></p><p></p><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p><p></p><p></p><p>与B-Tree相比，B+Tree有以下不同点：</p><p></p><p></p><p>每个节点的指针上限为2d而不是2d+1。</p><p></p><p></p><p>内节点不存储data，只存储key；叶子节点不存储指针。</p><p></p><p></p><p>图3是一个简单的B+Tree示意。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/3.png"></p><p></p><p></p><p align="center">图3</p><p></p><p></p><p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p><p></p><p></p><p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p><p></p><p></p><h3>带有顺序访问指针的B+Tree</h3><p></p><p></p><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/4.png"></p><p></p><p></p><p align="center">图4</p><p></p><p></p><p>如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><p></p><p></p><p>这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p><p></p><p></p><h2><a name="nav-2-3"></a>为什么使用B-Tree（B+Tree）</h2><p></p><p></p><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p><p></p><p></p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><p></p><p></p><h3>主存存取原理</h3><p></p><p></p><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/5.png"></p><p></p><p></p><p align="center">图5</p><p></p><p></p><p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p><p></p><p></p><p>主存的存取过程如下：</p><p></p><p></p><p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p><p></p><p></p><p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p><p></p><p></p><p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><p></p><p></p><h3>磁盘存取原理</h3><p></p><p></p><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p></p><p></p><p>图6是磁盘的整体结构示意图。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/6.png"></p><p></p><p></p><p align="center">图6</p><p></p><p></p><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p></p><p></p><p>图7是磁盘结构的示意图。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/7.png"></p><p></p><p></p><p align="center">图7</p><p></p><p></p><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p></p><p></p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><p></p><p></p><h3>局部性原理与磁盘预读</h3><p></p><p></p><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><p></p><p></p><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p><p></p><p></p><p>程序运行期间所需要的数据通常比较集中。</p><p></p><p></p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p></p><p></p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p></p><p></p><h3>B-/+Tree索引的性能分析</h3><p></p><p></p><p>到这里终于可以分析B-/+Tree索引的性能了。</p><p></p><p></p><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p></p><p></p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p></p><p></p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为(O(h)=O(log_dN))。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p></p><p></p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p></p><p></p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p><p></p><p></p><p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p><p></p><p></p><p>(d_{max}=floor(pagesize / (keysize + datasize + pointsize)))</p><p></p><p></p><p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p><p></p><p></p><p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p><p></p><p></p><h1><a name="nav-3"></a>MySQL索引实现</h1><p></p><p></p><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><p></p><p></p><h2><a name="nav-3-1"></a>MyISAM索引实现</h2><p></p><p></p><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/8.png"></p><p></p><p></p><p align="center">图8</p><p></p><p></p><p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/9.png"></p><p></p><p></p><p align="center">图9</p><p></p><p></p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><p></p><p></p><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><p></p><p></p><h2><a name="nav-3-2"></a>InnoDB索引实现</h2><p></p><p></p><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p></p><p></p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/10.png"></p><p></p><p></p><p align="center">图10</p><p></p><p></p><p>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p></p><p></p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/11.png"></p><p></p><p></p><p align="center">图11</p><p></p><p></p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p></p><p></p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><p></p><p></p><p>下一章将具体讨论这些与索引有关的优化策略。</p><p></p><p></p><h1><a name="nav-4"></a>索引使用策略及优化</h1><p></p><p></p><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。</p><p></p><p></p><h2><a name="nav-4-1"></a>示例数据库</h2><p></p><p></p><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/12.png"></p><p></p><p></p><p align="center">图12</p><p></p><p></p><p>MySQL官方文档中关于此数据库的页面为<a title="http://dev.mysql.com/doc/employee/en/employee.html" href="http://dev.mysql.com/doc/employee/en/employee.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/employee/en/employee.html</a>。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。</p><p></p><p></p><h2><a name="nav-4-2"></a>最左前缀原理与相关优化</h2><p></p><p></p><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p><p></p><p></p><p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</p><p></p><p></p><p>以employees.titles表为例，下面先查看其上都有哪些索引：</p><p></p><p><pre class="prettyprint linenums">SHOW INDEX FROM employees.titles;<br>+——–+————+———-+————–+————-+———–+————-+——+————+<br>| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |<br>+——–+————+———-+————–+————-+———–+————-+——+————+<br>| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      |<br>| titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      |<br>| titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      |<br>| titles |          1 | emp_no   |            1 | emp_no      | A         |      443308 |      | BTREE      |<br>+——–+————+———-+————–+————-+———–+————-+——+————+</pre></p><p></p><p>从结果中可以到titles表的主索引为&lt;emp_no, title, from_date&gt;，还有一个辅助索引&lt;emp_no&gt;。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：</p><p></p><p><pre class="prettyprint linenums">ALTER TABLE employees.titles DROP INDEX emp_no;</pre></p><p></p><p>这样就可以专心分析索引PRIMARY的行为了。</p><p></p><p></p><h3>情况一：全列匹配。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND title=’Senior Engineer’ AND from_date=’1986-06-26’;<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+</pre></p><p></p><p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE from_date=’1986-06-26’ AND emp_no=’10001’ AND title=’Senior Engineer’;<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+</pre></p><p></p><p>效果是一样的。</p><p></p><p></p><h3>情况二：最左前缀匹配。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’;<br>+—-+————-+——–+——+—————+———+———+——-+——+——-+<br>| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |<br>+—-+————-+——–+——+—————+———+———+——-+——+——-+<br>|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |<br>+—-+————-+——–+——+—————+———+———+——-+——+——-+</pre></p><p></p><p>当查询条件精确匹配索引的左边连续一个或几个列时，如&lt;emp_no&gt;或&lt;emp_no, title&gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</p><p></p><p></p><h3>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND from_date=’1986-06-26’;<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+</pre></p><p></p><p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p><p></p><p></p><p>首先我们看下title一共有几种不同的值：</p><p></p><p><pre class="prettyprint linenums">SELECT DISTINCT(title) FROM employees.titles;<br>+——————–+<br>| title              |<br>+——————–+<br>| Senior Engineer    |<br>| Staff              |<br>| Engineer           |<br>| Senior Staff       |<br>| Assistant Engineer |<br>| Technique Leader   |<br>| Manager            |<br>+——————–+</pre></p><p></p><p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no=’10001’<br>AND title IN (‘Senior Engineer’, ‘Staff’, ‘Engineer’, ‘Senior Staff’, ‘Assistant Engineer’, ‘Technique Leader’, ‘Manager’)<br>AND from_date=’1986-06-26’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |    7 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：</p><p></p><p><pre class="prettyprint linenums">SHOW PROFILES;<br>+———-+————+——————————————————————————-+<br>| Query_ID | Duration   | Query                                                                         |<br>+———-+————+——————————————————————————-+<br>|       10 | 0.00058000 | SELECT <em> FROM employees.titles WHERE emp_no=’10001’ AND from_date=’1986-06-26’|<br>|       11 | 0.00052500 | SELECT </em> FROM employees.titles WHERE emp_no=’10001’ AND title IN …          |<br>+———-+————+——————————————————————————-+</pre></p><p></p><p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p><p></p><p></p><h3>情况四：查询条件没有指定索引第一列。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE from_date=’1986-06-26’;<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+</pre></p><p></p><p>由于不是最左前缀，索引这样的查询显然用不到索引。</p><p></p><p></p><h3>情况五：匹配某列的前缀字符串。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND title LIKE ‘Senior%’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 56      | NULL |    1 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>此时可以用到索引，<strike>但是如果通配符不是只出现在末尾，则无法使用索引。</strike>（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）</p><p></p><p></p><h3>情况六：范围查询。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; ‘10010’ and title=’Senior Engineer’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no &lt; ‘10010’<br>AND title=’Senior Engineer’<br>AND from_date BETWEEN ‘1986-01-01’ AND ‘1986-12-31’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no BETWEEN ‘10001’ AND ‘10010’<br>AND title=’Senior Engineer’<br>AND from_date BETWEEN ‘1986-01-01’ AND ‘1986-12-31’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p><p></p><p></p><h3>情况七：查询条件中含有函数或表达式。</h3><p></p><p></p><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND left(title, 6)=’Senior’;<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+</pre></p><p></p><p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1=’10000’;<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+</pre></p><p></p><p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p><p></p><p></p><h2><a name="nav-4-3"></a>索引选择性与前缀索引</h2><p></p><p></p><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p><p></p><p></p><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p><p></p><p></p><p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p><p></p><p></p><p>Index Selectivity = Cardinality / #T</p><p></p><p></p><p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.0000 |<br>+————-+</pre></p><p></p><p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p><p></p><p></p><p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p><p></p><p></p><p>从图12可以看到employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.employees WHERE first_name=’Eric’ AND last_name=’Anido’;<br>+—-+————-+———–+——+—————+——+———+——+——–+————-+<br>| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |<br>+—-+————-+———–+——+—————+——+———+——+——–+————-+<br>|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |<br>+—-+————-+———–+——+—————+——+———+——+——–+————-+</pre></p><p></p><p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建&lt;first_name&gt;或&lt;first_name, last_name&gt;，看下两个索引的选择性：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(first_name))/count(<em>) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.0042 |<br>+————-+<br>SELECT count(DISTINCT(concat(first_name, last_name)))/count(</em>) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.9313 |<br>+————-+</pre></p><p></p><p>&lt;first_name&gt;显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.7879 |<br>+————-+</pre></p><p></p><p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.9007 |<br>+————-+</pre></p><p></p><p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上：</p><p></p><p><pre class="prettyprint linenums">ALTER TABLE employees.employees<br>ADD INDEX <code>first_name_last_name4</code> (first_name, last_name(4));</pre></p><p></p><p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p><p></p><p><pre class="prettyprint linenums">SHOW PROFILES;<br>+———-+————+———————————————————————————+<br>| Query_ID | Duration   | Query                                                                           |<br>+———-+————+———————————————————————————+<br>|       87 | 0.11941700 | SELECT <em> FROM employees.employees WHERE first_name=’Eric’ AND last_name=’Anido’ |<br>|       90 | 0.00092400 | SELECT </em> FROM employees.employees WHERE first_name=’Eric’ AND last_name=’Anido’ |<br>+———-+————+———————————————————————————+</pre></p><p></p><p>性能的提升是显著的，查询速度提高了120多倍。</p><p></p><p></p><p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p><p></p><p></p><h2><a name="nav-4-4"></a>InnoDB的主键选择与插入优化</h2><p></p><p></p><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p><p></p><p></p><p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p><p></p><p></p><p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p></p><p></p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/13.png"></p><p></p><p></p><p align="center">图13</p><p></p><p></p><p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p></p><p></p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/14.png"></p><p></p><p></p><p align="center">图14</p><p></p><p></p><p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><p></p><p></p><p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p><p></p><p></p><h1><a name="nav-5"></a>后记</h1><p></p><p></p><p>这篇文章断断续续写了半个月，主要内容就是上面这些了。不可否认，这篇文章在一定程度上有纸上谈兵之嫌，因为我本人对MySQL的使用属于菜鸟级别，更没有太多数据库调优的经验，在这里大谈数据库索引调优有点大言不惭。就当是我个人的一篇学习笔记了。</p><p></p><p></p><p>其实数据库索引调优是一项技术活，不能仅仅靠理论，因为实际情况千变万化，而且MySQL本身存在很复杂的机制，如查询优化策略和各种引擎的实现差异等都会使情况变得更加复杂。但同时这些理论是索引调优的基础，只有在明白理论的基础上，才能对调优策略进行合理推断并了解其背后的机制，然后结合实践中不断的实验和摸索，从而真正达到高效使用MySQL索引的目的。</p><p></p><p></p><p>另外，MySQL索引及其优化涵盖范围非常广，本文只是涉及到其中一部分。如与排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）的话题本文并未涉及，同时除B-Tree索引外MySQL还根据不同引擎支持的哈希索引、全文索引等等本文也并未涉及。如果有机会，希望再对本文未涉及的部分进行补充吧。</p><br><p></p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理 作者 张洋 | 发布于 2011-10-18</a></p>]]></content>
    
    <summary type="html">
    
      本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论
    
    </summary>
    
    
      <category term="MySQL, Index, Database" scheme="http://yoursite.com/tags/MySQL-Index-Database/"/>
    
  </entry>
  
  <entry>
    <title>The Difference between Process and Thread</title>
    <link href="http://yoursite.com/2020/02/05/The-Difference-between-Process-and-Thread/"/>
    <id>http://yoursite.com/2020/02/05/The-Difference-between-Process-and-Thread/</id>
    <published>2020-02-05T08:41:49.000Z</published>
    <updated>2020-02-17T10:19:15.781Z</updated>
    
    <content type="html"><![CDATA[<p>对于操作系统而言，进程是整个现代操作系统的根本，操作系統是以进程为单位执行任务。随着技术发展，在执行一些细小任务，且本身无需分配单独资源时，进程的实现机制依然会繁琐的将资源分割，这样造成浪费，而且还消耗时间，所以就有了专门的多任务技术被创造出来——线程。 线程的特点就是在不需要独立资源的情况下就可以运行。如此一来会极大节省资源开销，以及处理时间。</p><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><p>我们有如下对比图片：</p><table><thead><tr><th>Tables</th><th style="text-align:center">Process   进程</th><th style="text-align:right">Thread线程</th></tr></thead><tbody><tr><td>引入目的</td><td style="text-align:center">可以并发执行，提高资源的利用率和系统吞吐量</td><td style="text-align:right">调高并发执行的速度，进一步提高资源的利用率和系统吞吐量</td></tr><tr><td>并发性</td><td style="text-align:center">较低</td><td style="text-align:right">较高</td></tr><tr><td>基本属性（调度）</td><td style="text-align:center">资源拥有的基本单位是进程，独立调度/分配的基本单位是进程</td><td style="text-align:right">资源拥有的基本单位是进程，独立调度/分配的基本单位是线程</td></tr><tr><td>基本状态</td><td style="text-align:center">就绪；执行；等待</td><td style="text-align:right">就绪；执行；等待</td></tr><tr><td>系统开销</td><td style="text-align:center">创建/撤销/切换时开销较大</td><td style="text-align:right">创建/撤销/切换时开销较小</td></tr><tr><td>系统操作</td><td style="text-align:center">创建；撤销；切换</td><td style="text-align:right">创建；撤销；切换</td></tr><tr><td>存在状态</td><td style="text-align:center">进程控制块PCB</td><td style="text-align:right">进程控制块PCB，进程控制块TCB</td></tr></tbody></table><h4 id="但是对于-Linux-来说，它只支持轻量级进程，不支持线程，对于-Linux-而言："><a href="#但是对于-Linux-来说，它只支持轻量级进程，不支持线程，对于-Linux-而言：" class="headerlink" title="但是对于 Linux 来说，它只支持轻量级进程，不支持线程，对于 Linux 而言："></a>但是对于 Linux 来说，它只支持轻量级进程，不支持线程，对于 Linux 而言：</h4><ul><li>系统启动后的 第一个进程是 init，它的 PID 是 1。init 是唯一一个由系统内核直接运行的进程。</li><li>除了 init 之外，每个进程都有 父进程（PPID 标识）</li><li>每个进程还有四个 与用户和组相关的识别号<br>1.实际用户识别号 （real user ID，RUID）<br>2.实际组识别号 （real group ID，RGID）<br>3.有效用户识别号 （effect user ID，EUID）<br>4.有效组识别号 （effect group ID，EGID</li></ul><p>######在 Linux 内核 2.4 版以前，线程的实现和管理方式就是完全按照进程方式实现的。在 2.6 版内核以后才有了单独的线程实现,为了弥补不支持线程的缺陷，Linux 引入线程组的概念，即该组中第一个轻量级进程的 PID，它被存入进程描述符的 tgid 字段中。<code>getpid()</code>系统调用返回当前进程的 tgid 值而不是 pid 值，因此，一个多线程应用的所有线程共享相同的 PID。</p><ul><li><code>fork()</code>系统调用是Unix下以自身进程创建子进程的系统调用，一次调用，两次返回，如果返回是0，则是子进程，如果返回值&gt;0，则是父进程（返回值是子进程的pid）,如果fork出错，返回一个负值.</li><li>在<code>fork()</code>的调用处，整个父进程空间会原模原样地复制到子进程中，包括指令，变量值，程序调用栈，环境变量，缓冲区，等等。</li><li><code>fork()</code>函数会把它所在语句以后的语句复制到一个子进程里，单独执行。</li><li><p>如果<code>printf</code>函数最后没有<code>&quot;\n&quot;</code>，则输出缓冲区不会被立即清空，而fork函数会把输出缓冲区里的内容也都复制到子进程里</p></li><li><p>进程的执行过程是线状的，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。</p></li><li>线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。</li><li>计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</li><li>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</li><li>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。</li></ul><p><strong>文章来源:</strong><br><a href="https://zhuanlan.zhihu.com/p/60558136" target="_blank" rel="noopener">进程和线程有哪些区别与联系？力扣（LeetCode）</a></p>]]></content>
    
    <summary type="html">
    
      进程和线程有哪些区别与联系
    
    </summary>
    
    
      <category term="Operation System" scheme="http://yoursite.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>Everything About HashMap</title>
    <link href="http://yoursite.com/2020/02/04/Everything-About-HashMap/"/>
    <id>http://yoursite.com/2020/02/04/Everything-About-HashMap/</id>
    <published>2020-02-04T10:51:33.000Z</published>
    <updated>2020-02-17T10:22:18.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么用HashMap？"><a href="#1-为什么用HashMap？" class="headerlink" title="1.为什么用HashMap？"></a>1.为什么用HashMap？</h2><ul><li>HashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射。</li><li>HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改。数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到. 链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</li><li>用LinkedList代替数组结构可以么?</li></ul><p>当然是可以的，稍微说明一下，此题的意思是，源码中是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry[] table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line"></span><br><span class="line">Entry就是一个链表节点。 那下面这样表示，是否可行?</span><br><span class="line"></span><br><span class="line">List&lt;Entry&gt; table = <span class="keyword">new</span> LinkedList&lt;Entry&gt;();</span><br></pre></td></tr></table></figure><p>答案很明显，是可以的。</p><p>既然是可以的,为什么HashMap不用LinkedList,而选用数组?<br>因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</p><ul><li>那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList?<br>因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。 而ArrayList的扩容机制是1.5倍扩容，那ArrayList为什么是1.5倍扩容这就不在本文说明了。</li><li>HashMap是非synchronized，所以HashMap很快。</li><li>HashMap可以接受null键和值，而Hashtable则不能（原因就是<code>equlas()</code>方法需要对象，因为HashMap是后出的API经过处理才可以）</li><li>当链表转为红黑树后，什么时候退化为链表?<br>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</li></ul><h2 id="2-HashMap的工作原理是什么？"><a href="#2-HashMap的工作原理是什么？" class="headerlink" title="2.HashMap的工作原理是什么？"></a>2.HashMap的工作原理是什么？</h2><p>HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node。　　</p><ul><li><p>以下是HashMap初始化 ，简单模拟数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Node[] table=<span class="keyword">new</span> Node[<span class="number">16</span>]  散列桶初始化，table</span><br><span class="line"></span><br><span class="line">　　 <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　hash;<span class="comment">//hash值</span></span><br><span class="line"></span><br><span class="line">     key;<span class="comment">//键</span></span><br><span class="line"></span><br><span class="line">　　　　value;<span class="comment">//值</span></span><br><span class="line"></span><br><span class="line">　　　　node next;<span class="comment">//用于指向链表的下一层（产生冲突，用拉链法）</span></span><br><span class="line"></span><br><span class="line">　　 &#125;</span><br></pre></td></tr></table></figure></li><li><p>以下是具体的put过程（JDK1.8版）</p><pre><code>1.对Key求Hash值，然后再计算下标2.如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）3.如果碰撞了，以链表的方式链接到后面4.如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表5.如果节点已经存在就替换旧值6.如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）</code></pre></li></ul><p><strong>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</strong></p><ul><li>以下是具体get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)<br>当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。</li></ul><p>　　</p><h2 id="3-有什么方法可以减少碰撞？"><a href="#3-有什么方法可以减少碰撞？" class="headerlink" title="3.有什么方法可以减少碰撞？"></a>3.有什么方法可以减少碰撞？</h2><ul><li>扰动函数可以减少碰撞，原理是如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这就意味着存链表结构减小，这样取值的话就不会频繁调用equal方法，这样就能提高HashMap的性能。（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。）</li><li>使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。为什么String, Interger这样的wrapper类适合作为键？因为String是final的，而且已经重写了equals()和hashCode()方法了。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。</li></ul><h2 id="4-HashMap中hash函数怎么是是实现的"><a href="#4-HashMap中hash函数怎么是是实现的" class="headerlink" title="4.HashMap中hash函数怎么是是实现的?"></a>4.HashMap中hash函数怎么是是实现的?</h2><p>　　我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式，我们来看看JDK1.8的源码是怎么做的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     h=key.hashCode()；返回散列值也就是hashcode</span><br><span class="line">      <span class="comment">// ^ ：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="comment">//其中n是数组的长度，即Map的数组部分初始化长度</span></span><br><span class="line">     <span class="keyword">return</span>  (n-<span class="number">1</span>)&amp;(h ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>高16位异或低16位以后，进行取模运算</strong><br>1.高16bit不变，低16bit和高16bit做了一个异或(得到的HashCode转化为32位的二进制，前16位和后16位低16bit和高16bit做了一个异或)<br>2.(n·1)&amp;hash=-&gt;得到下标</p><ul><li>为什么扩容是2的次幂?</li></ul><p>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法<br>这个算法实际就是取模，hash%length。 但是，大家都知道这种运算不如位移运算快。<br>因此，源码中做了优化hash&amp;(length-1)。 也就是说hash%length==hash&amp;(length-1)</p><h2 id="5-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"><a href="#5-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？" class="headerlink" title="5.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"></a>5.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</h2><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p><h2 id="6-对红黑树的见解？"><a href="#6-对红黑树的见解？" class="headerlink" title="6.对红黑树的见解？"></a>6.对红黑树的见解？</h2><ul><li>节点是红色或黑色。</li><li>根节点是黑色。</li><li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li><strong>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</strong></li></ul><h2 id="7-解决hash-碰撞还有那些办法？"><a href="#7-解决hash-碰撞还有那些办法？" class="headerlink" title="7.解决hash 碰撞还有那些办法？"></a>7.解决hash 碰撞还有那些办法？</h2><p><strong>比较出名的有四种 (1)开放定址法 (2)链地址法 (3)再哈希法 (4)公共溢出区域法</strong></p><ul><li>开放定址法<br>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li><li>链地址法<br>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li><li>再哈希法<br>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li><li>建立公共溢出区<br>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li></ul><p><strong>下面给一个线性探查法的例子</strong>　</p><p><strong>问题：已知一组关键字为(26，36，41，38，44，15，68，12，06，51)，用除余法构造散列函数，用线性探查法解决冲突构造这组关键字的散列表</strong></p><p> <strong>解答：为了减少冲突，通常令装填因子α由除余法因子是13的散列函数计算出的上述关键字序列的散列地址为(0，10，2，12，5，2，3，12，6，12)。</strong></p><ul><li>前5个关键字插入时，其相应的地址均为开放地址，故将它们直接插入T[0]，T[10)，T[2]，T[12]和T[5]中。</li><li>当插入第6个关键字15时，其散列地址2(即h(15)=15％13=2)已被关键字41(15和41互为同义词)占用。故探查h1=(2+1)％13=3，此地址开放，所以将15放入T[3]中。</li><li>当插入第7个关键字68时，其散列地址3已被非同义词15先占用，故将其插入到T[4]中。</li><li>当插入第8个关键字12时，散列地址12已被同义词38占用，故探查hl=(12+1)％13=0，而T[0]亦被26占用，再探查h2=(12+2)％13=1，此地址开放，可将12插入其中。</li><li>类似地，第9个关键字06直接插入T[6]中；而最后一个关键字51插人时，因探查的地址12，0，1，…，6均非空，故51插入T[7]中。</li></ul><h2 id="8-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#8-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h2><p>　　默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置　　</p><h2 id="9-重新调整HashMap大小存在什么问题吗？"><a href="#9-重新调整HashMap大小存在什么问题吗？" class="headerlink" title="9.重新调整HashMap大小存在什么问题吗？"></a>9.重新调整HashMap大小存在什么问题吗？</h2><ul><li>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。因为直接插入的效率更高。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap）。</li><li>为什么多线程会导致死循环，它是怎么发生的？<br>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。1.扩容：创建一个新的Entry空数组，长度是原数组的2倍。2.ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。</li></ul><h2 id="10-HashTable"><a href="#10-HashTable" class="headerlink" title="10.HashTable"></a>10.HashTable</h2><p>数组 + 链表方式存储<br>默认容量： 11(质数为宜)</p><h4 id="Put"><a href="#Put" class="headerlink" title="Put:"></a><code>Put:</code></h4><ul><li>对key的hashCode()做hash运算，计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树(JDK1.8中的改动)； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。</li><li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li><li>若在链表中找到了，则替换旧值，若未找到则继续</li><li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li><li>将新元素加到链表头部,对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。<h4 id="Get"><a href="#Get" class="headerlink" title="Get:"></a><code>Get:</code></h4>对key的hashCode()做hash运算，计算index; 如果在bucket里的第一个节点里直接命中，则直接返回； 如果有冲突，则通过key.equals(k)去查找对应的Entry;<br>• 若为树，则在树中通过key.equals(k)查找，O(logn)；<br>• 若为链表，则在链表中通过key.equals(k)查找，O(n)。</li></ul><h2 id="11-HashMap-，HashTable-区别"><a href="#11-HashMap-，HashTable-区别" class="headerlink" title="11.HashMap ，HashTable 区别"></a>11.HashMap ，HashTable 区别</h2><ul><li>默认容量不同。扩容不同</li><li>线程安全性，HashTable 安全  </li><li>效率不同 HashTable 要慢因为加锁</li></ul><h2 id="12-可以使用CocurrentHashMap来代替Hashtable吗？"><a href="#12-可以使用CocurrentHashMap来代替Hashtable吗？" class="headerlink" title="12.可以使用CocurrentHashMap来代替Hashtable吗？"></a>12.可以使用CocurrentHashMap来代替Hashtable吗？</h2><p>我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p><h2 id="13-CocurrentHashMap（1-8）"><a href="#13-CocurrentHashMap（1-8）" class="headerlink" title="13.CocurrentHashMap（1.8）"></a>13.CocurrentHashMap（1.8）</h2><ul><li>其中抛弃了原有的 Segment 分段锁，而采用了<code>CAS + synchronized</code>来保证并发安全性。</li><li>其中的 val next 都用了 <code>volatile</code>修饰，保证了可见性</li><li>最大特点是引入了 CAS（借助 Unsafe 来实现【native code】）<br>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li><li><p>CAS 会出现的问题：ABA<br>解决：对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。<br>####<code>Put过程</code></p></li><li><p>根据 key 计算出 hashcode 。判断是否需要进行初始化。</p></li><li>通过 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li><p>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</p><h4 id="Get过程"><a href="#Get过程" class="headerlink" title="Get过程"></a><code>Get过程</code></h4></li><li><p>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p></li><li>如果是红黑树那就按照树的方式获取值。</li><li>都不满足那就按照链表的方式遍历获取值。</li></ul><h2 id="14-TreeMap"><a href="#14-TreeMap" class="headerlink" title="14.TreeMap"></a>14.TreeMap</h2><p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和HashMap不同，它的get、put、remove之类操作都是O(logn)的复杂度，具体顺序可以由指定的Comparator来决定，或者根据键的自然顺序来判断</p><h2 id="15-hash算法是干嘛的？还知道哪些hash算法？"><a href="#15-hash算法是干嘛的？还知道哪些hash算法？" class="headerlink" title="15.hash算法是干嘛的？还知道哪些hash算法？"></a>15.hash算法是干嘛的？还知道哪些hash算法？</h2><p>Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。<br>比较出名的算法有SHA,MD4、MD5等</p><p>说说String中hashcode的实现?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>String类中的hashCode计算方法还是比较简单的，就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。</li><li>哈希计算公式可以计为<figure class="highlight plain"><figcaption><span>+ s[1]*31^(n-2) + ... + s[n-1]```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 那为什么以31为质数呢?</span><br><span class="line">主要是因为31是一个奇质数，所以```31*i=32*i-i=(i&lt;&lt;5)-i```，这种位移与减法结合的计算相比一般的运算快很多。</span><br><span class="line"></span><br><span class="line">## 16.健可以为Null值么?</span><br><span class="line"></span><br><span class="line">可以，key为null的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。</span><br><span class="line"></span><br><span class="line">## 17.一般用什么作为HashMap的key?</span><br><span class="line"></span><br><span class="line">一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。</span><br><span class="line">• (1) 因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</span><br><span class="line">• (2) 因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的覆写了hashCode()以及equals()方法。</span><br><span class="line"></span><br><span class="line">## Hashcode</span><br><span class="line">* 一、hashCode简介</span><br><span class="line">public int hashCode()：``hashCode``是根类Obeject中的方法。默认情况下，Object中的``hashCode() ``返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。</span><br><span class="line">* 二、hashCode注意点</span><br><span class="line">关于hashCode方法，一致的约定是：</span><br><span class="line">1、重写了``euqls``方法的对象必须同时重写``hashCode()``方法。</span><br><span class="line">2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</span><br><span class="line">3、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</span><br><span class="line">* 三、hashCode作用</span><br><span class="line">从Object角度看，JVM每new一个Object，它都会将这个Object丢到一个Hash表中去，这样的话，下次做Object的比较或者取这个对象的时候（读取过程），它会根据对象的HashCode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。若HashCode相同再去调用equal。</span><br><span class="line">HashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。</span><br><span class="line">* 四、为什么重写</span><br><span class="line">实际开发的过程中在hashmap或者hashset里如果不重写的hashcode和equals方法的话会导致我们存对象的时候，把对象存进去了，取的时候却取不到想要的对象。</span><br><span class="line">重写了hashcode和equals方法可以迅速的在hashmap中找到键的位置；</span><br><span class="line">1、重写hashcode是为了保证相同的对象会有相同的hashcode；</span><br><span class="line">2、重写equals是为了保证在发生冲突的情况下取得到Entry对象（也可以理解是key或是元素）；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存在一个table数组，里面每个元素都是一个node链表，当添加一个元素（key-value）时，就首先计算元素key的hash值，通过table的长度和key的hash值进行与运算得到一个index，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就把这个元素添加到同一hash值的node链表的链尾，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度大于等于8时，链表就可能转换为红黑树，这样大大提高了查找的效率。</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191102133424361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM1ODMzMTE=,size_16,color_FFFFFF,t_70&quot; alt=&quot;存储结构&quot; /&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&amp;lt;K,V&amp;gt; next; //可以看得出这是一个链表</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li></ul><li>HashMap内部包含一个Node类型的数组table，Node由Map.Entry继承而来。</li><br><li>Node存储着键值对。它包含四个字段，从next字段我们可以看出node是一个链表。</li><br><li>table数组中的每个位置都可以当做一个桶，一个桶存放一个链表。</li><br><li>HashMap使用拉链法来解决冲突，同一个存放散列值相同的Node。</li><br><h4 id="数据域">数据域</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;  </span><br><span class="line"><span class="comment">// 初始化容量，初始化有16个桶</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &amp;lt;&amp;lt; <span class="number">4</span>; <span class="comment">// aka 16  </span></span><br><span class="line"><span class="comment">// 最大容量  1 073 741 824, 10亿多</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &amp;lt;&amp;lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 当put()一个元素到某个桶，其链表长度达到8时有可能将链表转换为红黑树  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;  </span><br><span class="line"><span class="comment">// 在hashMap扩容时，如果发现链表长度小于等于6，则会由红黑树重新退化为链表。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;  </span><br><span class="line"><span class="comment">// 在转变成红黑树树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换，否者直接扩容。这是为了避免在HashMap建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;  </span><br><span class="line"><span class="comment">// 存储元素的数组  </span></span><br><span class="line"><span class="keyword">transient</span> Node&amp;lt;k,v&amp;gt;[] table;</span><br><span class="line"><span class="comment">// 存放元素的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 被修改的次数fast-fail机制   </span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 临界值 当实际大小(容量*填充比)超过临界值时，会进行扩容   </span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 填充比</span></span><br><span class="line">final float loadFactor;&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;h4 id="构造函数"&gt;构造函数&lt;/h4&gt;</span><br><span class="line">&lt;pre <span class="class"><span class="keyword">class</span></span>=<span class="string">"java"</span>&gt;&lt;code&gt;<span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &amp;lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(&amp;quot;Illegal initial capacity: &amp;quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &amp;gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &amp;lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(&amp;quot;Illegal load factor: &amp;quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// tableSizeFor(initialCapacity)方法计算出接近initialCapacity</span></span><br><span class="line">        <span class="comment">// 参数的2^n来作为初始化容量。</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&amp;lt;? extends K, ? extends V&amp;gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li><p>HashMap构造函数允许用户传入容量不是2的n次方，因为它可以自动地将传入的容量转换为2的n次方。</p><br></li></ul><br>### <code>Put()</code>源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// “扰动函数”。参考 https://www.cnblogs.com/zhengwang/p/8136164.html</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; <span class="number">16</span>);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] tab; HashMap.Node&amp;lt;K,V&amp;gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 未初始化则初始化table</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 通过table的长度和hash与运算得到一个index，</span></span><br><span class="line">        <span class="comment">// 然后判断table数组下标为index处是否已经存在node。</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp;amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果table数组下标为index处为空则新创建一个node放在该处</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 运行到这代表table数组下标为index处已经存在node，即发生了碰撞</span></span><br><span class="line">            HashMap.Node&amp;lt;K,V&amp;gt; e; K k;</span><br><span class="line">            <span class="comment">// 检查这个node的key是否跟插入的key是否相同。</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                    ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 检查这个node是否已经是一个红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果这个node已经是一个红黑树则继续往树种添加节点</span></span><br><span class="line">                e = ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 在这里循环遍历node链表</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断是否到达链表尾</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 到达链表尾，直接把新node插入链表，插入链表尾部，在jdk8之前是头插法</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &amp;gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            <span class="comment">// 如果node链表的长度大于等于8则可能把这个node转换为红黑树</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 检查这个node的key是否跟插入的key是否相同。</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当插入key存在，则更新value值并返回旧value</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改次数++</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 如果当前大小大于门限，门限原本是初始容量*0.75</span></span><br><span class="line">        <span class="keyword">if</span> (++size &amp;gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>下面简单说下put()流程：<br><ol><br><li>判断键值对数组table[]是否为空或为null，否则以默认大小resize()；</li><br><li>根据键key计算hash值与table的长度进行与运算得到插入的数组索引 index，如果tab[index] == null，直接根据key-value新建node添加，否则转入3</li><br><li>判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可),分别处理</li><br></ol></li><p><li>为啥头插法为什么要换成尾插：jdk1.7时候用头插法可能是考虑到了一个所谓的热点数据的点(新插入的数据可能会更早用到)；找到链表尾部的时间复杂度是 O(n)，或者需要使用额外的内存地址来保存链表尾部的位置，头插法可以节省插入耗时。但是在扩容时会改变链表中元素原本的顺序，以至于在<strong>并发场景下导致链表成环</strong>的问题。</li></p><p><li>从putVal()源码可以看出，HashMap并没有对null的键值对做限制（hash值设为0），即HashMap允许插入键尾null的键值对。但在JDK1.8之前HashMap使用第0个node存放键为null的键值对。</li></p><p><li>确定node下标：通过table的长度和key的hash进行与运算得到一个index。</li></p><p><li>在转变成红黑树树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换，否者直接扩容。这是为了避免在HashMap建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</li><br></p></ul><p></p><h4 id="get操作源码解析">get()操作源码解析</h4><br><pre class="java"><code>public V get(Object key) {<br>        HashMap.Node&lt;K,V&gt; e;<br>        return (e = getNode(hash(key), key)) == null ? null : e.value;<br>    }<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.Node&amp;lt;K,V&amp;gt; getNode(<span class="keyword">int</span> hash, Object key) &#123;</span><br><span class="line">    HashMap.Node&amp;lt;K,V&amp;gt;[] tab; HashMap.Node&amp;lt;K,V&amp;gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// table不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;amp;&amp;amp; (n = tab.length) &amp;gt; <span class="number">0</span> &amp;amp;&amp;amp;</span><br><span class="line">            <span class="comment">// 通过table的长度和hash与运算得到一个index，table</span></span><br><span class="line">            <span class="comment">// 下标位index处的元素不为空，即元素为node链表</span></span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp;amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 首先判断node链表中中第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;amp;&amp;amp; <span class="comment">// always check first node</span></span><br><span class="line">                <span class="comment">// 分别判断key为null和key不为null的情况</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// key相等则返回第一个</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 第一个节点key不同且node链表不止包含一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断node链表是否转为红黑树。</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">                <span class="comment">// 则在红黑树中进行查找。</span></span><br><span class="line">                <span class="keyword">return</span> ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 循环遍历node链表中的节点，判断key是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key在table中不存在则返回null。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>get(key)方法首先获取key的hash值，<br><ol><br><li>计算hash &amp; (table.len - 1)得到在链表数组中的位置，</li><br><li>先判断node链表（桶）中的第一个节点的key是否与参数key相等，</li><br><li>不等则判断是否已经转为红黑树，若转为红黑树则在红黑树中查找，</li><br><li>如没有转为红黑树就遍历后面的链表找到相同的key值返回对应的Value值即可。</li><br></ol></li><br></ul><br><h4 id="resize操作源码解析">resize()操作源码解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化或者扩容之后的元素调整</span></span><br><span class="line">    <span class="keyword">final</span> HashMap.Node&amp;lt;K,V&amp;gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">// 获取旧table</span></span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">// 旧table容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">// 旧table扩容临界值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">// 定义新table容量和临界值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果原table不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果table容量达到最大值，则修改临界值为Integer.MAX_VALUE</span></span><br><span class="line">            <span class="comment">// MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;</span></span><br><span class="line">            <span class="comment">// Integer.MAX_VALUE = 1 &amp;lt;&amp;lt; 31 - 1;</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &amp;gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// Map达到最大容量，这时还要向map中放数据，则直接设置临界值为整数的最大值</span></span><br><span class="line">                <span class="comment">// 在容量没有达到最大值之前不会再resize。</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">// 结束操作</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面就是扩容操作（2倍）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &amp;lt;&amp;lt; <span class="number">1</span>) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;</span><br><span class="line">                    oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">// 临界值也变为两倍</span></span><br><span class="line">                newThr = oldThr &amp;lt;&amp;lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &amp;gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 进入此if证明创建HashMap时用的带参构造：public HashMap(int initialCapacity)</span></span><br><span class="line"><span class="comment">             * 或 public HashMap(int initialCapacity, float loadFactor)</span></span><br><span class="line"><span class="comment">             * 注：带参的构造中initialCapacity（初始容量值）不管是输入几都会通过</span></span><br><span class="line"><span class="comment">             * tableSizeFor(initialCapacity)方法计算出接近initialCapacity</span></span><br><span class="line"><span class="comment">             * 参数的2^n来作为初始化容量。</span></span><br><span class="line"><span class="comment">             * 所以实际创建的容量并不等于设置的初始容量。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">// 进入此if证明创建map时用的无参构造：</span></span><br><span class="line">            <span class="comment">// 然后将参数newCap（新的容量）、newThr(新的扩容阀界值)进行初始化</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 进入这代表有两种可能。</span></span><br><span class="line">            <span class="comment">// 1. 说明old table容量大于0但是小于16.</span></span><br><span class="line">            <span class="comment">// 2. 创建HashMap时用的带参构造，根据loadFactor计算临界值。</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改临界值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;&amp;quot;rawtypes&amp;quot;,&amp;quot;unchecked&amp;quot;&#125;)</span><br><span class="line">        <span class="comment">// 根据新的容量生成新的 table</span></span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] newTab = (HashMap.Node&amp;lt;K,V&amp;gt;[])<span class="keyword">new</span> HashMap.Node[newCap];</span><br><span class="line">        <span class="comment">// 替换成新的table</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">// 如果oldTab不为null说明是扩容，否则直接返回newTab</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 遍历原来的table */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; oldCap; ++j) &#123;</span><br><span class="line">                HashMap.Node&amp;lt;K,V&amp;gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 判断这个桶（链表）中就只有一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// 根据新的容量重新计算在table中的位置index，并把当前元素赋值给他。</span></span><br><span class="line">                        newTab[e.hash &amp;amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">// 判断这个链表是否已经转为红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">                        <span class="comment">// 在split函数中可能由于红黑树的长度小于等于UNTREEIFY_THRESHOLD（6）</span></span><br><span class="line">                        <span class="comment">// 则把红黑树重新转为链表</span></span><br><span class="line">                        ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">// 运行到这里证明桶中有多个节点。</span></span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">// 对桶进行遍历</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp;amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-的工作原理是什么"><a href="#HashMap-的工作原理是什么" class="headerlink" title="HashMap 的工作原理是什么?"></a>HashMap 的工作原理是什么?</h2><p>HashMap基于hashing原理，我们通过put()和get()方法存储和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来存储值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会存储在链表的第一个节点，链接原先的对象节点，HashMap在每个链表节点中存储键值对对象。</p><h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？"></a>快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？</h2><ul><li>1、快速失败（fail-fast）<br>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行修改（增加、删除、修改），则会抛出Concurrent Modification Exception.<br>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。<br>注意：这里异常的抛出条件是检测到modCount!=expectedmodCount这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。<br>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</li><li>2、安全失败（fail-safe）<br>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<br>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。<br>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception,但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的<br>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li></ul></code></pre>]]></content>
    
    <summary type="html">
    
      Find Everything about HashMap IN There.
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms, Part I | Princeton Online</title>
    <link href="http://yoursite.com/2020/01/16/Algorithms-Part-I-Princeton-Online/"/>
    <id>http://yoursite.com/2020/01/16/Algorithms-Part-I-Princeton-Online/</id>
    <published>2020-01-16T14:19:13.000Z</published>
    <updated>2020-01-16T14:29:42.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Princeton-Online-course"><a href="#Princeton-Online-course" class="headerlink" title="Princeton Online course"></a><a href="https://algs4.cs.princeton.edu/" target="_blank" rel="noopener">Princeton Online course</a></h2><h2 id="You-can-find-all-the-code-and-comments-details-in-this-Repository"><a href="#You-can-find-all-the-code-and-comments-details-in-this-Repository" class="headerlink" title="You can find all the code and comments details in this Repository"></a><a href="https://github.com/Williamren97/Alg4" target="_blank" rel="noopener">You can find all the code and comments details in this Repository</a></h2><h3 id="What-algorithms-and-data-structures-will-be-covered-in-this-course"><a href="#What-algorithms-and-data-structures-will-be-covered-in-this-course" class="headerlink" title="What algorithms and data structures will be covered in this course?"></a>What algorithms and data structures will be covered in this course?</h3><h4 id="The-first-part-will-focus-on-the-basic-data-structure-sorting-and-searching"><a href="#The-first-part-will-focus-on-the-basic-data-structure-sorting-and-searching" class="headerlink" title="The first part will focus on the basic data structure, sorting, and searching."></a>The first part will focus on the basic data structure, sorting, and searching.</h4><ul><li>Topics include: parallel search algorithm, binary search, stack, queue, backpack, insert sort, select sort, hill sort, fast sort, three-way fast sort, merge sort, heap sort, binary heap, binary search tree, red-black tree , Split link and linear probe hash tables, Graham scans, kd trees.</li></ul><h4 id="The-second-part-will-focus-on-graph-and-string-processing-algorithms"><a href="#The-second-part-will-focus-on-graph-and-string-processing-algorithms" class="headerlink" title="The second part will focus on graph and string processing algorithms."></a>The second part will focus on graph and string processing algorithms.</h4><ul><li>Topics include: depth-first search, width-first search, topology sorting, Kosaraju-Sharir algorithm, Kruskal algorithm, Prim algorithm, Dijkistra algorithm, Bellman-Ford algorithm, Ford-Fulkerson algorithm, LSD cardinality ranking algorithm, MSD cardinality ranking algorithm, three-way Cardinality fast sorting algorithm, multi-path trie algorithm, ternary search trie algorithm, Knuth-Morris-Pratt algorithm, Boyer-Moore algorithm, Rabin-Karp algorithm, regular matching, run-length encoding, Huffman encoding, LZW compression, Burrows-Wheeler transform .</li></ul><h4 id="The-Imp-of-Algorithm-in-Princeton-University"><a href="#The-Imp-of-Algorithm-in-Princeton-University" class="headerlink" title="The Imp of Algorithm in Princeton University."></a>The Imp of Algorithm in Princeton University.</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Princeton-Online-course&quot;&gt;&lt;a href=&quot;#Princeton-Online-course&quot; class=&quot;headerlink&quot; title=&quot;Princeton Online course&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
      <category term="Algorithms," scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>EveryThing About MySQL</title>
    <link href="http://yoursite.com/2020/01/14/EveryThing-About-MySQL/"/>
    <id>http://yoursite.com/2020/01/14/EveryThing-About-MySQL/</id>
    <published>2020-01-14T15:37:44.000Z</published>
    <updated>2020-02-23T16:59:23.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><p><a href="https://blog.csdn.net/chai471793/article/details/99563704" target="_blank" rel="noopener">彻底搞懂系列B-树、B+树、B-树、B*树</a></p><p><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">B树和B+树的插入、删除图文详解</a></p><h3 id="关系型数据库和非关系型数据库为什么用B树或B-树"><a href="#关系型数据库和非关系型数据库为什么用B树或B-树" class="headerlink" title="关系型数据库和非关系型数据库为什么用B树或B+树"></a><a href="https://baijiahao.baidu.com/s?id=1658675762218129560&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">关系型数据库和非关系型数据库为什么用B树或B+树</a></h3><blockquote><p>==B+树的数据只出现在叶子节点上==，因此在查询单条数据的时候，查询速度非常稳定。因此，==在做单一数据的查询上，其平均性能并不如B树==。但是，B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，==只需要对叶子节点进行遍历即可，这个特性使得B+树非常适合做范围查询==。</p></blockquote><ul><li>没准是==Mysql中数据遍历操作比较多，所以用B+树作为索引结构==。凡做这种关联查询，你躲不开join操作的！既然涉及到了<code>Join</code>操作，无外乎从一个表中取一个数据，去另一个表中逐行匹配，如果索引结构是B+树，叶子节点上是有指针的，能够极大的提高这种一行一行的匹配速度</li><li>==而Mongodb是做单一查询比较多，数据遍历操作比较少==，所以用B树作为索引结构。</li></ul><p>那么为什么Mysql做数据遍历操作多？而Mongodb做数据遍历操作少呢？因为Mysql是关系型数据库，而Mongodb是非关系型数据。</p><p>平衡二叉树则是子树高读不能超过2，B树非叶子节点也可以存储数据，B+树则是叶子节点才可以存储数据。</p><ul><li>我们说的==平衡二叉树结构，指的是逻辑结构上的平衡二叉树，其物理实现是数组==。然后由于在逻辑结构上相近的节点在物理结构上可能会差很远。因此，每次读取的磁盘页的数据中有许多是用不上的。因此，查找过程中要进行许多次的磁盘读取操作。而适合作为索引的结构应该是尽可能少的执行磁盘IO操作，因为执行磁盘IO操作非常的耗时。因此，平衡二叉树并不适合作为索引结构</li><li>红黑树这种结构==h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性==，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。也就是说，使用红黑树（平衡二叉树）结构的话，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。</li><li>==B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能==。每次读取磁盘页时就会读取一整个节点。==也正因每个节点存储着非常多个关键字，树的深度就会非常的小==。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</li><li>==B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中==。因此，虽然B树查询查询的次数不比平衡二叉树的次数少，但是相比起磁盘IO速度，内存中比较的耗时就可以忽略不计了。因此，B树更适合作为索引。</li></ul><h1 id="一步步分析为什么B-树适合作为索引的结构-以及索引原理-阿里面试，写的很好"><a href="#一步步分析为什么B-树适合作为索引的结构-以及索引原理-阿里面试，写的很好" class="headerlink" title="一步步分析为什么B+树适合作为索引的结构 以及索引原理(阿里面试，写的很好"></a><a href="https://www.cnblogs.com/aspirant/p/9214485.html" target="_blank" rel="noopener">一步步分析为什么B+树适合作为索引的结构 以及索引原理(阿里面试，写的很好</a></h1><p>B+Tree是mysql使用最频繁的一个索引数据结构，是Inodb和Myisam存储引擎模式的索引类型。相对Hash索引，B+Tree在查找单条记录的速度比不上Hash索引(Memory表只存在内存中)，但是因为更适合排序等操作，所以它更受欢迎。毕竟不可能只对数据库进行单条记录的操作。</p><ul><li><p>带顺序访问指针的B+Tree</p><blockquote><p>B+Tree所有索引数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。这样做是为了提高区间效率，例如查询key为从18到49的所有数据记录，当找到18后，只要顺着节点和指针顺序遍历就可以以此向访问到所有数据节点，极大提高了区间查询效率。</p></blockquote></li><li><p>大大减少磁盘I/O读取</p><blockquote><p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点需要一次I/O就可以完全载入</p></blockquote></li></ul><p><strong>全文索引（FULLTEXT）=mysql的myISAM搜索引擎默认的索引类型</strong>==不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法==。</p><p>文本字段上的普通索引只能加快对出现在字段内容最前面的字符串(也就是字段内容开头的字符)进行检索操作。如果字段里存放的是由几个、甚至是多个单词构成的较大段文字，普通索引就没什么作用了。这种检索往往以LIKE%word%的形式出现，这对MySQL来说很复杂，如果需要处理的数据量很大，响应时间就会很长。</p><p>这类场合正是全文索引(full-textindex)可以大显身手的地方。在生成这种类型的索引时，MySQL将把在文本中出现的所有单词创建为一份清单，查询操作将根据这份清单去检索有关的数据记录。全文索引即可以随数据表一同创建，也可以等日后有必要时再使用下面这条命令添加：<br><code>ALTER TABLE table_name ADD FULLTEXT(column1, column2)</code></p><p>有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。下面是这类查询命令的基本语法：<br>　　<br><code>SELECT * FROM table_name WHERE MATCH(column1, column2) AGAINST(&#39;word1&#39;, &#39;word2&#39;, &#39;word3&#39;)</code></p><p>上面这条命令将把column1和column2字段里有word1、word2和word3的数据记录全部查询出来。</p><p><a href="https://blog.csdn.net/qq_33330687/article/details/89004462" target="_blank" rel="noopener">InnoDB如何解决幻读</a></p><blockquote><p>使用MVCC</p></blockquote><p><a href="https://www.jianshu.com/p/bbaeab492a64" target="_blank" rel="noopener">一条SQL语句是如何执行的</a></p><p>由server层和存储引擎组成</p><blockquote><p>server 层包括连接器、分析器、优化器、执行器，涵盖 MySQL的核心服务，以及所有的内置函数（如日期、时间、数学、加密函数等），还有所有跨存储引擎的功能，例如存储过程、触发器、视图等。</p></blockquote><p><a href="https://blog.csdn.net/zxp0727/article/details/84580277" target="_blank" rel="noopener">一条SQL更新语句是如何执行的？</a></p><blockquote><p>里面包含binlog和redolog,两阶段提交</p></blockquote><h4 id="什么叫视图？游标是什么？"><a href="#什么叫视图？游标是什么？" class="headerlink" title="什么叫视图？游标是什么？"></a>什么叫视图？游标是什么？</h4><ul><li>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</li><li>游标是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</li></ul><h3 id="请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</h3><h3 id="在Mysql中ENUM的用法是什么？"><a href="#在Mysql中ENUM的用法是什么？" class="headerlink" title="在Mysql中ENUM的用法是什么？"></a>在Mysql中ENUM的用法是什么？</h3><blockquote><p>同一个属性里面包含多个字段，每个字段都有自己的索引.enum 在数据库底层以整型方式储存，从 1 开始，0 用于指代空或错误的字符串。</p></blockquote><h3 id="CHAR和VARCHAR的区别？"><a href="#CHAR和VARCHAR的区别？" class="headerlink" title="CHAR和VARCHAR的区别？"></a>CHAR和VARCHAR的区别？</h3><p>char 固定长度255，不足的部分补空格，取出时再去掉空格。varchar 不定长度</p><h3 id="drop-delete与truncate的区别"><a href="#drop-delete与truncate的区别" class="headerlink" title="drop,delete与truncate的区别"></a>drop,delete与truncate的区别</h3><p>drop删除表，truncate清空表，delete删除表、drop和truncate不能回滚。</p><h3 id="存储过程与触发器的区别"><a href="#存储过程与触发器的区别" class="headerlink" title="存储过程与触发器的区别"></a>存储过程与触发器的区别</h3><ul><li>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</li><li>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。可以供外部程序调用，比如：java程序。<blockquote><p>存储过程是预编译过的，执行效率高。存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。安全性高，执行存储过程需要有一定权限的用户。存储过程可以重复使用，可减少数据库开发人员的工作量。==缺点：移植性差==。</p></blockquote></li></ul><p>2）可以供外部程序调用，比如：java程序。</p><h3 id="完整性约束包括哪些？"><a href="#完整性约束包括哪些？" class="headerlink" title="完整性约束包括哪些？"></a><a href="https://www.cnblogs.com/hwlong/p/9009311.html" target="_blank" rel="noopener">完整性约束包括哪些</a>？</h3><p>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</p><ul><li>实体完整性：规定表的每一行在表中是惟一的实体。</li><li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li><li>参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</li><li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li></ul><p>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE)</p><p>MySql不支持check</p><h3 id="Mysql-的存储引擎-myisam和innodb的区别。"><a href="#Mysql-的存储引擎-myisam和innodb的区别。" class="headerlink" title="Mysql 的存储引擎,myisam和innodb的区别。"></a>Mysql 的存储引擎,myisam和innodb的区别。</h3><pre><code>NULL | myisam | innodb</code></pre><p>   —|—|—<br>事务支持|不支持| 支持| row 2 col 2<br>存储结构     |三种文件  | 一种文件<br>存储空间     |体积小 | 体积大<br>可移植性     |方便 | 困难<br>锁力度     |表级锁| 表级锁，行级锁<br>全文索引     |支持 | 不支持<br>表主键     |可以没有|必须有，没有就自动生成<br>外键     |不支持 | 支持</p><h2 id="1-锁"><a href="#1-锁" class="headerlink" title="1.锁"></a>1.锁</h2><ul><li>MyISAM 是非事务的存储引擎，适合用于频繁查询的应用。表锁，不会出现死锁，适合小数据，小并发。</li><li>Innodb是支持事务的存储引擎，合于插入和更新操作比较多的应用，设计合理的话是行锁（最大区别就在锁的级别上），适合大数据，大并发<br><img src="https://upload-images.jianshu.io/upload_images/2604566-27832dbe20e803fa.png" alt="image"><h3 id="表锁和行锁的区别"><a href="#表锁和行锁的区别" class="headerlink" title="表锁和行锁的区别"></a>表锁和行锁的区别</h3><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5></li><li>特点：开销小、加锁快、<strong>无死锁</strong>；锁粒度大，发生锁冲突的概率高，<strong>高并发下性能低</strong></li><li>加锁的方式：自动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5></li><li>特点：锁的粒度小，发生锁冲突的概率低、<strong>处理并发的能力强</strong>；开销大、加锁慢、<strong>会出现死锁</strong></li><li><p>加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁。</p></li><li><p>乐观锁：不加锁，只有在更新时验证数据是否被其他线程更新，吞吐量较高，适用于多读场景。它==假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚==。</p><blockquote><p>乐观锁实现方式是：版本号version和CAS(compare and swap)</p></blockquote></li><li>悲观锁：读取时加锁，更新完释放锁，再此过程中会造成其他线程阻塞，导致吞吐量低，适用于多写场景。当事务A对某行数据应用了锁，==并且当这个事务把锁释放后，其他事务才能够执行与该锁冲突的操作==，这里事务A所施加的锁就叫悲观锁。</li></ul><blockquote><p>行锁(共享锁和排他锁),间隙锁(next-keylock）都属于悲观锁。<br>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：==允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁==。</li><li>排他锁（X)：==允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。==<br>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</li></ul></blockquote><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁* ，事务在给一个数据行加排他锁前必须先取得该表的IX锁。<h5 id="间隙锁（Next-Key锁）"><a href="#间隙锁（Next-Key锁）" class="headerlink" title="间隙锁（Next-Key锁）:"></a>间隙锁（Next-Key锁）:</h5></li><li>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；</li><li>对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key)锁。</li></ul><hr><ul><li>1:<strong>表级锁不会死锁,行级锁和页级锁可能死锁</strong></li><li>2:在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</li><li>3:==从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应==用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</li><li>4:意向锁是InnoDB自动加的，不需用户干预。==对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)==；对于普通SELECT语句，InnoDB不会加任何锁；</li><li>5:InnoDB行锁实现方式: ==InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁==</li></ul><h3 id="Mysql中MVCC的使用及原理详解"><a href="#Mysql中MVCC的使用及原理详解" class="headerlink" title="Mysql中MVCC的使用及原理详解"></a><a href="https://blog.csdn.net/w2064004678/article/details/83012387" target="_blank" rel="noopener">Mysql中MVCC的使用及原理详解</a></h3><p>MVCC是一种多版本并发控制机制。MVCC是通过保存数据在某个时间点的快照来实现的。在每个表后添加创建版本号和删除版本号，版本号为修改该项的事务版本号。</p><ul><li>SELECT:InnoDB会根据以下两个条件检查每行记录<blockquote><p>InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的.</p></blockquote></li></ul><blockquote><p>行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除.<br>只有a,b同时满足的记录，才能返回作为查询结果.</p></blockquote><ul><li><p>DELETE:InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识.</p></li><li><p>UPDATE:InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间。</p></li></ul><h2 id="锁策略"><a href="#锁策略" class="headerlink" title="锁策略"></a><a href="https://www.nowcoder.com/discuss/151430" target="_blank" rel="noopener">锁策略</a></h2><h2 id="2-日志"><a href="#2-日志" class="headerlink" title="2.日志"></a>2.日志</h2><h3 id="redolog，binlog，undolog对事务的影响"><a href="#redolog，binlog，undolog对事务的影响" class="headerlink" title="redolog，binlog，undolog对事务的影响"></a>redolog，binlog，undolog对事务的影响</h3><ul><li>binlog</li><li>redolog,保证事务的持久性，缓存区中数据会慢慢更新到数据库的硬盘上。</li><li>undolog，记录了修改几率，可以随便回滚，保证原子性。</li></ul><h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h2><p>MVCC (MultiVersion Concurrency Control) 叫做==多版本并发==控制。==由undolog和记录版本的一个东西组成==。</p><blockquote><p>InnoDB的 MVCC，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，当然存储的并不是实际的时间值，而是系统版本号。</p></blockquote><p>以上片段摘自《高性能Mysql》这本书对MVCC的定义。他的主要实现思想是通过==数据多版本==来做到==读写分离==。从而实现不加锁读进而做到读写并行。</p><p><strong>MVCC在mysql中的实现依赖的是undo log与read view</strong></p><ul><li>undolog :undolog中记录某行数据的多个版本的数据。</li><li>read view :用来判断当前版本数据的可见性<h3 id="ACID特性中的一致性是如何实现的"><a href="#ACID特性中的一致性是如何实现的" class="headerlink" title="ACID特性中的一致性是如何实现的"></a>ACID特性中的一致性是如何实现的</h3></li><li>事务的原子性是通过 undo log 来实现的</li><li>事务的持久性性是通过 redo log 来实现的</li><li>事务的隔离性是通过 (读写锁+MVCC)来实现的</li><li>而事务的终极大boss一致性是通过原子性，持久性，隔离性来实现的！！！<blockquote><p>原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性</p></blockquote></li><li><a href="https://www.sohu.com/a/316482862_663371" target="_blank" rel="noopener">事务是如何通过日志实现的</a></li><li>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Buffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。<blockquote><p>redolog来记录已成功提交事务的修改信息，并且会把redolog持久化到磁盘，系统重启之后在读取redo log恢复最新数据。redolog是用来恢复数据的 用于保障，已提交事务的持久化特性</p></blockquote></li></ul><blockquote><p>undolog 叫做回滚日志，用于记录数据被修改前的信息。<strong>他正好跟前面所说的重做日志所记录的相反，redolog记录数据被修改后的信息。undolog主要记录的是数据的逻辑变化</strong>，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。undolog记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undolog的信息来进行回滚到没被修改前的状态。</p></blockquote><p><code>redo和undo</code>基本流程如下：<br>因为事务在修改页时，要先记 undo，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 Redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。 当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的状态，崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。 如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。</p><h2 id="4-索引"><a href="#4-索引" class="headerlink" title="4.索引"></a>4.索引</h2><h3 id="MySQL索引背后的数据结构及算法原理"><a href="#MySQL索引背后的数据结构及算法原理" class="headerlink" title="MySQL索引背后的数据结构及算法原理"></a><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></h3><h3 id="多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）"><a href="#多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）" class="headerlink" title="多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）"></a>多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）</h3><ul><li><p>唯一索引</p><blockquote><p>唯一索引是<strong>不允许其中任何两行具有相同索引值的索引</strong>。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p></blockquote></li><li><p>主键索引</p><blockquote><p>数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p></blockquote></li><li><p>聚集索引</p><blockquote><p>表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p></blockquote><h3 id="建索引有哪些原则"><a href="#建索引有哪些原则" class="headerlink" title="建索引有哪些原则"></a>建索引有哪些原则</h3><blockquote><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说应该在这些列上创建索引：</p></blockquote></li><li><p>在经常需要搜索的列上，可以加快搜索的速度</p></li><li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li><li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li></ul><h3 id="什么情况下设置了索引但无法使用"><a href="#什么情况下设置了索引但无法使用" class="headerlink" title="什么情况下设置了索引但无法使用"></a>什么情况下设置了索引但无法使用</h3><ul><li>条件中使用了 or，而相关列不全有索引</li><li>条件中使用了and，而相关列不满足最左原则</li><li>索引列的数据类型出现隐形转换，如varchar不加单引号的话可能会自动转换为int型）</li><li>like查询是以%开头</li><li>where 子句里对索引列上有数学运算/函数</li><li>mysql估计使用全表扫描要比使用索引快<h3 id="什么情况下不宜建立索引？"><a href="#什么情况下不宜建立索引？" class="headerlink" title="什么情况下不宜建立索引？"></a>什么情况下不宜建立索引？</h3></li><li>对于那些在查询中==很少使用或者参考的列不应该创建索引==。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>对于那些==只有很少数据值的列==也不应该增加索引。举例比如性别只有男和女</li><li>对于==那些定义为text,image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少==。</li><li>经==常频繁更新的列==不要建立索引，因为肯定会影响插入或更新的效率</li><li>尽量避==免在 where 子句中使用 ！= 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫==描。</li><li>当==修改性能远远大于检索性能时，不应该创建索引==。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li><li>尽量避免NULL：在MySQL中，==含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂==。可以采用0、一个特殊的值或者一个空串代替空值<blockquote><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p></blockquote><h3 id="为什么用B-树"><a href="#为什么用B-树" class="headerlink" title="为什么用B-树"></a>为什么用B-树</h3>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了==磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入== 为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</li></ul><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>为什么不用红黑树</p><blockquote><p>红黑树这种结构，h(层数)明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p></blockquote><h3 id="MySQL索引失效的情形很多。"><a href="#MySQL索引失效的情形很多。" class="headerlink" title="MySQL索引失效的情形很多。"></a>MySQL索引失效的情形很多。</h3><p>例如： 在WHERE条件的LIKE关键字匹配的字符串以”%“开头，这种情况下，索引是不会起到作用的；WHERE条件中使用OR关键字来连接多个查询条件，如果有一个条件没有使用索引，那么其他的索引也不会起作用；多列索引的第一个字段没有使用，那么这个多列索引也不会起作用。 使用in查询时，in查询条件超过数据库表的一半的时候也会失效。</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><ul><li>索引字段要尽量的小</li><li>索引的最左匹配特性（即从左往右匹配）：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</li></ul><h3 id="MySQL索引优化深入分析执行计划"><a href="#MySQL索引优化深入分析执行计划" class="headerlink" title="MySQL索引优化深入分析执行计划"></a><a href="https://mp.weixin.qq.com/s/TSbfdC6G-r8pvgpQ3qyjMA" target="_blank" rel="noopener">MySQL索引优化深入分析执行计划</a></h3><h3 id="如果有2级索引怎么存"><a href="#如果有2级索引怎么存" class="headerlink" title="如果有2级索引怎么存"></a>如果有2级索引怎么存</h3><h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，==磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。==这样做的理论依据是计算机科学中著名的==<br>局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中==。</p><p><strong>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效</strong>率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，<strong>会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行</strong></p><h2 id="5-SQL语句"><a href="#5-SQL语句" class="headerlink" title="5.SQL语句"></a>5.SQL语句</h2><p> <a href="https://www.runoob.com/sql/sql-groupby.html" target="_blank" rel="noopener">SQL语句菜鸟教程</a></p><h4 id="SQL教程"><a href="#SQL教程" class="headerlink" title="SQL教程"></a>SQL教程</h4><ul><li><code>AND</code>运算符，如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</li><li><p><code>OR运算符</code>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Websites</span><br><span class="line">WHERE alexa &gt; 15</span><br><span class="line">AND (country=&apos;CN&apos; OR country=&apos;USA&apos;);</span><br></pre></td></tr></table></figure></li><li><p><code>ORDER BY</code> 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p></li><li><code>IN</code>操作符IN操作符允许在WHERE子句中规定多个值。</li><li><p><code>BETWEEN</code>操作符用于选取介于两个值之间的数据范围内的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Websites</span><br><span class="line">WHERE (alexa BETWEEN 1 AND 20)</span><br><span class="line">AND country NOT IN (&apos;USA&apos;, &apos;IND&apos;);</span><br></pre></td></tr></table></figure></li><li><p>INNER JOIN：如果表中有至少一个匹配，则返回行</p></li><li>LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN：只要其中一个表中存在匹配，则返回行</li></ul><h4 id="SQL高级教程"><a href="#SQL高级教程" class="headerlink" title="SQL高级教程"></a>SQL高级教程</h4><ul><li>模糊查询(like)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Websites</span><br><span class="line">以&quot;G&quot;开始的所有客户WHERE name LIKE &apos;G%&apos;;</span><br><span class="line">以&quot;k&quot;结尾的所有客户WHERE name LIKE &apos;%k&apos;;</span><br><span class="line">还可以写NOT LIKE做反向查询</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://blog.csdn.net/lu0422/article/details/78892497" target="_blank" rel="noopener">解释MySQL外连接、内连接(outer join和inner join)与自连接的区别外连接</a><br><img src="https://www.runoob.com/wp-content/uploads/2019/01/sql-join.png" alt="SQL JOINS"></p><ul><li>左连接：连接两张表，左表数据完全显示，右表匹配，匹配不上的补null；在这里，t_employee就是左表，也就是基准表，==用基准表的数据去匹配右表的数据，所以左表的记录是全部会查询出来的，如果右表没有记录对应的话就显示null==。<blockquote><p>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</p></blockquote></li><li>右连接：同上，换个方向；<br>全外连接：两表字段都匹配，匹配不上的补null；</li><li>内连接：所有查询出的结果都是能够在连接的表中有对应记录的。这就是内连接的特点，==只查询在连接的表中能够有对应的记录==，<blockquote><p>INNER JOIN关键字在表中存在至少一个匹配时返回行。</p></blockquote></li><li>全外连接：==mysql是没有全外连接的==(mysql中没有<code>full outer join</code>关键字)，==想要达到全外连接的效果，可以使用<code>union</code>关键字连接左外连接和右外连接==。<strong>如果在Oracle中，直接就使用<code>full outer join</code>关键字连接两表就行了。</strong></li><li><p>UNION</p><blockquote><p>SQL UNION 操作符合并两个或多个 SELECT 语句的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT country FROM Websites</span><br><span class="line">UNION</span><br><span class="line">SELECT country FROM apps</span><br><span class="line">ORDER BY country;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>SELECT INTO</p><blockquote><p>通过 SQL，您可以从一个表复制信息到另一个表。SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 新表</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM 旧表</span><br></pre></td></tr></table></figure><ul><li><p>INSERT INTO SELECT</p><blockquote><p>通过 SQL，您可以从一个表复制信息到另一个表。INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table2</span><br><span class="line">SELECT * FROM table1;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>自连接：找到两表的公共字段，然后和内连接一样。</p></li><li>交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</li></ul><p><code>SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</code></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a><a href="https://www.cnblogs.com/wz123/p/9722942.html" target="_blank" rel="noopener">子查询</a></h3><p>一个SELECT语句嵌套在另一个SELECT语句中，子查询也叫做内部查询，而包含子查询的语句又称为外部查询或主查询，子查询自身可以包含一个或多个子查询，一个查询语句中可以嵌套任意数量的子查询。</p><h4 id="SQL查询重复记录"><a href="#SQL查询重复记录" class="headerlink" title="SQL查询重复记录"></a><a href="https://www.cnblogs.com/njccqx/p/9672504.html" target="_blank" rel="noopener">SQL查询重复记录</a></h4><hr><p><a href="https://blog.csdn.net/a755199443/article/details/88723685" target="_blank" rel="noopener">MySQL两道经典SQL面试题(行转列/列转行/求最值)</a></p><h3 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h3><ul><li>GROUP BY<blockquote><p>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">统计 access_log 各个 site_id 的访问量：</span><br><span class="line">SELECT site_id, SUM(access_log.count) AS nums</span><br><span class="line">FROM access_log GROUP BY site_id;</span><br></pre></td></tr></table></figure></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Websites.name,COUNT(access_log.aid) AS nums FROM access_log</span><br><span class="line">LEFT JOIN Websites</span><br><span class="line">ON access_log.site_id=Websites.id</span><br><span class="line">GROUP BY Websites.name;</span><br></pre></td></tr></table></figure><ul><li>HAVING<blockquote><p>在 SQL 中增加 HAVING 子句原因是，==WHERE 关键字无法与聚合函数一起使用==。HAVING 子句可以让我们筛选分组后的各组数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查找总访问量大于 200 的网站。</span><br><span class="line">SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_log INNER JOIN Websites</span><br><span class="line">ON access_log.site_id=Websites.id)</span><br><span class="line">GROUP BY Websites.name</span><br><span class="line">HAVING SUM(access_log.count) &gt; 200;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="6-SQL优化"><a href="#6-SQL优化" class="headerlink" title="6.SQL优化"></a>6.SQL优化</h2><h6 id="慢查询解决的基本步骤"><a href="#慢查询解决的基本步骤" class="headerlink" title="慢查询解决的基本步骤"></a>慢查询解决的基本步骤</h6><h6 id="500万数量级查询优化"><a href="#500万数量级查询优化" class="headerlink" title="500万数量级查询优化"></a><a href="https://mp.weixin.qq.com/s/-ZSBoPVYUY5UN_lrwqQKVw" target="_blank" rel="noopener">500万数量级查询优化</a></h6><h6 id="我们是如何对实际项目进行查询优化的"><a href="#我们是如何对实际项目进行查询优化的" class="headerlink" title="我们是如何对实际项目进行查询优化的"></a><a href="https://mp.weixin.qq.com/s/zhvN31uYtm-507k3GKJeKg" target="_blank" rel="noopener">我们是如何对实际项目进行查询优化的</a></h6><h6 id="巧用这19条MySQL优化，效率至少提高3倍"><a href="#巧用这19条MySQL优化，效率至少提高3倍" class="headerlink" title="巧用这19条MySQL优化，效率至少提高3倍"></a><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485120&amp;idx=2&amp;sn=c80bd2698209858d86975d551b2144f3&amp;source=41#wechat_redirect" target="_blank" rel="noopener">巧用这19条MySQL优化，效率至少提高3倍</a></h6><h6 id="为什么要分区，分表和分库？"><a href="#为什么要分区，分表和分库？" class="headerlink" title="为什么要分区，分表和分库？"></a><a href="https://www.cnblogs.com/tuhooo/p/9582223.html" target="_blank" rel="noopener">为什么要分区，分表和分库？</a></h6><h6 id="一次SQL查询优化原理分析（900W-数据，从17s到300ms"><a href="#一次SQL查询优化原理分析（900W-数据，从17s到300ms" class="headerlink" title="一次SQL查询优化原理分析（900W+数据，从17s到300ms"></a><a href="https://www.jianshu.com/p/0768ebc4e28d" target="_blank" rel="noopener">一次SQL查询优化原理分析（900W+数据，从17s到300ms</a></h6><h6 id="面试官：给我讲一下分库分表方案"><a href="#面试官：给我讲一下分库分表方案" class="headerlink" title="面试官：给我讲一下分库分表方案"></a><a href="https://www.jianshu.com/p/bf27be3fd448" target="_blank" rel="noopener">面试官：给我讲一下分库分表方案</a></h6><h6 id="数据库如何保证数据不丢失"><a href="#数据库如何保证数据不丢失" class="headerlink" title="数据库如何保证数据不丢失"></a><a href="https://www.cnblogs.com/a-phper/p/10313948.html" target="_blank" rel="noopener">数据库如何保证数据不丢失</a></h6><h6 id="MYSQL的主从同步延迟的原因及解决方案"><a href="#MYSQL的主从同步延迟的原因及解决方案" class="headerlink" title="MYSQL的主从同步延迟的原因及解决方案"></a><a href="https://blog.csdn.net/hao_yunfeng/article/details/82392261" target="_blank" rel="noopener">MYSQL的主从同步延迟的原因及解决方案</a></h6><ul><li>mysql主从复制用途<blockquote><p>从库生成两个线程，一个I/O线程，一个SQL线程；i/o线程去请求主库的binlog，并将得到的binlog日志写到relaylog（中继日志）文件中；主库会生成一个 log dump 线程，用来给从库i/o线程传binlog；<br>SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；</p></blockquote></li></ul><p>实时灾备，用于故障切换,==读写分离(主写从读比例为10：1)==，提供查询服务<br>备份，避免影响业务</p><ul><li>主从部署必要条件：<br>主库开启binlog日志（设置log-bin参数）,主从server-id不同,从库服务器能连通主库<h6 id="数据库如何保证高可用"><a href="#数据库如何保证高可用" class="headerlink" title="数据库如何保证高可用"></a><a href="https://blog.csdn.net/dhfzhishi/article/details/82561939" target="_blank" rel="noopener">数据库如何保证高可用</a></h6><h6 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a><a href="https://blog.csdn.net/qq_42234452/article/details/90906692?fps=1&amp;locationNum=2" target="_blank" rel="noopener">灰度发布</a></h6>在灰度发布开始后，先启动一个新版本应用，但是并不直接将流量切过来，而是测试人员对新版本进行线上测试，启动的这个新版本应用，就是我们的金丝雀。如果没有问题，那么可以将少量的用户流量导入到新版本上，然后再对新版本做运行状态观察，收集各种运行时数据，如果此时对新旧版本做各种数据对比，就是所谓的A/B测试。</li></ul><p>当确认新版本运行良好后，再逐步将更多的流量导入到新版本上，在此期间，还可以不断地调整新旧两个版本的运行的服务器副本数量，以使得新版本能够承受越来越大的流量压力。直到将100%的流量都切换到新版本上，最后关闭剩下的老版本服务，完成灰度发布。</p><p>如果在灰度发布过程中（灰度期）发现了新版本有问题，就应该立即将流量切回老版本上，这样，就会将负面影响控制在最小范围内。</p><h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h2><h6 id="创建表时候的优化"><a href="#创建表时候的优化" class="headerlink" title="创建表时候的优化"></a>创建表时候的优化</h6><ul><li>整数TinyInt,SmallInt,MediumInt,Int,BigInt 使用的存储 8,16,24,32,64 位存储空间。使用 Unsigned 表示不允许负数，可以使正数的上线提高一倍。</li><li>实数Float,Double , 支持近似的浮点运算。<br>Decimal，用于存储精确的小数。</li><li>字符串VarChar，存储变长的字符串。需要 1 或 2 个额外的字节记录字符串的长度。Char，定长，适合存储固定长度的字符串，如 MD5 值。</li><li>Blob，Text为了存储很大的数据而设计的。分别采用二进制和字符的方式。</li><li>时间类型DateTime，保存大范围的值，占 8 个字节。TimeStamp，推荐，与 UNIX 时间戳相同，占 4 个字节。<h6 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h6></li><li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<code>select id from t where num is null</code>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<code>select id from t where num=0</code></li><li>用EXISTS替代IN、用NOT EXISTS替代NOT IN</li><li>用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤。</li><li>尽量避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</li><li>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。</li><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引<h6 id="索引优化-选择索引的数据类型"><a href="#索引优化-选择索引的数据类型" class="headerlink" title="索引优化(选择索引的数据类型)"></a>索引优化(选择索引的数据类型)</h6>MySQL支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。</li><li>越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和cpu缓存中都需要更少的空间，处理起来更快。</li><li>简单的数据类型更好：整形数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应用内置的日期和时间数据类型，而不是字符串来存储时间；以及用整形数据存储IP地址。</li><li>尽量避免NULL：应该制定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为他们使得索引、索引的统计信息以及比较运算更加复杂。</li><li>为了更多的提高mysql效率可建立组合索引，遵循“最左前缀”原则。创建复合索引应该将最常用（频率）做限制条件的列放在最左边，一次递减。组合索引最左字段用in是可以用到索引的。相当于建立了col1,col1col2,col1col2col3三个索引。<h6 id="分库分表优化"><a href="#分库分表优化" class="headerlink" title="分库分表优化"></a>分库分表优化</h6></li><li><p>垂直拆分：解决问题：表与表之间的io竞争 不解决问题：单表中数据量增长出现的压力</p><blockquote><p>方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上。</p></blockquote></li><li><p>水平拆分： 解决问题：单表中数据量增长出现的压力 不解决问题：表与表之间的io争夺</p><blockquote><p>用户表通过性别拆分为男用户表和女用户表 订单表通过已完成和完成中拆分为已完成订单和未完成订单 产品表 未完成订单放一个server上 已完成订单表盒男用户表放一个server上 女用户表放一个server上(女的爱购物 哈哈)，<br><strong>==可以把学校范围内的用户单独独立出来一张表==。</strong></p></blockquote></li></ul><p>MySQL不需要执行后面的复杂操作，就可以直接返回结果，效率很高，==但是查询缓存失效非常频繁，只要有对一个表的更新，这个表的所有查询缓存都会被清空，因此可能你费力地把结果缓存起来，还没使用，就被一个更新全部清空了。除非你的业务是一张静态表，很长时间才会更新一次，这种情况下可以使用查询缓存==。(==把管理员信息放进去==)</p><h2 id="7-三范式"><a href="#7-三范式" class="headerlink" title="7.三范式"></a>7.三范式</h2><h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>==如果一个关系模式的所有属性的域都是原子的是指数据库表的每一列都是不可分割的基本数据项==，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。（2NF）==要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性==，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p><h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><ul><li>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。（我的理解是消除冗余）</li><li>优点:可以尽量得减少数据冗余，使得更新快，体积小</li><li>缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化</li></ul>]]></content>
    
    <summary type="html">
    
      U can find everything  be need in here.
    
    </summary>
    
    
      <category term="MySQL, DataBase" scheme="http://yoursite.com/tags/MySQL-DataBase/"/>
    
  </entry>
  
  <entry>
    <title>SortAlgorithms</title>
    <link href="http://yoursite.com/2020/01/13/SortAlgorithm/"/>
    <id>http://yoursite.com/2020/01/13/SortAlgorithm/</id>
    <published>2020-01-13T14:19:13.000Z</published>
    <updated>2020-02-17T10:23:38.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SortAlgorithms"><a href="#SortAlgorithms" class="headerlink" title="SortAlgorithms"></a>SortAlgorithms</h1><blockquote><p>原文链接： <a href="https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener"><strong>八大排序算法总结与java实现</strong> - iTimeTraveler</a></p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/big-o.png" alt></p><ul><li><a href="#一直接插入排序insertion-sort">直接插入排序</a></li><li><a href="#二希尔排序shell-sort">希尔排序</a></li><li><a href="#三选择排序selection-sort">简单选择排序</a></li><li><a href="#四堆排序heap-sort">堆排序</a></li><li><a href="#五冒泡排序bubble-sort">冒泡排序</a></li><li><a href="#六快速排序quick-sort">快速排序</a></li><li><a href="#七归并排序merging-sort">归并排序</a></li><li><a href="#八基数排序radix-sort">基数排序</a></li></ul><a id="more"></a><p>其中我们讨论的这八大排序算法的实现可以参考<a href="https://github.com/iTimeTraveler/SortAlgorithms" target="_blank" rel="noopener">我的Github：<strong>SortAlgorithms</strong></a>，其中包括了排序测试模块<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Test.java" target="_blank" rel="noopener">[Test.java]</a>和排序算法对比模块<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Bench.java" target="_blank" rel="noopener">[Bench.java]</a>，大家可以试运行。</p><p>它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/1156494-ab4cecff133d87b3.png" alt></p><h3 id="一、直接插入排序（Insertion-Sort）"><a href="#一、直接插入排序（Insertion-Sort）" class="headerlink" title="一、直接插入排序（Insertion Sort）"></a>一、直接插入排序（Insertion Sort）</h3><hr><p>插入排序的设计初衷是<strong>往有序的数组中快速插入一个新的元素</strong>。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.</p><p>插入排序由于操作不尽相同, 可分为 <code>直接插入排序</code> , <code>折半插入排序</code>(又称二分插入排序), <code>链表插入排序</code> , <code>希尔排序</code> 。我们先来看下直接插入排序。</p><h4 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/Insertion-sort-example-300px.gif" alt="使用插入排序为一列数字进行排序的过程"></p><h4 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><p>①. 从第一个元素开始，该元素可以认为已经被排序<br><br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br><br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br><br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br><br>⑤. 将新元素插入到该位置后<br><br>⑥. 重复步骤②~⑤<br></p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/insert-sort.gif" alt="直接插入排序演示"></p><p>算法实现中比较有意思的一点是，在每次比较操作发现取出来的新元素小于等于已排序的元素时，可以将已排序的元素移到下一位置，然后将取出来的新元素插入该位置（即相邻位置对调），接着再与前面的已排序的元素进行比较，如上图所示，这样做缺点是交换操作代价比较大。另一种做法是：将新元素取出（挖坑），从左到右依次与已排序的元素比较，如果已排序的元素大于取出的新元素，那么将该元素移动到下一个位置（填坑），接着再与前面的已排序的元素比较，直到找到已排序的元素小于等于新元素的位置，这时再将新元素插入进去。就像基本思想中的动图演示的那样。</p><p>如果<em>比较操作</em>的代价比<em>交换操作</em>大的话，可以采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95" target="_blank" rel="noopener">二分查找法</a>来减少<em>比较操作</em>的数目。可以认为是<strong>插入排序</strong>的一个变种，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">二分查找插入排序</a>。</p><h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 从第一个元素开始，该元素可以认为已经被排序</span></span><br><span class="line"><span class="comment"> * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class="line"><span class="comment"> * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置</span></span><br><span class="line"><span class="comment"> * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span></span><br><span class="line"><span class="comment"> * 5. 将新元素插入到该位置后</span></span><br><span class="line"><span class="comment"> * 6. 重复步骤2~5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];    <span class="comment">// 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j-- ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( j &gt; <span class="number">0</span> &amp;&amp; arr[j-<span class="number">1</span>] &gt; temp ) &#123;</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];    <span class="comment">// 如果该元素（已排序）大于取出的元素temp，将该元素移到下一位置</span></span><br><span class="line">                System.out.println(<span class="string">"Temping:  "</span> + Arrays.toString(arr));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将新元素插入到该位置后</span></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换次数较多的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span>; j-- ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( arr[j-<span class="number">1</span>] &lt;= arr[j] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];      <span class="comment">//交换操作</span></span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">            System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入排序复杂度如下：</p><ul><li>最好情况下，排序前对象已经按照要求的有序。比较次数(KCN)：n−1；移动次数(RMN)为0。则对应的时间复杂度为O(n)。</li><li>最坏情况下，排序前对象为要求的顺序的反序。第i趟时第i个对象必须与前面i个对象都做排序码比较，并且每做1次比较就要做1次数据移动（从上面给出的代码中看出）。比较次数(KCN)：n²/2 ; 移动次数(RMN)为：n²/2。则对应的时间复杂度为O(n²)。</li><li>如果排序记录是随机的，那么根据概率相同的原则，在平均情况下的排序码比较次数和对象移动次数约为n²/2，因此，<strong>直接插入排序的平均时间复杂度</strong>为O(n²)。</li></ul><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>Tips: 由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。</p><h3 id="二、希尔排序（Shell-Sort）"><a href="#二、希尔排序（Shell-Sort）" class="headerlink" title="二、希尔排序（Shell Sort）"></a>二、希尔排序（Shell Sort）</h3><hr><blockquote><p>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p></blockquote><p>希尔排序，也称<strong>递减增量排序算法</strong>，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。</p><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h4 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/shell-sort.jpg" alt></p><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p><p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97" target="_blank" rel="noopener">维基百科</a>。</p><h4 id="2、算法描述-1"><a href="#2、算法描述-1" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（<strong>一般初次取数组半长，之后每次再减半，直到增量为1</strong>）<br><br>②. 按增量序列个数k，对序列进行k 趟排序；<br><br>③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br></p><h4 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>以下是我自己的实现，可以看到实现很幼稚，但是好处是理解起来很简单。因为没有经过任何的优化，所以不建议大家直接使用。建议对比下方的维基百科官方实现代码，特别是步长取值策略部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1）</span></span><br><span class="line"><span class="comment"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span></span><br><span class="line"><span class="comment"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span></span><br><span class="line"><span class="comment"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;      <span class="comment">//不断缩小gap，直到1为止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; (j+gap) &lt; arr.length; j++)&#123;     <span class="comment">//使用当前gap进行组内插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; (k+gap)&lt; arr.length; k += gap)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[k] &gt; arr[k+gap]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[k+gap];      <span class="comment">//交换操作</span></span><br><span class="line">                    arr[k+gap] = arr[k];</span><br><span class="line">                    arr[k] = temp;</span><br><span class="line">                    System.out.println(<span class="string">"    Sorting:  "</span> + Arrays.toString(arr));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是维基百科官方实现，大家注意gap步长取值部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序（Wiki官方版）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（注意此算法的gap取值）</span></span><br><span class="line"><span class="comment"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span></span><br><span class="line"><span class="comment"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span></span><br><span class="line"><span class="comment"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">1</span>, i, j, len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>)</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;      <span class="comment">// &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span></span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是希尔排序复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog2 n)</td><td>O(nlog2 n)</td><td>O(nlog2 n)</td><td>O(1)</td></tr></tbody></table><h3 id="三、选择排序（Selection-Sort）"><a href="#三、选择排序（Selection-Sort）" class="headerlink" title="三、选择排序（Selection Sort）"></a>三、选择排序（Selection Sort）</h3><hr><blockquote><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/Selection-Sort-Animation.gif" alt="选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。"></p></blockquote><p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p><h4 id="1、基本思想-2"><a href="#1、基本思想-2" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>选择排序的基本思想：比较 + 交换。</p><p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h4 id="2、算法描述-2"><a href="#2、算法描述-2" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 从待排序序列中，找到关键字最小的元素；<br><br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br><br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。<br></p><h4 id="3、代码实现-2"><a href="#3、代码实现-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 从待排序序列中，找到关键字最小的元素；</span></span><br><span class="line"><span class="comment"> * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</span></span><br><span class="line"><span class="comment"> * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</span></span><br><span class="line"><span class="comment"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++)&#123;    <span class="comment">//选出之后待排序中值最小的位置</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[min];      <span class="comment">//交换操作</span></span><br><span class="line">            arr[min] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是选择排序复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><h3 id="四、堆排序（Heap-Sort）"><a href="#四、堆排序（Heap-Sort）" class="headerlink" title="四、堆排序（Heap Sort）"></a>四、堆排序（Heap Sort）</h3><hr><blockquote><p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p></blockquote><p>堆的定义如下：n个元素的序列{k1,k2,···,kn}，当且仅当满足下关系时，称之为堆。</p><p>ki &lt;= k(2i)  且   ki &lt;= k(2i+1) <br></p><p>或：   ki &gt;= k(2i)  且  ki &gt;=  k(2i+1) <br></p><p>把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：<strong>完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。</strong>由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p><h4 id="1、基本思想-3"><a href="#1、基本思想-3" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p><h4 id="2、算法描述-3"><a href="#2、算法描述-3" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.<br><br>②. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n-1]和有序区K[n], 且满足K[1..n-1].keys &lt;= K[n].key <br><br>③. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n-1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止. <br></p><p>动图效果如下所示：</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/heap_sort_gif.gif" alt="堆排序过程"></p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_heapsort_anim.gif" alt="堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。"></p><h4 id="3、代码实现-3"><a href="#3、代码实现-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p><p>总结起来就是定义了以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>对于堆节点的访问：</p><ul><li>父节点i的左子节点在位置：<code>(2*i+1)</code>;</li><li>父节点i的右子节点在位置：<code>(2*i+2)</code>;</li><li>子节点i的父节点在位置：<code>floor((i-1)/2)</code>;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.</span></span><br><span class="line"><span class="comment"> * 2. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n−1]和有序区K[n], 且满足K[1..n−1].keys⩽K[n].key</span></span><br><span class="line"><span class="comment"> * 3. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        max_heapify(arr, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = arr[<span class="number">0</span>];      <span class="comment">//堆顶元素(第一个元素)与Kn交换</span></span><br><span class="line">        arr[<span class="number">0</span>] = arr[i-<span class="number">1</span>];</span><br><span class="line">        arr[i-<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span> || arr.length &lt; limit) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIdx = limit / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; parentIdx &gt;= <span class="number">0</span>; parentIdx--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parentIdx * <span class="number">2</span> &gt;= limit)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = parentIdx * <span class="number">2</span>;       <span class="comment">//左子节点位置</span></span><br><span class="line">        <span class="keyword">int</span> right = (left + <span class="number">1</span>) &gt;= limit ? left : (left + <span class="number">1</span>);    <span class="comment">//右子节点位置，如果没有右节点，默认为左节点位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxChildId = arr[left] &gt;= arr[right] ? left : right;</span><br><span class="line">        <span class="keyword">if</span>(arr[maxChildId] &gt; arr[parentIdx])&#123;   <span class="comment">//交换父节点与左右子节点中的最大值</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[parentIdx];</span><br><span class="line">            arr[parentIdx] = arr[maxChildId];</span><br><span class="line">            arr[maxChildId] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Max_Heapify: "</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注:</strong> x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 == Math.floor(x/2) .</p></blockquote><p>以上,<br>①. 建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);<br>②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);<br>③. 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn).</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td></tr></tbody></table><p>Tips: <strong>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列.</strong> 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p><h3 id="五、冒泡排序（Bubble-Sort）"><a href="#五、冒泡排序（Bubble-Sort）" class="headerlink" title="五、冒泡排序（Bubble Sort）"></a>五、冒泡排序（Bubble Sort）</h3><hr><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort02.gif" alt="冒泡排序的思想"></p><blockquote><p>我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。</p></blockquote><h4 id="1、基本思想-4"><a href="#1、基本思想-4" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort.gif" alt="冒泡排序演示"></p><h4 id="2、算法描述-4"><a href="#2、算法描述-4" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>冒泡排序算法的运作如下：</p><p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br><br>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br><br>③. 针对所有的元素重复以上的步骤，除了最后一个。<br><br>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。<br></p><h4 id="3、代码实现-4"><a href="#3、代码实现-4" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>冒泡排序需要两个嵌套的循环. 其中, <strong>外层循环</strong>移动游标; <strong>内层循环</strong>遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span></span><br><span class="line"><span class="comment"> * ②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span></span><br><span class="line"><span class="comment"> * ③. 针对所有的元素重复以上的步骤，除了最后一个。</span></span><br><span class="line"><span class="comment"> * ④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;      <span class="comment">//外层循环移动游标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;    <span class="comment">//内层循环遍历游标及之后(或之前)的元素</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是冒泡排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p><p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p><h3 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a>六、快速排序（Quick Sort）</h3><hr><p>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。</p><h4 id="1、基本思想-5"><a href="#1、基本思想-5" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p><p>首先选一个轴值(pivot，也有叫基准的)，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_quicksort_anim.gif" alt="使用快速排序法对一列数字进行排序的过程"></p><h4 id="2、算法描述-5"><a href="#2、算法描述-5" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p><p>①. 从数列中挑出一个元素，称为”基准”（pivot）。<br><br>②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br><br>③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br></p><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/quick-sort09.gif" alt="快速排序演示"></p><h4 id="3、代码实现-5"><a href="#3、代码实现-5" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>用伪代码描述如下：</p><p>①. <code>i = L; j = R;</code> 将基准数挖出形成第一个坑<code>a[i]</code>。<br><br>②．<code>j--</code>，由后向前找比它小的数，找到后挖出此数填前一个坑<code>a[i]</code>中。<br><br>③．<code>i++</code>，由前向后找比它大的数，找到后也挖出此数填到前一个坑<code>a[j]</code>中。<br><br>④．再重复执行②，③二步，直到<code>i==j</code>，将基准数填入<code>a[i]</code>中 <br></p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/200px-Partition_example.svg.png" alt="快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序（递归）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ①. 从数列中挑出一个元素，称为"基准"（pivot）。</span></span><br><span class="line"><span class="comment"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span></span><br><span class="line"><span class="comment"> * ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> low   左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> high  右边界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> left = low;</span><br><span class="line">    <span class="keyword">int</span> right = high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = arr[left];   <span class="comment">//挖坑1：保存基准的值</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  <span class="comment">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   <span class="comment">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = temp;   <span class="comment">//基准值填补到坑3中，准备分治递归快排</span></span><br><span class="line">    System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</span><br><span class="line">    quickSort(arr, low, left-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, left+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是递归版的快速排序：通过把基准temp插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？</p><p>因为<strong>递归的本质是栈</strong>，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序（非递归）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ①. 从数列中挑出一个元素，称为"基准"（pivot）。</span></span><br><span class="line"><span class="comment"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span></span><br><span class="line"><span class="comment"> * ③. 把分区之后两个区间的边界（low和high）压入栈保存，并循环①、②步骤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortByStack</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态的左右指针入栈</span></span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    stack.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> high = stack.pop();     <span class="comment">//出栈进行划分</span></span><br><span class="line">        <span class="keyword">int</span> low = stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivotIdx = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存中间变量</span></span><br><span class="line">        <span class="keyword">if</span>(pivotIdx &gt; low) &#123;</span><br><span class="line">            stack.push(low);</span><br><span class="line">            stack.push(pivotIdx - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pivotIdx &lt; high &amp;&amp; pivotIdx &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            stack.push(pivotIdx + <span class="number">1</span>);</span><br><span class="line">            stack.push(high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = low;</span><br><span class="line">    <span class="keyword">int</span> r = high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[l];    <span class="comment">//挖坑1：保存基准的值</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[r] &gt;= pivot)&#123;  <span class="comment">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt;= pivot)&#123;   <span class="comment">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[r] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = pivot;   <span class="comment">//基准值填补到坑3中，准备分治递归快排</span></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p><p>以下是快速排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(1)（原地分区递归版）</td></tr></tbody></table><p>快速排序排序效率非常高。 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常平均来看, 它的时间复杂为O(nlogn), 比同样为O(nlogn)时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高.</p><p>Tips: 同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定.</p><h3 id="七、归并排序（Merging-Sort）"><a href="#七、归并排序（Merging-Sort）" class="headerlink" title="七、归并排序（Merging Sort）"></a>七、归并排序（Merging Sort）</h3><hr><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort_sample.jpg" alt></p><p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><h4 id="1、基本思想-6"><a href="#1、基本思想-6" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/2016-07-15_归并排序.gif" alt="这个图很有概括性，来自维基"></p><h4 id="2、算法描述-6"><a href="#2、算法描述-6" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p><strong>归并排序可通过两种方式实现：</strong></p><ul><li>自上而下的递归</li><li>自下而上的迭代</li></ul><p><strong>一、递归法</strong>（假设序列共有n个元素）：</p><p>①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；<br><br>②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；<br><br>③. 重复步骤②，直到所有元素排序完毕。<br></p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort.gif" alt></p><p><strong>二、迭代法</strong></p><p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 <br><br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置 <br><br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 <br><br>④. 重复步骤③直到某一指针到达序列尾 <br><br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾 <br></p><h4 id="3、代码实现-6"><a href="#3、代码实现-6" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>归并排序其实要做两件事：</p><ul><li>分解：将序列每次折半拆分</li><li>合并：将划分后的序列段两两排序合并</li></ul><p>因此，归并排序实际上就是两个操作，拆分+合并</p><p><strong>如何合并？</strong></p><p>L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。</p><p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]<br><br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]<br><br>此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序<br></p><p><strong>如何分解？</strong></p><p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p><p>这里我写了递归算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序（递归）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</span></span><br><span class="line"><span class="comment"> * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</span></span><br><span class="line"><span class="comment"> * ③. 重复步骤②，直到所有元素排序完毕。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergingSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = arr.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] leftArr = Arrays.copyOfRange(arr, <span class="number">0</span>, num);</span><br><span class="line">    <span class="keyword">int</span>[] rightArr = Arrays.copyOfRange(arr, num, arr.length);</span><br><span class="line">    System.out.println(<span class="string">"split two array: "</span> + Arrays.toString(leftArr) + <span class="string">" And "</span> + Arrays.toString(rightArr));</span><br><span class="line">    <span class="keyword">return</span> mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      <span class="comment">//不断拆分为最小单元，再排序合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeTwoArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length + arr2.length];  <span class="comment">//申请额外的空间存储合并之后的数组</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;      <span class="comment">//选取两个序列中的较小值放入新数组</span></span><br><span class="line">        <span class="keyword">if</span>(arr1[i] &lt;= arr2[j])&#123;</span><br><span class="line">            result[k++] = arr1[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.length)&#123;     <span class="comment">//序列1中多余的元素移入新数组</span></span><br><span class="line">        result[k++] = arr1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; arr2.length)&#123;     <span class="comment">//序列2中多余的元素移入新数组</span></span><br><span class="line">        result[k++] = arr2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Merging: "</span> + Arrays.toString(result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上, 长度为n的数组, 最终会调用mergeSort函数2n-1次。<strong>通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</strong></p><p>以下是归并排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n)</td></tr></tbody></table><p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p><blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(n log n）</code>的时间复杂度。代价是需要额外的内存空间。</p></blockquote><h3 id="八、基数排序（Radix-Sort）"><a href="#八、基数排序（Radix-Sort）" class="headerlink" title="八、基数排序（Radix Sort）"></a>八、基数排序（Radix Sort）</h3><hr><p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。</p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h4 id="1、基本思想-7"><a href="#1、基本思想-7" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>基数排序按照优先从高位或低位来排序有两种实现方案：</p><ul><li><p><strong>MSD（Most significant digital） 从最左侧高位开始进行排序</strong>。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<em>MSD方式适用于位数多的序列</em>。</p></li><li><p><strong>LSD （Least significant digital）从最右侧低位开始进行排序</strong>。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<em>LSD方式适用于位数少的序列</em>。</p></li></ul><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/radix-sort_sample.gif" alt="基数排序LSD动图演示"></p><h4 id="2、算法描述-7"><a href="#2、算法描述-7" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>我们以LSD为例，从最低位开始，具体算法描述如下：</p><p>①. 取得数组中的最大数，并取得位数；<br><br>②. arr为原始数组，从最低位开始取每个位组成radix数组；<br><br>③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；<br></p><h4 id="3、代码实现-7"><a href="#3、代码实现-7" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p><ul><li><p><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p></li><li><p><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序（LSD 从低位开始）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 基数排序适用于：</span></span><br><span class="line"><span class="comment"> *  (1)数据范围较小，建议在小于1000</span></span><br><span class="line"><span class="comment"> *  (2)每个数值都要大于等于0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ①. 取得数组中的最大数，并取得位数；</span></span><br><span class="line"><span class="comment"> * ②. arr为原始数组，从最低位开始取每个位组成radix数组；</span></span><br><span class="line"><span class="comment"> * ③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取得数组中的最大数，并取得位数</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; arr[i])&#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(max / <span class="number">10</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        maxDigit++;</span><br><span class="line">        max = max / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"maxDigit: "</span> + maxDigit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请一个桶空间</span></span><br><span class="line">    <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从低位到高位，对每一位遍历，将所有元素分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];        <span class="comment">//存储各个桶中存储元素的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配：将所有元素分配到桶中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> whichBucket = (arr[j] % base) / (base / <span class="number">10</span>);</span><br><span class="line">            buckets[whichBucket][bktLen[whichBucket]] = arr[j];</span><br><span class="line">            bktLen[whichBucket]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; buckets.length; b++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; bktLen[b]; p++)&#123;</span><br><span class="line">                arr[k++] = buckets[b][p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是基数排序算法复杂度，其中k为最大数的位数：</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(n+r)</td></tr></tbody></table><p>其中，<strong>d 为位数，r 为基数，n 为原数组个数</strong>。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 <code>O(d*(n + r))</code>。</p><p>基数排序更适合用于对时间, 字符串等这些<strong>整体权值未知的数据</strong>进行排序。</p><p>Tips: 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ol><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>各种排序性能对比如下图，有些排序未详细介绍，暂且放到这里。<br>实例测试结果可以看这里：<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/BENCH_RESULT.md" target="_blank" rel="noopener"><strong>八大排序算法耗时对比</strong></a> 。</p><table><thead><tr><th>排序类型</th><th>平均情况</th><th>最好情况</th><th>最坏情况</th><th>辅助空间</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.3)</td><td>O(nlogn)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(nlog₂n)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n²)</td><td>O(n+k)</td><td>(不)稳定</td></tr><tr><td>基数排序</td><td>O(d(n+k))</td><td>O(d(n+k))</td><td>O(d(n+kd))</td><td>O(n+kd)</td><td>稳定</td></tr></tbody></table><p>从时间复杂度来说：</p><p>(1). 平方阶O(n²)排序：<strong><code>各类简单排序：直接插入、直接选择和冒泡排序</code></strong>；</p><p>(2). 线性对数阶O(nlog₂n)排序：<strong><code>快速排序、堆排序和归并排序</code></strong>；</p><p>(3). O(n1+§))排序，§是介于0和1之间的常数：<strong><code>希尔排序</code></strong></p><p>(4). 线性阶O(n)排序：<strong><code>基数排序，此外还有桶、箱排序</code></strong>。</p><p>到此，很多人会注意到<strong>基数排序</strong>的时间复杂度是最小的，那么为什么却没有快排、堆排序流行呢？我们看看下图算法导论的相关说明：</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/radixsort-comparison.jpg" alt></p><p>基数排序只适用于有基数的情况，而基于比较的排序适用范围就广得多。另一方面是内存上的考虑。作为一种通用的排序方法，最好不要带来意料之外的内存开销，所以各语言的默认实现都没有用基数排序，但是不能否认基数排序在各领域的应用。</p><h4 id="时间复杂度极限"><a href="#时间复杂度极限" class="headerlink" title="时间复杂度极限"></a>时间复杂度极限</h4><p><strong>当被排序的数有一些性质的时候</strong>（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于O(nlgn)的。比如：</p><ol><li>计数排序 复杂度O( k+n)     要求：被排序的数是0~k范围内的整数</li><li>基数排序 复杂度O( d(k+n) )  要求：d位数，每个数位有k个取值</li><li>桶排序    复杂度 O( n ) （平均） 要求：被排序数在某个范围内，并且服从均匀分布</li></ol><p>但是，当被排序的数不具有任何性质的时候，一般使用基于比较的排序算法，而<strong>基于比较的排序算法时间复杂度的下限必须是O(nlgn)</strong>。 参考<a href="https://www.zhihu.com/question/24516934" target="_blank" rel="noopener">很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？</a></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li><li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</li><li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li></ul><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/2016-07-15_常用排序算法.png" alt></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>数据结构可视化：<a href="https://visualgo.net/zh" target="_blank" rel="noopener">visualgo</a>，<a href="https://www.toptal.com/developers/sorting-algorithms/" target="_blank" rel="noopener">Sorting Algorithms Animations</a>，<a href="https://codepen.io/iTimeTraveler/pen/dRrwZr" target="_blank" rel="noopener">CodePen</a> &amp; <a href="https://codepen.io/iTimeTraveler/pen/weORyW" target="_blank" rel="noopener">sort it out</a></li><li><a href="https://coolshell.cn/articles/536.html" target="_blank" rel="noopener">一个显示排序过程的PYTHON脚本</a></li><li>排序算法测试：<a href="http://www.cse.chalmers.se/edu/course/DIT960/lab1-sorting.html" target="_blank" rel="noopener">Lab 1: Sorting - 哥德堡大学课件（University of Gothenburg）</a></li><li><a href="http://www.sorting-algorithms.com/" target="_blank" rel="noopener">Sorting Algorithm Animations - 一个排序算法比较的网站</a></li><li><a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html" target="_blank" rel="noopener">Sorting - 卡内基梅隆大学课件</a></li><li><a href="http://www.jianshu.com/p/7d037c332a9d" target="_blank" rel="noopener">数据结构常见的八大排序算法（详细整理）</a></li><li><a href="http://www.jianshu.com/p/8c915179fd02" target="_blank" rel="noopener">必须知道的八大种排序算法【java实现】</a></li><li><a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">十大经典排序算法</a></li><li><a href="http://blog.jobbole.com/11745/" target="_blank" rel="noopener">视觉直观感受 7 种常用的排序算法</a></li><li><a href="http://louiszhai.github.io/2016/12/23/sort/" target="_blank" rel="noopener">JS中可能用得到的全部的排序算法</a></li><li><a href="http://www.cnblogs.com/minkaihui/p/4077888.html" target="_blank" rel="noopener">总结5种比较高效常用的排序算法</a></li><li><a href="http://www.cnblogs.com/zyb428/p/5673738.html" target="_blank" rel="noopener">常见排序算法C++总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      因为健忘，加上对各种排序算法理解不深刻，过段时间面对排序就蒙了。所以决定对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法
    
    </summary>
    
    
      <category term="Algorithms," scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>EveryThing About Operation System</title>
    <link href="http://yoursite.com/2019/12/27/EveryThing-About-Operation-System/"/>
    <id>http://yoursite.com/2019/12/27/EveryThing-About-Operation-System/</id>
    <published>2019-12-27T09:13:56.000Z</published>
    <updated>2020-02-27T09:17:33.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表。堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些堆可以被看成是一棵树，如：堆排序。</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>由操作系统（编译器）自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放。一种先进后出的数据结构</li></ul><h3 id="用户态，内核态以及如何切换。"><a href="#用户态，内核态以及如何切换。" class="headerlink" title="用户态，内核态以及如何切换。"></a>用户态，内核态以及如何切换。</h3><ul><li><p>内核态：运行操作系统程序，控制计算机的硬件资源，并提供上层应用程序运行的环境，运行在高特权级上。<strong>内核态切换到用户态的途径——&gt;设置程序状态字</strong>。</p></li><li><p>用户态：运行用户程序上层应用程序的活动空间，运行在低特权级别上。为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。<strong>用户态切换到内核态的唯一途径(申请外部资源)——&gt;中断/异常/系统调用</strong>(读写文件,申请堆内存,缺页(虚拟内存地址没有映射到物理内存地址,在Java中New一个对象))。系统调用 System， Callaccept:套接字的客户端连接套接字，bind套接字的服务端监听端口</p></li></ul><h2 id="信号和信号量的关系"><a href="#信号和信号量的关系" class="headerlink" title="信号和信号量的关系"></a>信号和信号量的关系</h2><ul><li>信号：（signal）是一种处理异步事件的方式。信号时比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。linux除了支持unix早期的信号语义函数，还支持语义符合posix.1标准的信号函数sigaction。</li><li>信号量：（Semaphore）进程间通信处理同步互斥的机制。是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。<h2 id="进程和线程，进程之间的通信方式等"><a href="#进程和线程，进程之间的通信方式等" class="headerlink" title="进程和线程，进程之间的通信方式等"></a>进程和线程，进程之间的通信方式等</h2>啥是进程，啥是线程，他们的本质区别？我们运行一个程序时，数据放在哪里？代码放在哪里？咋就还要分堆和栈？线程切换时是上下文是啥意思？</li></ul><p>虚拟地址是什么鬼东西？线程需要那么多种状态干啥子？什么是乐观锁、悲观锁？死锁是怎么造成的？解决死锁的策略有哪些？等等<br>2、进程、线程究竟是由什么组成的？有哪些数据？</p><p>3、内存管理，包括：虚拟内存（重点）、分页、分段、分页系统地址映射、内存置换算法（重点）。</p><p>安全系统不会死锁</p><h2 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h2><p>进程是具有一定独立功能的程序，它是系统进行资源分配和调度的一个独立单位，重点在系统调度和独立的单位，也就是说进程是可以独立运行的一段程序。</p><h2 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h2><p>线程是进程的一个实体，是CPU调度和分配的基本单位，它是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，在运行时，只是暂用一些计数器，寄存器，和栈。</p><h2 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h2><ul><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。</li><li>资源分配给进程，同一进程的所有线程共享该进程的所有资源。</li><li>线程在执行过程中，需要协作同步，不同进程的线程间要利用消息通信的方法实现同步。</li><li>处理机分配给线程，即真正在处理机上运行的是线程。</li><li>线程是指进程内的一个执行单元，也是进程内的可调度实体。</li><li>进程会释放资源，线程不会。<h2 id="从4个角度来分析进程与线程之间的区别"><a href="#从4个角度来分析进程与线程之间的区别" class="headerlink" title="从4个角度来分析进程与线程之间的区别"></a>从4个角度来分析进程与线程之间的区别</h2></li><li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li><li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行</li><li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源</li><li>系统开销：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销<h2 id="进程有几种状态"><a href="#进程有几种状态" class="headerlink" title="进程有几种状态"></a>进程有几种状态</h2></li><li>就绪状态：进程已经获得除处理机以外的所有资源，等待分配处理机资源</li><li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数目</li><li>阻塞状态：进程等待某种条件，在条件满足之前无法运行<h2 id="线程有几种状态"><a href="#线程有几种状态" class="headerlink" title="线程有几种状态"></a>线程有几种状态</h2></li><li>执行状态：表示线程已经获得处理机而正在运行</li><li>就绪状态：指线程已经具备了各种执行条件，只需再获得CPU便可以立即执行难</li><li>阻塞状态：线程在执行过程中因某事受阻而处于暂停状态<h2 id="操作系统进程调度有哪几种"><a href="#操作系统进程调度有哪几种" class="headerlink" title="操作系统进程调度有哪几种"></a>操作系统进程调度有哪几种</h2></li><li>非抢占式方式：采用这种调度方式时，一旦把处理机分配给某个进程后，就一直让它运行下去，决不会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机，直至该进程完成，或发生某种事件而被阻塞时，才把处理机分配给其他进程</li><li>抢占式方式：这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将已经分配给该进程的处理机重新分配给另一进程，在现代OS中广泛采用抢占方式。<br>进程为什么需要同步<br>进程同步机制的主要任务是对多个相关进程在执行次序上进行协调，使得并发执行的各个进程之间能按照一定的规则或时序共享系统资源，并能很好的相互合作，从而使得程序的执行具有可再现性</li></ul><h2 id="列举几种进程同步机制，并说明其优缺点"><a href="#列举几种进程同步机制，并说明其优缺点" class="headerlink" title="列举几种进程同步机制，并说明其优缺点"></a>列举几种进程同步机制，并说明其优缺点</h2><ul><li>硬件同步机制：</li><li>信号量机制：</li><li>管程机制：<h2 id="进程之间通信的途径"><a href="#进程之间通信的途径" class="headerlink" title="进程之间通信的途径"></a>进程之间通信的途径</h2><a href="https://mp.weixin.qq.com/s/5CbYGrylSKx1JwtOiW3aOQ" target="_blank" rel="noopener">进程之间通信方向</a></li><li>管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，进程的亲缘关系通常是指父子进程关系</li><li>有名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系的进程间的通信</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问，它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源，因此，主要作为进程间以及同一进程内不同线程之间的同步手段</li><li>消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</li><li>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程通信方式运行效率低而专门设计的，它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信</li><li>Socket(套接字)：套接字可以用于不同的进程间的通信<h2 id="线程之间通信的途径"><a href="#线程之间通信的途径" class="headerlink" title="线程之间通信的途径"></a>线程之间通信的途径</h2></li><li>锁机制：包括互斥锁，条件变量，读写锁 互斥锁提供了以排他方式防止数据结构被并发修改的方法 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止，对条件的测试是在互斥锁的保护下进行的，条件变量始终与互斥锁一起使用 读写锁允许多个线程同时读共享数据，而对写操作是互斥的</li><li>信号量机制：包括无名线程信号量和命名线程信号量</li><li>信号机制：类似进程间的信号处理 <strong>注意：线程间的通信的目的主要是用于线程的同步，所以线程没有像进程通信中的用于数据交换的通信机制</strong></li></ul><h2 id="多线程如何同步"><a href="#多线程如何同步" class="headerlink" title="多线程如何同步"></a>多线程如何同步</h2><blockquote><p>临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphore）、事件（Event）的区别</p></blockquote><h3 id="临界区："><a href="#临界区：" class="headerlink" title="临界区："></a>临界区：</h3><p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</p><h3 id="互斥量："><a href="#互斥量：" class="headerlink" title="互斥量："></a>互斥量：</h3><p>采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 .互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p><h3 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h3><p>它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 .信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</p><p>PV操作及信号量的概念都是由荷兰科学家E.W.Dijkstra提出的。信号量S是一个整数，S大于等于零时代表可供并发进程使用的资源实体数，但S小于零时则表示正在等待使用共享资源的进程数。</p><h6 id="P操作申请资源："><a href="#P操作申请资源：" class="headerlink" title="P操作申请资源："></a>P操作申请资源：</h6><ul><li>S减1；</li><li>若S减1后仍大于等于零，则进程继续执行；</li><li><p>若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转入进程调度。　　</p><h5 id="V操作释放资源："><a href="#V操作释放资源：" class="headerlink" title="V操作释放资源："></a>V操作释放资源：</h5></li><li><p>S加1；</p></li><li>若相加结果大于零，则进程继续执行；</li><li>若相加结果小于等于零，则从该信号的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转入进程调度。　　<h3 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h3>通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作 .</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</li><li>互斥量（Mutex），信号灯（Semaphore），事件（Event）都可以被跨越进程使用来进行同步数据操作，而其他的对象与数据同步操作无关，但对于进程和线程来讲，如果进程和线程在运行状态则为无信号状态，在退出后为有信号状态。所以可以使用WaitForSingleObject来等待进程和线程退出。</li><li>通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号灯对象可以说是一种资源计数器。　　</li></ul><h2 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h2><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的</p><h2 id="进程死锁的原因"><a href="#进程死锁的原因" class="headerlink" title="进程死锁的原因"></a>进程死锁的原因</h2><p>多个进程对资源的争夺，包括对不可抢占资源和对可消耗资源</p><h2 id="进程死锁的4个必要条件"><a href="#进程死锁的4个必要条件" class="headerlink" title="进程死锁的4个必要条件"></a>进程死锁的4个必要条件</h2><ul><li>互斥条件：进程对所分配到的资源进行排它性使用，即在一段时间内，其资源只能被一个进程占用，如果此时还有其它进程请求该资源，则请求进程只能等待，直至占有该资源的进程用完释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其它进程占有，此时请求进程被阻塞，但对自己已经获得的资源保持不放</li><li>不可抢占条件：进程已经获得的资源在未使用完之前不能被抢占，只能在进程使用完时由自己释放</li><li>循环等待条件：在发生死锁时，必然存在一个进程-资源循环链，即进程集合｛P0,P1,……,PN｝中的P0正在等待一个P1占用的资源，P1正在等待P2占用的资源，……，PN 正在等待P0占用的资源<h2 id="进程死锁的处理"><a href="#进程死锁的处理" class="headerlink" title="进程死锁的处理"></a>进程死锁的处理</h2></li><li>预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一种</li><li>避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态</li><li>检测死锁：通过检测机构及时检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来</li><li>解除死锁：当检测到系统中已经发生死锁时，采取相应的措施，将进程从死锁状态解脱出来，常用的方法是撤销一些进程，回收他们的资源，将它们分配给已经处于阻塞状态的进程，使其能够继续运行<h2 id="描述实时操作系统的基本特征"><a href="#描述实时操作系统的基本特征" class="headerlink" title="描述实时操作系统的基本特征"></a>描述实时操作系统的基本特征</h2>实时操作系统是指操作系统工作时，其各种资源可以根据需要随时进行动态分配，由于各种资源可以进行动态分配，因此，其处理事务的能力较强 换言之，在特定时间内完成特定的任务，具有实时性与可靠性</li></ul><h2 id="操作系统中断与轮询的基本特点"><a href="#操作系统中断与轮询的基本特点" class="headerlink" title="操作系统中断与轮询的基本特点"></a>操作系统中断与轮询的基本特点</h2><ul><li>轮询：对I/O设备的程序轮询的方式是早期的计算机系统对I/O设备的一种管理方式，它定时对各种设备轮流询问一遍有无处理要求。轮询占据了CPU相当一部分处理时间，因此，程序轮询是一种效率较低的方式，在现代计算机系统中已经很少应用</li><li><p>中断：中断是指CPU在正常运行程序的过程中，由于发生的内部或外部的特定的事件，使得CPU中断正在运行的程序，而转到响应的服务程序去处理</p><h2 id="什么是临界区，如何解决冲突"><a href="#什么是临界区，如何解决冲突" class="headerlink" title="什么是临界区，如何解决冲突"></a>什么是临界区，如何解决冲突</h2><p>每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入 解决冲突的方法：</p></li><li><p>如果有若干个进程要求进入空闲的临界区，一次仅允许一个进程进入</p></li><li>任何时候，处于临界区内的进程不可以多于一个，如果已经有进程进入自己的临界区，则其他所有试图进入临界区的进程必须等待</li><li>进入临界区内的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区</li><li>如果进程不能进入自己的临界区，则应该让出CPU，避免进程出现“忙碌”现象。<h2 id="windows下内存是如何管理的"><a href="#windows下内存是如何管理的" class="headerlink" title="windows下内存是如何管理的"></a>windows下内存是如何管理的</h2>windows操纵内存可以分为两个层面，物理内存和虚拟内存。</li></ul><h3 id="进程调度算法-长中短"><a href="#进程调度算法-长中短" class="headerlink" title="进程调度算法(长中短)"></a>进程调度算法(长中短)</h3><ul><li>时间片轮转调度算法（RR）：给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，时间片轮转调度不考虑进程等待时间和执行时间，属于抢占式调度。优点是兼顾长短作业；缺点是平均等待时间较长，上下文切换较费时。适用于分时系统。</li><li>先来先服务调度算法（FCFS）：根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间，会产生饥饿现象。属于非抢占式调度，优点是公平，实现简单；缺点是不利于短作业。</li><li>优先级调度算法（HPF）：在进程等待队列中选择优先级最高的来执行。</li><li>多级反馈队列调度算法：将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。</li><li>高响应比优先调度算法：根据“响应比=（进程执行时间+进程等待时间）/ 进程执行时间”这个公式得到的响应比来进行调度。高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足段任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。</li></ul><h3 id="进程调度算法-长中短-1"><a href="#进程调度算法-长中短-1" class="headerlink" title="进程调度算法(长中短)"></a>进程调度算法(长中短)</h3><ul><li><strong>长程调度，把作业后背队列调入内存</strong>，又称为作业调度或高级调度，这种调度将已进入系统并处于后备状态的作业按某种算法选择一个或一批，为其建立进程，并进入主机，当该作业执行完毕时，还负责回收系统资源，在批处理系统中，需要有作业调度的过程，以便将它们分批地装入内存，在分时系统和实时系统中，通常不需要长期调度。它的频率比较低，主要用来控制内存中进程的数量。</li><li><strong>中程调度，内外存阻塞进程来回切换</strong>，又称为交换调度。它的核心思想是能将进程从内存或从CPU竞争中移出，从而降低多道程序设计的程度，之后进程能被重新调入内存，并从中断处继续执行，这种交换的***作可以调整进程在内存中的存在数量和时机。其主要任务是按照给定的原则和策略，将处于外存交换区中的就绪状态或等待状态的进程调入内存，或把处于内存就绪状态或内存等待状态的进程交换到外存交换区。</li><li><strong>短程调度，把进程分配给CPU执行</strong>。又称为进程调度、低级调度或微观调度。这也是通常所说的调度，一般情况下使用最多的就是短期调度。它的主要任务是按照某种策略和算法将处理机分配给一个处于就绪状态的进程，分为抢占式和非抢占式。 可以从下图中清晰的看到这些调度之间的区别。</li></ul><h3 id="磁盘寻道算法"><a href="#磁盘寻道算法" class="headerlink" title="磁盘寻道算法"></a>磁盘寻道算法</h3><ul><li>先来先服务算法（FCFS）First Come First Service</li></ul><p>这是一种比较简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。此算法由于未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低设备服务的吞吐量，致使平均寻道时间可能较长，但各进程得到服务的响应时间的变化幅度较小。<strong>在单用户系统环境中，I/O队列的长度通常为1，因此，先来先服务FCFS算法是最经济实惠的磁盘调度算法</strong>.</p><p>先来先服务 （125）86.147.91.177.94.150.102.175.130</p><ul><li>最短寻道时间优先算法（SSTF） Shortest Seek Time First</li></ul><p>该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，该算法可以得到比较好的吞吐量，但却不能保证平均寻道时间最短。其缺点是对用户的服务请求的响应机会不是均等的，因而导致响应时间的变化幅度很大。在服务请求很多的情况下，对内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期。最短寻道时间优先（125）130.147.150.175.177.102.94.91.86</p><ul><li>扫描算法（SCAN）电梯调度</li></ul><p>扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。例如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁道之内，从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律颇似电梯的运行，故又称为电梯调度算法。此算法基本上克服了最短寻道时间优先算法的服务集中于中间磁道和响应时间变化比较大的缺点，而具有最短寻道时间优先算法的优点即吞吐量较大，平均响应时间较小，但由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道。电梯调度（125）102.94.91.86.130.147.150.175.177</p><ul><li>循环扫描算法（CSCAN）</li></ul><p>循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。循环扫描 （125）130.147.150.175.177.86.91.94.102</p><h3 id="學長筆記連結"><a href="#學長筆記連結" class="headerlink" title="學長筆記連結"></a>學長筆記連結</h3><ul><li><p><a href="https://kim85326.github.io/2018/01/09/CH6-%E8%A1%8C%E7%A8%8B%E6%8E%92%E7%8F%AD-(Process-Scheduling)/" target="_blank" rel="noopener">https://kim85326.github.io/2018/01/09/CH6-%E8%A1%8C%E7%A8%8B%E6%8E%92%E7%8F%AD-(Process-Scheduling)/</a><br>信號</p></li><li><p><a href="https://kim85326.github.io/2018/01/10/CH10-%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1-(File-System)/" target="_blank" rel="noopener">https://kim85326.github.io/2018/01/10/CH10-%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1-(File-System)/</a></p></li><li><p>檔案系統<br><a href="https://kim85326.github.io/2018/01/09/CH8-%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86-(Memory-Management-Strategies)/" target="_blank" rel="noopener">https://kim85326.github.io/2018/01/09/CH8-%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86-(Memory-Management-Strategies)/</a><br>記憶體管理</p></li><li><p><a href="https://kim85326.github.io/2018/01/09/CH9-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86-(Virtual-Memory-Management)/" target="_blank" rel="noopener">https://kim85326.github.io/2018/01/09/CH9-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86-(Virtual-Memory-Management)/</a><br>虛擬記憶裡 lru</p></li></ul>]]></content>
    
    <summary type="html">
    
      EveryThing About Operation System
    
    </summary>
    
    
      <category term="Operation System" scheme="http://yoursite.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>SDN_OpenFlow</title>
    <link href="http://yoursite.com/2019/11/06/SDN-OpenFlow/"/>
    <id>http://yoursite.com/2019/11/06/SDN-OpenFlow/</id>
    <published>2019-11-06T06:00:03.000Z</published>
    <updated>2020-02-17T10:24:20.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="107-SDN"><a href="#107-SDN" class="headerlink" title="107 SDN"></a>107 SDN</h1><h2 id="a10715005-任偉"><a href="#a10715005-任偉" class="headerlink" title="a10715005 任偉"></a>a10715005 任偉</h2><h3 id="Boot-onosproject"><a href="#Boot-onosproject" class="headerlink" title="Boot onosproject"></a>Boot onosproject</h3><p><img src="https://imgur.com/GBqQTM5.png" alt></p><h3 id="Configuration-Json-file-and-Create-Topo-using-command-line"><a href="#Configuration-Json-file-and-Create-Topo-using-command-line" class="headerlink" title="Configuration Json file and Create Topo using command line"></a>Configuration Json file and Create Topo using command line</h3><p><img src="https://imgur.com/ZBZABkv.png" alt></p><h1 id="已經解決"><a href="#已經解決" class="headerlink" title="已經解決"></a>已經解決</h1><h2 id="ONOS-GUI中的topology"><a href="#ONOS-GUI中的topology" class="headerlink" title="ONOS GUI中的topology"></a>ONOS GUI中的topology</h2><p><img src="https://imgur.com/meGhS42.png" alt></p><h2 id="Ping-成功的畫面"><a href="#Ping-成功的畫面" class="headerlink" title="Ping 成功的畫面"></a>Ping 成功的畫面</h2><p><img src="https://imgur.com/gvkVOIL.png" alt></p><h2 id="Switch-s3的forwarding-table"><a href="#Switch-s3的forwarding-table" class="headerlink" title="Switch s3的forwarding table"></a>Switch s3的forwarding table</h2><p><img src="https://imgur.com/VpZQL2l.png" alt></p><h1 id="還沒有解決"><a href="#還沒有解決" class="headerlink" title="還沒有解決"></a>還沒有解決</h1><p><del>h1 ping h2</del><br><del>產生有兩條路徑的topology</del></p><ul><li>讓ping packet走較長的路徑</li></ul><p>原来是<br><img src="https://imgur.com/fX9oXev.png" alt></p><p>现在想让他变成<br><img src="https://imgur.com/LJETsWO.png" alt></p><h2 id="Pre-requisites"><a href="#Pre-requisites" class="headerlink" title="Pre-requisites:"></a>Pre-requisites:</h2><p><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener"><code>VirtualBox</code></a></p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration:"></a>Configuration:</h3><p><a href="https://jingyan.baidu.com/article/e2284b2b61a2efe2e6118d39.html" target="_blank" rel="noopener">JDK Configuration in Ubuntu</a></p><p><a href="https://blog.csdn.net/u010558281/article/details/78419321" target="_blank" rel="noopener">Install ONOS on Ubuntu</a></p><h3 id="Using-Linux-command"><a href="#Using-Linux-command" class="headerlink" title="Using Linux command:"></a>Using Linux command:</h3><p>modification file in Linux <code>gedit</code></p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h4><ul><li><p><a href="https://wiki.onosproject.org/display/ONOS/Basic+ONOS+Tutorial" target="_blank" rel="noopener"><code>Basic ONOS Tutorial</code></a></p></li><li><p><a href="https://www.youtube.com/watch?v=l25Ukkmk6Sk" target="_blank" rel="noopener"><code>OpenFlow</code></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;107-SDN&quot;&gt;&lt;a href=&quot;#107-SDN&quot; class=&quot;headerlink&quot; title=&quot;107 SDN&quot;&gt;&lt;/a&gt;107 SDN&lt;/h1&gt;&lt;h2 id=&quot;a10715005-任偉&quot;&gt;&lt;a href=&quot;#a10715005-任偉&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="ONOS OpenFlow SDN" scheme="http://yoursite.com/tags/ONOS-OpenFlow-SDN/"/>
    
  </entry>
  
  <entry>
    <title>CV</title>
    <link href="http://yoursite.com/2019/11/05/CV/"/>
    <id>http://yoursite.com/2019/11/05/CV/</id>
    <published>2019-11-05T06:10:01.000Z</published>
    <updated>2019-11-05T06:55:17.236Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/@xiaosean5408/pix2pixhd%E7%B0%A1%E4%BB%8B-high-resolution-image-synthesis-and-semantic-manipulation-with-conditional-gans-2099bd492f5" target="_blank" rel="noopener">pix2pixHD簡介 — High-Resolution Image Synthesis and Semantic Manipulation with Conditional GANs</a></p><p><a href="https://www.bilibili.com/video/av5987715" target="_blank" rel="noopener">【熟肉】线性代数的本质 - 01 - 向量究竟是什么？</a></p><p><a href="https://wei2624.github.io/machine%20learning/Machine-Learning-Notes/" target="_blank" rel="noopener">Machine-Learning-Notes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://medium.com/@xiaosean5408/pix2pixhd%E7%B0%A1%E4%BB%8B-high-resolution-image-synthesis-and-semantic-manipulation-with-cond
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>108FALL</title>
    <link href="http://yoursite.com/2019/10/18/108FALL/"/>
    <id>http://yoursite.com/2019/10/18/108FALL/</id>
    <published>2019-10-18T06:29:50.000Z</published>
    <updated>2019-12-05T05:00:43.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CS5095701-Advanced-Database-Systems"><a href="#CS5095701-Advanced-Database-Systems" class="headerlink" title="CS5095701 Advanced Database Systems"></a>CS5095701 Advanced Database Systems</h1><ul><li><p><a href="http://faculty.csie.ntust.edu.tw/~ywu/cs5095701/index.html" target="_blank" rel="noopener">CourseInfo</a></p></li><li><p><a href="https://docs.google.com/presentation/d/1HP7sgi0ClYdZmHQpGbO5SYVTYlU4V5MpYIx4xEOi4Co/edit" target="_blank" rel="noopener">PrensentationSlides</a></p></li><li><p>11/15 Proposal presentation (all 14 groups)</p></li><li>11/22 Mid-term exam</li><li>11/29 paper presentation (4 groups)(sequence        1~4)</li></ul><h2 id="Project-proposal"><a href="#Project-proposal" class="headerlink" title="Project proposal:"></a>Project proposal:</h2><p>You are required to propose a database related research project in this course. You are encouraged to have a publication as a goal for your project. A list of project ideas is listed below.</p><h2 id="You-proposal-should-include-the-following-aspects"><a href="#You-proposal-should-include-the-following-aspects" class="headerlink" title="You proposal should include the following aspects:"></a>You proposal should include the following aspects:</h2><ul><li><p>importance of the proposed project</p></li><li><p>your algorithm and ideas</p></li><li><p>main contributions</p></li><li><p>the design of the software you propose to build</p></li><li><p>how you propose to evaluate your ideas</p></li><li><p>the design of the experiments</p></li><li><p>literature survey</p></li></ul><h3 id="You-will-present-to-the-class-about-your-proposal-5-minutes-and-write-a-proposal-report-2-4-pages-in-IEEE-format"><a href="#You-will-present-to-the-class-about-your-proposal-5-minutes-and-write-a-proposal-report-2-4-pages-in-IEEE-format" class="headerlink" title="You will present to the class about your proposal (~ 5 minutes) and write a proposal report (2~4 pages in IEEE format)."></a>You will present to the class about your proposal (~ 5 minutes) and write a proposal report (2~4 pages in IEEE format).</h3><h1 id="CS5014701-電腦與機器人視覺-Computer-and-Robot-Vision"><a href="#CS5014701-電腦與機器人視覺-Computer-and-Robot-Vision" class="headerlink" title="CS5014701 電腦與機器人視覺 Computer and Robot Vision"></a>CS5014701 電腦與機器人視覺 Computer and Robot Vision</h1><ul><li><p><a href="https://docs.google.com/presentation/d/1IGnx-zBDaD7oFmCo3vJa4of-yKDxCmiLzA4EswjaXX0/edit" target="_blank" rel="noopener">Everybody Dance NOW<br></a></p></li><li><p><a href="https://docs.google.com/presentation/d/1KySt5eAGNONS2xu5TM4nkeAA_78sE_DKQ-Eq6oCJjJE/edit#slide=id.p" target="_blank" rel="noopener">Joint Discriminative and Generative Learning for Person Re-identification</a></p></li></ul><h1 id="CS5146701-虛擬化網路及應用-Virtualized-Networks-and-Applications"><a href="#CS5146701-虛擬化網路及應用-Virtualized-Networks-and-Applications" class="headerlink" title="CS5146701 虛擬化網路及應用 Virtualized Networks and Applications"></a>CS5146701 虛擬化網路及應用 Virtualized Networks and Applications</h1><ul><li>Proposal</li></ul><h2 id="Catch-up-from-Flick"><a href="#Catch-up-from-Flick" class="headerlink" title="Catch up from Flick"></a>Catch up from Flick</h2><p><a href="https://www.youtube.com/watch?v=wLDK8ZCnuBc&t=2s" target="_blank" rel="noopener">network virtualization</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/WenaxhSv35c?start=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h1 id="CS5023701-Knowledge-Based-Systems"><a href="#CS5023701-Knowledge-Based-Systems" class="headerlink" title="CS5023701  Knowledge-Based Systems"></a>CS5023701  Knowledge-Based Systems</h1><p><a href="https://docs.google.com/presentation/d/1qY_z_h-IgD5GLm81VX1pLvkQcwI_KNSnJgOVYtuUyJY/edit#slide=id.p" target="_blank" rel="noopener">Revisit Fuzzy Neural Network: Demystifying Batch Normalization and ReLU with Generalized Hamming Network</a></p><h1 id="CS5141701-深度學習導論及其應用-Introduction-to-Deep-Learning-and-Its-Applications"><a href="#CS5141701-深度學習導論及其應用-Introduction-to-Deep-Learning-and-Its-Applications" class="headerlink" title="CS5141701 深度學習導論及其應用 Introduction to Deep Learning and Its Applications"></a>CS5141701 深度學習導論及其應用 Introduction to Deep Learning and Its Applications</h1><p><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLSD15_2.html" target="_blank" rel="noopener">Hung-yi Lee’S CourseInfo</a></p><p><a href="https://datawhalechina.github.io/leeml-notes/#/" target="_blank" rel="noopener">李宏毅机器学习笔记(LeeML-Notes)</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/videoseries?list=PLXVfgk9fNX2I7tB6oIINGBmW50rrmFTqf" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><iframe width="560" height="315" src="https://www.youtube.com/embed/videoseries?list=PLXVfgk9fNX2IQOYPmqjqWsNUFl2kpk1U2" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><iframe width="560" height="315" src="https://www.youtube.com/embed/CXgbekl66jc?start=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><iframe width="560" height="315" src="https://www.youtube.com/embed/JGZFYJFoxDA?start=3947" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h1 id="【財金學程】FBG006301-品牌價值創新講座-Seminar-on-Brand-Value-Innovation"><a href="#【財金學程】FBG006301-品牌價值創新講座-Seminar-on-Brand-Value-Innovation" class="headerlink" title="【財金學程】FBG006301 品牌價值創新講座 Seminar on Brand Value Innovation"></a>【財金學程】FBG006301 品牌價值創新講座 Seminar on Brand Value Innovation</h1><p><a href="https://docs.google.com/presentation/d/1EokcapXuKWdFcqMF8_RCJ9WLSpPHzAfqs9S3ddTh7A0/edit?usp=sharing" target="_blank" rel="noopener">柯達企業失敗個案分析</a></p><h1 id="TCG037301-親近經典智慧-Wisdom-in-Classics"><a href="#TCG037301-親近經典智慧-Wisdom-in-Classics" class="headerlink" title="TCG037301 親近經典智慧 Wisdom in Classics"></a>TCG037301 親近經典智慧 Wisdom in Classics</h1><p><a href="https://docs.google.com/presentation/d/1VrzqySkwp_2s_XxrMa3tAunXpURI08F3ZUdXqflCeE8/edit?usp=sharing" target="_blank" rel="noopener">畜牧業的陰謀</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CS5095701-Advanced-Database-Systems&quot;&gt;&lt;a href=&quot;#CS5095701-Advanced-Database-Systems&quot; class=&quot;headerlink&quot; title=&quot;CS5095701 Advanced Dat
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Recommend System</title>
    <link href="http://yoursite.com/2019/10/03/Recommend-System/"/>
    <id>http://yoursite.com/2019/10/03/Recommend-System/</id>
    <published>2019-10-03T09:50:23.000Z</published>
    <updated>2020-01-07T02:27:23.303Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://wepon.me/" target="_blank" rel="noopener">http://wepon.me/</a> pku<br><a href="https://coladrill.github.io/about/" target="_blank" rel="noopener">https://coladrill.github.io/about/</a> seu<br><a href="https://github.com/ColaDrill/2018spa" target="_blank" rel="noopener">https://github.com/ColaDrill/2018spa</a> 推荐系统</p><p><a href="https://www.zhihu.com/people/coladrill/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/coladrill/activities</a><br>推荐系统 必看</p><p><a href="https://zhuanlan.zhihu.com/p/82671707?utm_source=wechat_session&utm_medium=social&utm_oi=973611927536181248" target="_blank" rel="noopener">手写xgboost</a></p><h1 id="Special-Projects"><a href="#Special-Projects" class="headerlink" title="Special Projects"></a>Special Projects</h1><h2 id="Previous"><a href="#Previous" class="headerlink" title="Previous"></a>Previous</h2><p>The Uni require all the undergraduate student to reach out the Special Projects.</p><h2 id="Mission"><a href="#Mission" class="headerlink" title="Mission:"></a>Mission:</h2><p>Recommend systems based on the Collaborative Filtering</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><ul><li><p><a href="https://spinningup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Reinforcement Spinning Up</a></p></li><li><p><a href="https://d2l.ai/chapter_recommender-systems/index.html" target="_blank" rel="noopener">Introduction to Deep Learning STAT 157, UC Berkeley, Spring, 2019</a><br>Reference By <a href="https://zhuanlan.zhihu.com/p/66062438" target="_blank" rel="noopener">在伯克利教深度学习</a></p></li></ul><p><a href="https://www.bilibili.com/video/av63439164?from=search&seid=3600678311547036502" target="_blank" rel="noopener">Talk in Mandarin</a></p><ul><li><a href="https://zhuanlan.zhihu.com/p/27908027" target="_blank" rel="noopener">Intro CNN</a></li></ul><iframe width="560" height="315" src="https://www.youtube.com/embed/tH9FH1DH5n0?start=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><blockquote class="blockquote-center"><p>Elegant in code, simple in core</p></blockquote><h3 id="IEEE-International-Conference-on-Signal-Information-and-Data-Processing-2019"><a href="#IEEE-International-Conference-on-Signal-Information-and-Data-Processing-2019" class="headerlink" title="IEEE International Conference on Signal, Information and Data Processing 2019"></a>IEEE International Conference on Signal, Information and Data Processing 2019</h3><p><a href="https://www.scribd.com/document/431478280/Automatic-Digital-Recognition-of-Multiple-E-lect-rici-ty-Dash-boar-ds-pdf" target="_blank" rel="noopener">Automatic Digital Recognition of Multiple Electricity Dashboards, (accepted) [EI]</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://wepon.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://wepon.me/&lt;/a&gt; pku&lt;br&gt;&lt;a href=&quot;https://coladrill.github.io/about/&quot; target
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>108_FALL</title>
    <link href="http://yoursite.com/2019/09/28/Prepare4Interview/"/>
    <id>http://yoursite.com/2019/09/28/Prepare4Interview/</id>
    <published>2019-09-28T13:42:12.000Z</published>
    <updated>2019-09-28T14:39:01.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机网络和操作系统"><a href="#计算机网络和操作系统" class="headerlink" title="计算机网络和操作系统"></a>计算机网络和操作系统</h3><ul><li><p>一个浏览器发出请求：把所有流程连起来把想到的知识梳理一遍，http传输，json解析，tomcat收到请求， springmvc解析请求， 传给服务层， 请求数据库， 查询数据库， 数据库查找索引，数据库返回数据。</p></li><li><p>硬盘转速和文件系统读写速度的关系</p></li><li><p>加密为什么不用https</p></li></ul><h1 id="九章算法-《Java入门与基础算法班》"><a href="#九章算法-《Java入门与基础算法班》" class="headerlink" title="九章算法 《Java入门与基础算法班》"></a>九章算法 《Java入门与基础算法班》</h1><ul><li><p>Java语言基础：数组，字符串，函数，类，对象，引用</p></li><li><p>Java算法基础： 枚举法，贪心法，递归，链表，栈，树，递归，哈希表，排序</p></li></ul><h1 id="问题类型"><a href="#问题类型" class="headerlink" title="问题类型"></a>问题类型</h1><ul><li>操作系统：（找手机相册里面的图片）</li></ul><h2 id="素质测试数字推理和图形推理"><a href="#素质测试数字推理和图形推理" class="headerlink" title="素质测试数字推理和图形推理"></a>素质测试数字推理和图形推理</h2><p>字符串排重并排序</p><h2 id="专业测试"><a href="#专业测试" class="headerlink" title="专业测试"></a>专业测试</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="一级中药"><a href="#一级中药" class="headerlink" title="一级中药"></a>一级中药</h4><p>dijkstra<br>lru缓存机制 算法也可以考系统设计<br>链表排序<br>lru如何保证o1的查找和修改</p><p>天哥面试：（必会）</p><ul><li><p>1:写一个二叉树的层次遍历或者链表的取中心点+把链表中心点后的部分反转</p></li><li><p>2:快速排序和二分归并排序有什么不同，最坏和平均时间复杂度分半是多少</p></li><li><p>进程和线程的区别是什么，除了时间片轮转法外，你还知道什么进程调度算法</p></li><li><p>线程持有锁的变量时，线程被切换了（若只有cpu时间片到了的话，不会释放锁，不然也就不存在死锁问题了），锁会被释放吗？<br>不会，进程释放所有资源，线程不会，</p></li><li><p>Java实现b+树，链表和栈，霍夫曼。（Java集合的底层实现）hashmap</p></li><li><p>dp和写正则</p></li><li><p>逻辑回归和svm都可以用来作二分类，他们的lost function有什么不同</p></li><li><p>写一个dnn或者线性回归的反向传播算法的推导</p></li><li><p>svm中核函数起到的作用，</p></li><li><p>信息增益是怎么用于决策树中的特征选择</p></li><li><p>pca的原理是什么</p></li><li><p>cnn中的resnet中的res指什么</p></li><li><p>depthwise有什么好处</p></li><li><p>计算一下一个cnn卷积一次的计算量</p></li><li><p>为什么需要激活函数</p></li></ul><h4 id="二级中药"><a href="#二级中药" class="headerlink" title="二级中药"></a>二级中药</h4><p>红黑树，平衡树，b+树，跳跃表</p><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ul><li>基础数据类型</li><li>protected修饰符</li><li>抽象类和接口区别</li><li>Java内存结构（重要）</li><li>Java并发和线程同步。同步机制和锁解释一下</li><li>synchronized和lock区别</li><li>类，继承，多态的概念</li><li>设计爬虫，你需要设计什么</li><li>wait()和sleep(区别)</li><li>多线程的理解</li><li>hashtable和hashmap区别</li><li><p>synchronized如何保证原子性：<br>monitor ，继续深入：如何保证读取对象头和修改对象头的原子性<br>*</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3></li><li><p>设计模式：手画代理模式</p></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>事务一定会锁表吗</p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>找到一个痛点 难点：<br>（特色模块）：单点登录，全局搜索（搜关键字，快速找到）</p><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><ul><li>6个数找出里面最大的两个数</li><li>一个四则运算字符串写程序运算出结果</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机网络和操作系统&quot;&gt;&lt;a href=&quot;#计算机网络和操作系统&quot; class=&quot;headerlink&quot; title=&quot;计算机网络和操作系统&quot;&gt;&lt;/a&gt;计算机网络和操作系统&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个浏览器发出请求：把所有流程连起来把想到的知识梳理一遍，
      
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Computer Networks</title>
    <link href="http://yoursite.com/2019/08/28/Computer-Networkds/"/>
    <id>http://yoursite.com/2019/08/28/Computer-Networkds/</id>
    <published>2019-08-28T10:51:42.000Z</published>
    <updated>2020-02-20T19:14:05.139Z</updated>
    
    <content type="html"><![CDATA[<p>##<br><a href="https://www.cnblogs.com/inception6-lxc/p/9152691.html" target="_blank" rel="noopener">计算机网络常见面试题</a></p><p><a href="https://www.cnblogs.com/fundebug/p/what-happens-from-url-to-webpage.html" target="_blank" rel="noopener">经典面试题：从 URL 输入到页面展现到底发生什么之会话顺序？</a></p><h3 id="涉及到的协议"><a href="#涉及到的协议" class="headerlink" title="涉及到的协议"></a>涉及到的协议</h3><p>(1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务)</p><p>(2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输)</p><p>(3) 网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址)</p><p><a href="https://www.cnblogs.com/gopark/p/8430916.html" target="_blank" rel="noopener">从 URL 输入到页面展现到底发生什么之分布式DNS原理及解析顺序，浏览器如何通过域名去查询 URL 对应的 IP </a></p><blockquote><p>路由器是一种三层设备，主要使用ip地址进行网间路由查询与ip包的转发。而交换机是一种二层设备，使用MAC地址进行寻址，实现一个网络内的数据帧的转发。<br>A类网络为1到126<br>B类网络为129到191<br>C类网络为192到223<br>IPV4是一个32位的地址，用4个十进制数字表示。以C类地址192.168.24.1为例，其中前24位是网络地址，后8位是主机地址。如果两个IP地址在同一个子网内，则网络地址一定相同。</p></blockquote><blockquote><p>机器A的ip地址为 202.96.128.130，子网掩码为255.255.255.128，则IP地址的网络号为202.96.128，主机号为130</p></blockquote><p> 二层交换机工作于OSI模型的第二层数据链路层（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），它可以识别数据包中的MAC地址信息，<strong>根据<code>MAC地址</code>进行转发</strong>，并将这写地址与对应的连接端口记录在自己内部的一个地址表中。</p><p>三层交换机（路由器）<br>三层交换机工作于OSI模型中的第三层网络层，主要目的是加快大型局域网内部的数据交换。二层交换机是根据MAC地址进行处理数据， <strong>三层交换机是根据<code>IP地址</code>进行处理数</strong>据</p><blockquote><p>子网掩码：子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分.通过AND按位与运算即可确定。</p></blockquote><p>DNS是应用层协议</p><p>网关是从一个网络到另一个网络的关口，或者说是从一个网络通向其他网络的IP地址。比如有网络A和网络B，A的IP范围<code>192.168.1.1</code> ~ <code>192.168.1.254</code>，子网掩码<code>255.255.255.0</code>，B的IP范围是<code>192.168.2.1</code> ~ <code>192.168.2.254</code>，子网掩码为<code>255.255.255.0</code>.在没有路由器的情况下，A网络和B网络是不能进行TCP？IP通信的。TCP/IP协议会判定两个网络中的主机属于不同的网络。如果网络A中的主机发现数据包的目的主机不在自己所属的网络中，它就会把数据包发送给自己的网关，再由网关转发给网络B的网关，最终网络B的网关再转发个网络B中的某个主机。</p><p><a href="https://blog.csdn.net/A_LINGYUAN/article/details/80036329" target="_blank" rel="noopener">ARP原理</a></p><ul><li>只要知道了目标地址的IP，就可以想这个目标IP发送数据包，但是，在网络层以下的链路层，实际进行通信的还是MAC，实际上也就是两个网卡之间的通信。ARP地址解析协议以IP地址为线索，用来定位下一个应该接收数据包的主机的MAC地址。ARP是根据IP地址获取MAC地址的一个网络层协议。</li></ul><blockquote><p>A类地址：第1到8位是网络地址，首位以二进制0开头，后24位二进制是主机地址。<br>B类地址：第1到16位是网络地址，前两位是二进制10，后16位二进制是主机地址。<br>C类地址：第1到24位是网络地址，前三位是二进制110，后8位二进制是主机地址。<br>D类地址：第1到32位是网络地址，前四位是二进制1110，没有主机地址。</p></blockquote><p>所以只有设置好网关的IP，TCP/IP协议才能实现不同网络之间的通信。网关的IP地址是具有路由功能的设备的IP地址，也就是路由器。</p><p><a href="https://blog.csdn.net/weixin_34183910/article/details/91858109" target="_blank" rel="noopener">网络传输中的心跳控制</a></p><h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同 步的。但是关闭连接时，当Server端<br>收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你 发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我<br>才能发送FIN报文，因此不能一起发送。故需要四步握手。<br><img src="https://pic1.zhimg.com/80/v2-e0f97d5a91bba0350232020bdbbe5f38_hd.jpg" alt="TCP / IP三握四挥"></p><h2 id="DNS的原理"><a href="#DNS的原理" class="headerlink" title="DNS的原理"></a>DNS的原理</h2><h2 id="HTTP报文格式、头部字段等"><a href="#HTTP报文格式、头部字段等" class="headerlink" title="HTTP报文格式、头部字段等"></a>HTTP报文格式、头部字段等</h2><ul><li>请求方法“方法URL议/版本”：<code>GET/sample.jsp HTTP/1.1</code></li><li><p>请求头(Request Header)<br>请求头包含许多有关的客户端环境和请求正文的有用信息。请求头可以声明浏览器所用的语言，请求正文的长度等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Accept:image/gif.image/jpeg.*/*</span><br><span class="line">Accept-Language:zh-cn</span><br><span class="line">Connection:Keep-Alive</span><br><span class="line">Host:localhost</span><br><span class="line">User-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)</span><br><span class="line">Accept-Encoding:gzip,deflate.</span><br></pre></td></tr></table></figure></li><li><p>请求正文<br>  请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：<br><code>username=jinqiao&amp;password=1234</code></p></li></ul><h2 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h2><p>cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：</p><ul><li>无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。</li><li>在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。<h2 id="IPv4和IPv6"><a href="#IPv4和IPv6" class="headerlink" title="IPv4和IPv6"></a>IPv4和IPv6</h2></li><li>地址空间不同，IPv4中规定IP地址长度为32，而IPv6中IP地址的长度为128。</li><li>路由表大小不同，IPv6的路由表相比IPv4的更小。</li><li>安全性不同，IPv6的安全性更高，在使用IPv6的网络时，用户可对网络层的数据进行加密。</li></ul><h2 id="数字证书如何生成"><a href="#数字证书如何生成" class="headerlink" title="数字证书如何生成"></a><a href="https://baijiahao.baidu.com/s?id=1632331114122702660&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">数字证书如何生成</a></h2><h3 id="DHCP动态主机配置协议，是一种让系统得以连接到网络上，并获取所需的配置参数的手段"><a href="#DHCP动态主机配置协议，是一种让系统得以连接到网络上，并获取所需的配置参数的手段" class="headerlink" title="DHCP动态主机配置协议，是一种让系统得以连接到网络上，并获取所需的配置参数的手段"></a>DHCP动态主机配置协议，是一种让系统得以连接到网络上，并获取所需的配置参数的手段</h3><ul><li><a href="https://blog.csdn.net/weikanghuan/article/details/50825762?locationNum=6&amp;fps=1" target="_blank" rel="noopener">ICMP ping检测网络通信故障和实现链路追踪</a></li><li>ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。</li></ul><h3 id="从网络加载一个10M的图片，说下注意事项"><a href="#从网络加载一个10M的图片，说下注意事项" class="headerlink" title="从网络加载一个10M的图片，说下注意事项"></a>从网络加载一个10M的图片，说下注意事项</h3><h3 id="图解TCP的3次握手和四次挥手"><a href="#图解TCP的3次握手和四次挥手" class="headerlink" title="图解TCP的3次握手和四次挥手"></a><a href="https://hetaobackend.cn/2019/11/14/%E5%9B%BE%E8%A7%A3TCP&amp;IP-TCP%E4%B8%8EUDP/" target="_blank" rel="noopener">图解TCP的3次握手和四次挥手</a></h3><h3 id="TCP协议如何来保证传输的可靠性"><a href="#TCP协议如何来保证传输的可靠性" class="headerlink" title="TCP协议如何来保证传输的可靠性"></a>TCP协议如何来保证传输的可靠性</h3><h3 id="如何验证证书的合法性"><a href="#如何验证证书的合法性" class="headerlink" title="如何验证证书的合法性"></a>如何验证证书的合法性</h3><h3 id="Get与POST的区别"><a href="#Get与POST的区别" class="headerlink" title="Get与POST的区别"></a>Get与POST的区别</h3><ul><li>get请求参数在url地址上，直接暴露，post请求的参数放body部分，按F12也直接暴露了</li><li>GET产生一个TCP数据包；POST产生两个TCP数据包。长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200ok（返回数据）。</li><li>get传输量小,因为受URL长度限制,但效率较低。post可以传输大量数据,所以上传文件时只能用post方式<h3 id="TCP的拥塞处理"><a href="#TCP的拥塞处理" class="headerlink" title="TCP的拥塞处理"></a>TCP的拥塞处理</h3><h3 id="TCP是如何进行流量控制"><a href="#TCP是如何进行流量控制" class="headerlink" title="TCP是如何进行流量控制"></a>TCP是如何进行流量控制</h3><h3 id="TCP和UDP分别对应的常见应用层协议"><a href="#TCP和UDP分别对应的常见应用层协议" class="headerlink" title="TCP和UDP分别对应的常见应用层协议"></a>TCP和UDP分别对应的常见应用层协议</h3><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><h3 id="有了唯一的Mac地址为啥还需要IP地址？"><a href="#有了唯一的Mac地址为啥还需要IP地址？" class="headerlink" title="有了唯一的Mac地址为啥还需要IP地址？"></a>有了唯一的Mac地址为啥还需要IP地址？</h3><h3 id="交换机、集线器与路由器有什么区别？"><a href="#交换机、集线器与路由器有什么区别？" class="headerlink" title="交换机、集线器与路由器有什么区别？"></a>交换机、集线器与路由器有什么区别？</h3><h3 id="网桥的作用"><a href="#网桥的作用" class="headerlink" title="网桥的作用"></a>网桥的作用</h3>网桥工作在数据链路层，将两个LAN连起来，根据MAC地址来转发帧，可以看作一个“低层的路由器”（路由器工作在网络层，根据网络地址如IP地址进行转发</li><li>过滤通信量。网桥可以使用局域网的一个网段上各工作站之间的信息量局限在本网段的范围内，而不会经过网桥溜到其他网段去。</li><li>扩大了物理范围，也增加了整个局域网上的工作站的最大数目。</li><li>可使用不同的物理层，可互连不同的局域网。</li><li>提高了可靠性。如果把较大的局域网分割成若干较小的局域网，并且每个小的局域网内部的信息量明显地高于网间的信息量，那么整个互连网络的性能就变得更好<br>网桥缺点</li><li>由于网桥对接收的帧要先存储和查找站表，然后转发，这就增加了时延。</li><li>在MAC子层并没有流量控制功能。当网络上负荷很重时，可能因网桥缓冲区的存储空间不够而发生溢出，以致产生帧丢失的现象。</li><li>具有不同MAC子层的网段桥接再一起时，网桥在转发一个帧之前，必须修改帧的某些字段的内容，以适合另一个MAC子层的要求，增加时延。</li><li>网桥只适合于用户数不太多（不超过几百个）和信息量不太大的局域网，否则有时会产生较大的广播风暴。<h3 id="网络接口卡（网卡）的功能？"><a href="#网络接口卡（网卡）的功能？" class="headerlink" title="网络接口卡（网卡）的功能？"></a>网络接口卡（网卡）的功能？</h3>网络接口卡即网卡也就是网络适配器，接收上一层的ip数据报，并将其封装成帧发送到局域网中。一般的适配器都包含物理层和数据链路层这两层的功能。网络接口卡实现的是TCP/IP四层参考模型中的网络接口层，对应OSI七 层参考模型中的 物理层协议和数据链路层协议。</li></ul><h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p>URI标记了一个网络资源，仅此而已；  URL标记了一个WWW互联网资源（用地址标记），并给出了他的访问地址</p><h3 id="GET请求中URL编码的意义"><a href="#GET请求中URL编码的意义" class="headerlink" title="GET请求中URL编码的意义"></a>GET请求中URL编码的意义</h3><blockquote><p> 首先 url 在网络中传输时使用ascll编码的，也就是说，在浏览器中一个请求发出去最终是使用ascll编码的，这样子要是我们发出去的请求中包含有非ascll字符的话，就会被浏览器编码，但是，但是，各个浏览器对于url的编码方式是不一样的！！！这就会导致很大的问题，同一个url在不同的浏览器中实际发出的url都不一样了，服务器还要怎么解析这些请求的？要解决这个问题效率最最高的方法就是在前端中对要发出的url使用js 进行编码，编码后的url就只剩下ascll编码中有的字符了。这就是URL编码。<br>URL编码指的是对网址上的不安全的字符，例如中文，进行编码，编码后的中文方便在网络上传输。<strong>URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示</strong>，反之就是解码。</p></blockquote><h3 id="APPlication-Session和Cookie的区别"><a href="#APPlication-Session和Cookie的区别" class="headerlink" title="APPlication,Session和Cookie的区别"></a><a href="https://www.cnblogs.com/breezeblew/archive/2008/05/02/1179143.html" target="_blank" rel="noopener">APPlication,Session和Cookie的区别</a></h3><h3 id="彻底弄懂session，cookie，token"><a href="#彻底弄懂session，cookie，token" class="headerlink" title="彻底弄懂session，cookie，token"></a><a href="https://segmentfault.com/a/1190000017831088" target="_blank" rel="noopener">彻底弄懂session，cookie，token</a></h3><h3 id="http缓存机制，浏览器缓存到底是什么"><a href="#http缓存机制，浏览器缓存到底是什么" class="headerlink" title="http缓存机制，浏览器缓存到底是什么"></a><a href="https://blog.csdn.net/zouzixuan/article/details/84677548" target="_blank" rel="noopener">http缓存机制，浏览器缓存到底是什么</a></h3><h3 id="如何避免浏览器缓存"><a href="#如何避免浏览器缓存" class="headerlink" title="如何避免浏览器缓存"></a><a href="https://www.php.cn/website-design-ask-413969.html" target="_blank" rel="noopener">如何避免浏览器缓存</a></h3><h3 id="什么是分块传送。"><a href="#什么是分块传送。" class="headerlink" title="什么是分块传送。"></a>什么是分块传送。</h3><p>如果 HTTP 整块传输，需要提前设置 Content-Length。<br>分块传输编码（Chunked transfer encoding）允许服务端在不预先给出报文长度的情况下，分块将输出发送给客户端。输出空段表示报文结束。</p><h3 id="几种网络攻击方法"><a href="#几种网络攻击方法" class="headerlink" title="几种网络攻击方法"></a>几种网络攻击方法</h3><ul><li>XSS （跨站脚本攻击) 【攻击者在 Web 页面中插入恶意脚本，当用户浏览页面时，促使脚本执行，从而达到攻击目的】<blockquote><p>(1)客服端及服务端用户的输入数据进行双重验证(2)对所有的数据进行适当的编码(3)设置 HTTP Header： “X-XSS-Protection:1”</p></blockquote></li><li>DDos 分布式拒绝服务，【发送大量请求，使服务器瘫痪】<blockquote><p>服务器加带宽（成本昂贵）2.使用DDos 防御产品</p></blockquote></li><li>CSRF 跨站请求伪造 【用户本地存储cookie，攻击者利用用户的cookie进行认证，然后伪造用户发出请求】<blockquote><p>检查标准请求头 ，确认是否同源(2)检查CSRF token</p></blockquote></li><li>SQL注入(通过用户输入,拼接成恶意Sql,并执行)<blockquote><p>预编译SQL 2.验证用户输入3.用户输入编码</p></blockquote></li></ul><h3 id="XXS攻击和SQL注入"><a href="#XXS攻击和SQL注入" class="headerlink" title="XXS攻击和SQL注入"></a><a href="https://baijiahao.baidu.com/s?id=1618267672561552800&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">XXS攻击和SQL注入</a></h3><p><a href="https://www.jianshu.com/p/2a66b2ddc0fd" target="_blank" rel="noopener">MySQL最全的重要知识点学习</a></p><p><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></p><h1 id="HTTP-常见面试题"><a href="#HTTP-常见面试题" class="headerlink" title="HTTP 常见面试题"></a><a href="https://zhuanlan.zhihu.com/p/85363975" target="_blank" rel="noopener">HTTP 常见面试题</a></h1><h3 id="http协议有哪几种请求方式？"><a href="#http协议有哪几种请求方式？" class="headerlink" title="http协议有哪几种请求方式？"></a>http协议有哪几种请求方式？</h3><ul><li>GET:用于请求访问已经被URI(统一资源标识符)识别的资源,可以通过URL传参给服务器</li><li>POST:用于传输信息给服务器,主要功能与GET方法类似,但一般推荐使用POST方式</li><li>PUT:传输文件,报文主体中包含文件内容,保存到对应URI位置</li><li>HEAD:获得报文首部,与GET方法类似,只是不返回报文主体,一般用于验证URI是否有效</li><li>DELETE:删除文件,与PUT方法相反,删除对应URI位置的文件</li><li>OPTIONS:查询响应URI支持的HTTP方法</li></ul><h3 id="http和https区别？"><a href="#http和https区别？" class="headerlink" title="http和https区别？"></a>http和https区别？</h3><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。<br>总的来说： HTTPS=SSL+HTTP</p><ul><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>（这个只是默认端口不一样，实际上端口是可以改的）</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul><h3 id="HTTP请求报文与响应报文格式"><a href="#HTTP请求报文与响应报文格式" class="headerlink" title="HTTP请求报文与响应报文格式"></a>HTTP请求报文与响应报文格式</h3><p>请求报文包含三部分：</p><ul><li><strong>请求行：包含请求方法、URI、HTTP版本信息</strong></li><li>请求头部（headers）字段</li><li>请求内容实体(body)</li></ul><p>响应报文包含三部分：</p><ul><li><strong>状态行：包含HTTP版本、状态码、状态码的原因短</strong></li><li>响应头部（headers）字段</li><li>响应内容(body)实体</li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul><li>200 请求已成功，请求所希望的响应头或数据体将随此响应返回。</li><li>201 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回</li><li>202 服务器已接受请求，但尚未处理</li><li>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li><li>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li><li>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li><li>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</li><li><p>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p></li><li><p>401 当前请求需要用户验证。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书</p></li><li>403 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交</li><li>404 请求失败，请求所希望得到的资源未被在服务器上发现</li><li>500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</li><li>501 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</li><li>502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li><li>503 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。</li></ul>]]></content>
    
    <summary type="html">
    
      Fell free to approach to the Interview questions about Computer Networks.
    
    </summary>
    
    
      <category term="Computer Networks" scheme="http://yoursite.com/tags/Computer-Networks/"/>
    
  </entry>
  
  <entry>
    <title>Travel</title>
    <link href="http://yoursite.com/2019/05/17/Travel/"/>
    <id>http://yoursite.com/2019/05/17/Travel/</id>
    <published>2019-05-17T10:44:48.000Z</published>
    <updated>2019-10-11T08:37:15.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Europe"><a href="#Europe" class="headerlink" title="Europe"></a>Europe</h1><ul><li><a href="https://www.goteamjosh.com/europe" target="_blank" rel="noopener">Europe</a></li></ul><h1 id="Asian"><a href="#Asian" class="headerlink" title="Asian"></a>Asian</h1><h2 id="TAIWAN"><a href="#TAIWAN" class="headerlink" title="TAIWAN"></a>TAIWAN</h2><ul><li><a href="https://www.goteamjosh.com/blog/lionshead" target="_blank" rel="noopener">taiwan</a></li></ul>]]></content>
    
    <summary type="html">
    
      AROUND THE WORLD
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="Travel" scheme="http://yoursite.com/tags/Travel/"/>
    
  </entry>
  
  <entry>
    <title>Design Pattern-Behavioral-pattern</title>
    <link href="http://yoursite.com/2019/05/16/Design-Pattern-Behavioral-pattern/"/>
    <id>http://yoursite.com/2019/05/16/Design-Pattern-Behavioral-pattern/</id>
    <published>2019-05-16T14:06:20.000Z</published>
    <updated>2020-02-17T10:20:13.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Design-Patterns”-Is-a-Bad-Name-From-laike9m"><a href="#Design-Patterns”-Is-a-Bad-Name-From-laike9m" class="headerlink" title="Design Patterns” Is a Bad Name From laike9m"></a><a href="https://laike9m.com/blog/design-patterns-is-a-bad-name,131/" target="_blank" rel="noopener">Design Patterns” Is a Bad Name From laike9m</a></h1><p></p><h2 id="-">行为型模式</h2><p></p><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p><br><h3 id="-">策略模式</h3><br><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p><br><p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p><br><p>首先，先定义一个策略接口：</p><br><pre><code class="lang-java">public interface Strategy {<br>   public void draw(int radius, int x, int y);<br>}<br></code></pre><br><p>然后我们定义具体的几个策略：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(&amp;quot;用红色笔画图，radius:&amp;quot; + radius + &amp;quot;, x:&amp;quot; + x + &amp;quot;, y:&amp;quot; + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenPen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(&amp;quot;用绿色笔画图，radius:&amp;quot; + radius + &amp;quot;, x:&amp;quot; + x + &amp;quot;, y:&amp;quot; + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluePen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(&amp;quot;用蓝色笔画图，radius:&amp;quot; + radius + &amp;quot;, x:&amp;quot; + x + &amp;quot;, y:&amp;quot; + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>使用策略的类：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeDraw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.draw(radius, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>客户端演示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> BluePen()); <span class="comment">// 使用绿色笔来画</span></span><br><span class="line">      context.executeDraw(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p><img src="https://www.javadoop.com/blogimages/design-pattern/strategy-1.png" alt="strategy-1"></p><br><p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p><br><p><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p><br><p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p><h3 id="-">观察者模式</h3><br><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p><br><p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&amp;lt;Observer&amp;gt; observers = <span class="keyword">new</span> ArrayList&amp;lt;Observer&amp;gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="comment">// 数据已变更，通知观察者们</span></span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者们</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>定义观察者接口：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p><br><p>我们来定义具体的几个观察者类：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在构造方法中进行订阅主题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="comment">// 通常在构造方法中将 this 发布出去的操作一定要小心</span></span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法由主题类在数据变更的时候进行调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = Integer.toBinaryString(subject.getState());</span><br><span class="line">        System.out.println(&amp;quot;订阅的数据发生变化，新的数据处理为二进制值为：&amp;quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HexaObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = Integer.toHexString(subject.getState()).toUpperCase();</span><br><span class="line">        System.out.println(&amp;quot;订阅的数据发生变化，新的数据处理为十六进制值为：&amp;quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>客户端使用也非常简单：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先定义一个主题</span></span><br><span class="line">    Subject subject1 = <span class="keyword">new</span> Subject();</span><br><span class="line">    <span class="comment">// 定义观察者</span></span><br><span class="line">    <span class="keyword">new</span> BinaryObserver(subject1);</span><br><span class="line">    <span class="keyword">new</span> HexaObserver(subject1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span></span><br><span class="line">    subject.setState(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>output:</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">订阅的数据发生变化，新的数据处理为二进制值为：<span class="number">1011</span></span><br><span class="line">订阅的数据发生变化，新的数据处理为十六进制值为：B</span><br></pre></td></tr></table></figure><br><br>当然，jdk 也提供了相似的支持，具体的大家可以参考 <code>java.util.Observable</code>和 <code>java.util.Observer</code>这两个类。<p></p><br><p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p><br><p>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p><br><br><h3 id="-">责任链模式</h3><p></p><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p><p></p><p></p><p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p><p></p><p><blockquote></blockquote></p><p></p><p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p><br><p></p><p></p><p>首先，我们要定义流程上节点的基类：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">protected</span> RuleHandler successor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(RuleHandler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RuleHandler <span class="title">getSuccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>接下来，我们需要定义具体的每个节点了。</p><p></p><p></p><p>校验用户是否是新用户：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewUserRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (context.isNewUser()) &#123;</span><br><span class="line">            <span class="comment">// 如果有后继节点的话，传递下去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(&amp;quot;该活动仅限新用户参与&amp;quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>校验用户所在地区是否可以参与：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocationRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> allowed = activityService.isSupportedLocation(context.getLocation);</span><br><span class="line">        <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(&amp;quot;非常抱歉，您所在的地区无法参与本次活动&amp;quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>校验奖品是否已领完：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> remainedTimes = activityService.queryRemainedTimes(context); <span class="comment">// 查询剩余奖品</span></span><br><span class="line">        <span class="keyword">if</span> (remainedTimes &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(userInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(&amp;quot;您来得太晚了，奖品被领完了&amp;quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>客户端：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RuleHandler newUserHandler = <span class="keyword">new</span> NewUserRuleHandler();</span><br><span class="line">    RuleHandler locationHandler = <span class="keyword">new</span> LocationRuleHandler();</span><br><span class="line">    RuleHandler limitHandler = <span class="keyword">new</span> LimitRuleHandler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span></span><br><span class="line">    locationHandler.setSuccessor(limitHandler);</span><br><span class="line"></span><br><span class="line">    locationHandler.apply(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p><p></p><p></p><p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p><p></p><p></p><h3 id="-">模板方法模式</h3><p></p><p></p><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p><p></p><p></p><p>通常会有一个抽象类：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这就是模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); <span class="comment">// 这个是重点</span></span><br><span class="line">        end(); <span class="comment">// 可以作为钩子方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(&amp;quot;init 抽象层已经实现，子类也可以选择覆写&amp;quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p><p></p><p></p><p>我们写一个实现类：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(&amp;quot;子类实现抽象方法 apply&amp;quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(&amp;quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&amp;quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>客户端调用演示：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractTemplate t = <span class="keyword">new</span> ConcreteTemplate();</span><br><span class="line">    <span class="comment">// 调用模板方法</span></span><br><span class="line">    t.templateMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p><p></p><p></p><h3 id="-">状态模式</h3><p></p><p></p><p>update: 2017-10-19</p><p></p><p></p><p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p><p></p><p></p><p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p><p></p><p></p><p>定义状态接口：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>定义减库存的状态：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeductState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(&amp;quot;商品卖出，准备减库存&amp;quot;);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行减库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;quot;Deduct State&amp;quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>定义补库存状态：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RevertState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(&amp;quot;给此商品补库存&amp;quot;);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行加库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;quot;Revert State&amp;quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>我们来看下客户端调用，大家就一清二楚了：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们需要操作的是 iPhone X</span></span><br><span class="line">    Context context = <span class="keyword">new</span> Context(&amp;quot;iPhone X&amp;quot;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看怎么进行补库存操作</span></span><br><span class="line">      State revertState = <span class="keyword">new</span> RevertState();</span><br><span class="line">      revertState.doAction(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样的，减库存操作也非常简单</span></span><br><span class="line">      State deductState = <span class="keyword">new</span> DeductState();</span><br><span class="line">      deductState.doAction(context);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果需要我们可以获取当前的状态</span></span><br><span class="line">    <span class="comment">// context.getState().toString();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p><p></p><p></p><p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p><p></p><p></p><h3 id="-">行为型模式总结</h3><p></p><p></p><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p><p></p><p></p><h2 id="-">总结</h2><p></p><p></p><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</p><p></p><p></p><p>（全文完）</p><br><p></p><p><a href="https://javadoop.com/post/design-pattern" target="_blank" rel="noopener">https://javadoop.com/post/design-pattern</a></p>]]></content>
    
    <summary type="html">
    
      Design Patterns&quot; Is a Bad Name From laike9m
    
    </summary>
    
      <category term="Foundation" scheme="http://yoursite.com/categories/Foundation/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Design Patterns" scheme="http://yoursite.com/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>DesignPattern-Structural-pattern part2</title>
    <link href="http://yoursite.com/2019/05/16/DesignPattern-Structural-pattern-part2/"/>
    <id>http://yoursite.com/2019/05/16/DesignPattern-Structural-pattern-part2/</id>
    <published>2019-05-16T14:06:20.000Z</published>
    <updated>2020-02-18T06:24:27.281Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章 详解设计模式之结构型模式（上）中我们学习了三种结构型模式：适配器模式、桥接模式、组合模式。本文我们将介绍剩余四种结构型模式，它们分别是：</p><ul><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul><h2 id="四、装饰模式"><a href="#四、装饰模式" class="headerlink" title="四、装饰模式"></a>四、装饰模式</h2><p>提到装饰，我们先来想一下生活中有哪些装饰：</p><ul><li>女生的首饰：戒指、耳环、项链等装饰品</li><li>家居装饰品：粘钩、镜子、壁画、盆栽等</li></ul><p>我们为什么需要这些装饰品呢？很容易想到是为了美，戒指、耳环、项链、壁画、盆栽等都是为了提高颜值或增加美观度。但粘钩、镜子不一样，它们是为了方便我们挂东西、洗漱。所以我们可以总结出装饰品共有两种功能：</p><ul><li>增强原有的特性：我们本身就是有一定颜值的，添加装饰品提高了我们的颜值。同样，房屋本身就有一定的美观度，家居装饰提高了房屋的美观度。</li><li>添加新的特性：在墙上挂上粘钩，让墙壁有了挂东西的功能。在洗漱台装上镜子，让洗漱台有了照镜子的功能。</li></ul><p>并且，我们发现装饰品并不会改变物品本身，只是起到一个锦上添花的作用。装饰模式也一样，它的主要作用就是：</p><ul><li>增强一个类原有的功能</li><li>为一个类添加新的功能<br>并且 装饰模式也不会改变原有的类。</li></ul><blockquote><p>装饰模式：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p></blockquote><h2 id="1-用于增强功能的装饰模式"><a href="#1-用于增强功能的装饰模式" class="headerlink" title="1. 用于增强功能的装饰模式"></a>1. 用于增强功能的装饰模式</h2><p>我们用程序来模拟一下戴上装饰品提高我们颜值的过程：</p><p>新建颜值接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBeauty</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新建 Me 类，实现颜值接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Me</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>戒指装饰类，将 Me 包装起来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RingDecorator</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RingDecorator</span><span class="params">(IBeauty me)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.me = me;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IBeauty me = <span class="keyword">new</span> Me();</span><br><span class="line">        System.out.println(<span class="string">"我原本的颜值："</span> + me.getBeautyValue());</span><br><span class="line">​</span><br><span class="line">        IBeauty meWithRing = <span class="keyword">new</span> RingDecorator(me);</span><br><span class="line">        System.out.println(<span class="string">"戴上了戒指后，我的颜值："</span> + meWithRing.getBeautyValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，输出如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我原本的颜值：<span class="number">100</span></span><br><span class="line">戴上了戒指后，我的颜值：<span class="number">120</span></span><br></pre></td></tr></table></figure></p><p>这就是最简单的增强功能的装饰模式。以后我们可以添加更多的装饰类，比如：</p><p>耳环装饰类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EarringDecorator</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EarringDecorator</span><span class="params">(IBeauty me)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.me = me;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>项链装饰类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NecklaceDecorator</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NecklaceDecorator</span><span class="params">(IBeauty me)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.me = me;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IBeauty me = <span class="keyword">new</span> Me();</span><br><span class="line">        System.out.println(<span class="string">"我原本的颜值："</span> + me.getBeautyValue());</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 随意挑选装饰</span></span><br><span class="line">        IBeauty meWithNecklace = <span class="keyword">new</span> NecklaceDecorator(me);</span><br><span class="line">        System.out.println(<span class="string">"戴上了项链后，我的颜值："</span> + meWithNecklace.getBeautyValue());</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 多次装饰</span></span><br><span class="line">        IBeauty meWithManyDecorators = <span class="keyword">new</span> NecklaceDecorator(<span class="keyword">new</span> RingDecorator(<span class="keyword">new</span> EarringDecorator(me)));</span><br><span class="line">        System.out.println(<span class="string">"戴上耳环、戒指、项链后，我的颜值："</span> + meWithManyDecorators.getBeautyValue());</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 任意搭配装饰</span></span><br><span class="line">        IBeauty meWithNecklaceAndRing = <span class="keyword">new</span> NecklaceDecorator(<span class="keyword">new</span> RingDecorator(me));</span><br><span class="line">        System.out.println(<span class="string">"戴上戒指、项链后，我的颜值："</span> + meWithNecklaceAndRing.getBeautyValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，输出如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我原本的颜值：<span class="number">100</span></span><br><span class="line">戴上了项链后，我的颜值：<span class="number">180</span></span><br><span class="line">戴上耳环、戒指、项链后，我的颜值：<span class="number">250</span></span><br><span class="line">戴上戒指、项链后，我的颜值：<span class="number">200</span></span><br></pre></td></tr></table></figure></p><p>可以看到，装饰器也实现了 IBeauty 接口，并且没有添加新的方法，也就是说这里的装饰器仅用于增强功能，并不会改变 Me 原有的功能，这种装饰模式称之为 透明装饰模式，由于没有改变接口，也没有新增方法，所以透明装饰模式可以无限装饰。</p><p>装饰模式是 继承 的一种替代方案。本例如果不使用装饰模式，而是改用继承实现的话，戴着戒指的 Me 需要派生一个子类、戴着项链的 Me 需要派生一个子类、戴着耳环的 Me 需要派生一个子类、戴着戒指 + 项链的需要派生一个子类……各种各样的排列组合会造成类爆炸。而采用了装饰模式就只需要为每个装饰品生成一个装饰类即可，所以说就 增加对象功能 来说，装饰模式比生成子类实现更为灵活。</p><h2 id="2-用于添加功能的装饰模式"><a href="#2-用于添加功能的装饰模式" class="headerlink" title="2. 用于添加功能的装饰模式"></a>2. 用于添加功能的装饰模式</h2><p>我们用程序来模拟一下房屋装饰粘钩后，新增了挂东西功能的过程：</p><p>新建房屋接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHouse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">live</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>房屋类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">implements</span> <span class="title">IHouse</span></span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"房屋原有的功能：居住功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新建粘钩装饰器接口，继承自房屋接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStickyHookHouse</span> <span class="keyword">extends</span> <span class="title">IHouse</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hangThings</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>粘钩装饰类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StickyHookDecorator</span> <span class="keyword">implements</span> <span class="title">IStickyHookHouse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IHouse house;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StickyHookDecorator</span><span class="params">(IHouse house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.live();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有了粘钩后，新增了挂东西功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IHouse house = <span class="keyword">new</span> House();</span><br><span class="line">        house.live();</span><br><span class="line">​</span><br><span class="line">        IStickyHookHouse stickyHookHouse = <span class="keyword">new</span> StickyHookDecorator(house);</span><br><span class="line">        stickyHookHouse.live();</span><br><span class="line">        stickyHookHouse.hangThings();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，显示如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">房屋原有的功能：居住功能</span><br><span class="line">房屋原有的功能：居住功能</span><br><span class="line">有了粘钩后，新增了挂东西功能</span><br></pre></td></tr></table></figure></p><p>这就是用于 新增功能 的装饰模式。我们在接口中新增了方法：hangThings，然后在装饰器中将 House 类包装起来，之前 House 中的方法仍然调用 house 去执行，也就是说我们并没有修改原有的功能，只是扩展了新的功能，这种模式在装饰模式中称之为 半透明装饰模式。</p><p>为什么叫半透明呢？由于新的接口 IStickyHookHouse 拥有之前 IHouse 不具有的方法，所以我们如果要使用装饰器中添加的功能，就不得不区别对待 装饰前的对象和装饰后的对象。也就是说客户端要使用新方法，必须知道具体的装饰类 StickyHookDecorator，所以这个装饰类对客户端来说是可见的、不透明的。而被装饰者不一定要是 House，它可以是实现了 IHouse 接口的任意对象，所以被装饰者对客户端是不可见的、透明的。由于一半透明，一半不透明，所以称之为半透明装饰模式。</p><p>我们可以添加更多的装饰器：</p><p>新建镜子装饰器的接口，继承自房屋接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMirrorHouse</span> <span class="keyword">extends</span> <span class="title">IHouse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lookMirror</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>镜子装饰类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MirrorDecorator</span> <span class="keyword">implements</span> <span class="title">IMirrorHouse</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IHouse house;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MirrorDecorator</span><span class="params">(IHouse house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.live();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lookMirror</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有了镜子后，新增了照镜子功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IHouse house = <span class="keyword">new</span> House();</span><br><span class="line">        house.live();</span><br><span class="line">​</span><br><span class="line">        IMirrorHouse mirrorHouse = <span class="keyword">new</span> MirrorDecorator(house);</span><br><span class="line">        mirrorHouse.live();</span><br><span class="line">        mirrorHouse.lookMirror();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，输出如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">房屋原有的功能：居住功能</span><br><span class="line">房屋原有的功能：居住功能</span><br><span class="line">​有了镜子后，新增了照镜子功能</span><br></pre></td></tr></table></figure></p><p>现在我们仿照 透明装饰模式 的写法，同时添加粘钩和镜子装饰试一试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IHouse house = <span class="keyword">new</span> House();</span><br><span class="line">        house.live();</span><br><span class="line">​</span><br><span class="line">        IStickyHookHouse stickyHookHouse = <span class="keyword">new</span> StickyHookDecorator(house);</span><br><span class="line">        IMirrorHouse houseWithStickyHookMirror = <span class="keyword">new</span> MirrorDecorator(stickyHookHouse);</span><br><span class="line">        houseWithStickyHookMirror.live();</span><br><span class="line">        houseWithStickyHookMirror.hangThings(); <span class="comment">// 这里会报错，找不到 hangThings 方法</span></span><br><span class="line">        houseWithStickyHookMirror.lookMirror();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​我们会发现，第二次装饰时，无法获得上一次装饰添加的方法。原因很明显，当我们用 IMirrorHouse 装饰器后，接口变为了 IMirrorHouse，这个接口中并没有 hangThings 方法。</p><p>那么我们能否让 IMirrorHouse 继承自 IStickyHookHouse，以实现新增两个功能呢？</p><p>可以，但那样做的话两个装饰类之间有了依赖关系，那就不是装饰模式了。装饰类不应该存在依赖关系，而应该在原本的类上进行装饰。这就意味着，半透明装饰模式中，我们无法多次装饰。</p><p>有的同学会问了，既增强了功能，又添加了新功能的装饰模式叫什么呢？</p><p>—— 举一反三，肯定是叫全不透明装饰模式！</p><p>—— 并不是！只要添加了新功能的装饰模式都称之为 半透明装饰模式，他们都具有不可以多次装饰的特点。仔细理解上文半透明名称的由来就知道了，“透明”指的是我们无需知道被装饰者具体的类，既增强了功能，又添加了新功能的装饰模式仍然具有半透明特性。</p><p>看了这两个简单的例子，是不是发现装饰模式很简单呢？恭喜你学会了 1 + 1 = 2，现在你已经掌握了算数的基本思想，接下来我们来做一道微积分题练习一下。</p><h2 id="I-O-中的装饰模式"><a href="#I-O-中的装饰模式" class="headerlink" title="I/O 中的装饰模式"></a>I/O 中的装饰模式</h2><p>I/O 指的是 Input/Output，即输入、输出。我们以 Input 为例。先在 src 文件夹下新建一个文件 readme.text，随便写点文字：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">禁止套娃</span><br><span class="line">禁止禁止套娃</span><br><span class="line">​禁止禁止禁止套娃</span><br></pre></td></tr></table></figure></p><p>然后用 Java 的 InputStream 读取，代码一般长这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">io</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>));</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (in.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样写有一个问题，如果读取过程中出现了 IO 异常，InputStream 就不能正确关闭，所以我们要用try…finally来保证 InputStream 正确关闭：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">io</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (in.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种写法实在是太丑了，而 IO 操作又必须这么写，显然 Java 也意识到了这个问题，所以 Java 7 中引入了try(resource)语法糖，IO 的代码就可以简化如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">io</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>))) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (in.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种写法和上一种逻辑是一样的，运行程序，显示如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">禁止套娃</span><br><span class="line">禁止禁止套娃</span><br><span class="line">禁止禁止禁止套娃</span><br></pre></td></tr></table></figure></p><p>观察获取 InputStream 这句代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"src/readme.txt"</span>));</span><br></pre></td></tr></table></figure></p><p>是不是和我们之前多次装饰的代码非常相似：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 多次装饰</span></span><br><span class="line">IBeauty meWithManyDecorators = <span class="keyword">new</span> NecklaceDecorator(<span class="keyword">new</span> RingDecorator(<span class="keyword">new</span> EarringDecorator(me)));</span><br></pre></td></tr></table></figure></p><p>事实上，查看 I/O 的源码可知，Java I/O 的设计框架便是使用的 装饰者模式，InputStream 的继承关系如下：</p><p>其中，InputStream 是一个抽象类，对应上文例子中的 IHouse，其中最重要的方法是 read 方法，这是一个抽象方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法会读取输入流的下一个字节，并返回字节表示的 int 值（0~255），返回 -1 表示已读到末尾。由于它是抽象方法，所以具体的逻辑交由子类实现。</p><p>上图中，左边的三个类 FileInputStream、ByteArrayInputStream、ServletInputStream 是 InputStream 的三个子类，对应上文例子中实现了 IHouse 接口的 House。</p><p>右下角的三个类 BufferedInputStream、DataInputStream、CheckedInputStream 是三个具体的装饰者类，他们都为 InputStream 增强了原有功能或添加了新功能。</p><p>FilterInputStream 是所有装饰类的父类，它没有实现具体的功能，仅用来包装了一下 InputStream：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们以 BufferedInputStream 为例。原有的 InputStream 读取文件时，是一个字节一个字节读取的，这种方式的执行效率并不高，所以我们可以设立一个缓冲区，先将内容读取到缓冲区中，缓冲区读满后，将内容从缓冲区中取出来，这样就变成了一段一段读取，用内存换取效率。BufferedInputStream 就是用来做这个的。它继承自 FilterInputStream：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">byte</span> buf[];</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先来看它的构造方法，在构造方法中，新建了一个 byte[] 作为缓冲区，从源码中我们看到，Java 默认设置的缓冲区大小为 8192 byte，也就是 8 KB。</p><p>然后我们来查看 read 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">​<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">            fill();</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 往缓冲区内填充读取内容的过程</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 read 方法中，调用了 fill 方法，fill 方法的作用就是往缓冲区中填充读取的内容。这样就实现了增强原有的功能。</p><p>在源码中我们发现，BufferedInputStream 没有添加 InputStream 中没有的方法，所以 BufferedInputStream 使用的是 透明的装饰模式。</p><p>DataInputStream 用于更加方便地读取 int、double 等内容，观察 DataInputStream 的源码可以发现，DataInputStream 中新增了 readInt、readLong 等方法，所以 DataInputStream 使用的是 半透明装饰模式。</p><p>理解了 InputStream 后，再看一下 OutputStream 的继承关系，相信大家一眼就能看出各个类的作用了：</p><p>这就是装饰模式，注意不要和适配器模式混淆了。两者在使用时都是包装一个类，但两者的区别其实也很明显：</p><ul><li>纯粹的适配器模式 仅用于改变接口，不改变其功能，部分情况下我们需要改变一点功能以适配新接口。但使用适配器模式时，接口一定会有一个 回炉重造 的过程。</li><li>装饰模式 不改变原有的接口，仅用于增强原有功能或添加新功能，强调的是锦上添花。</li></ul><p>掌握了装饰者模式之后，理解 Java I/O 的框架设计就非常容易了。但对于不理解装饰模式的人来说，各种各样相似的 InputStream 非常容易让开发者感到困惑。这一点正是装饰模式的缺点：容易造成程序中有大量相似的类。虽然这更像是开发者的缺点，我们应该做的是提高自己的技术，掌握了这个设计模式之后它就是我们的一把利器。现在我们再看到 I/O 不同的 InputStream 装饰类，只需要关注它增强了什么功能或添加了什么功能即可。</p><h2 id="五、外观模式"><a href="#五、外观模式" class="headerlink" title="五、外观模式"></a>五、外观模式</h2><p>外观模式非常简单，体现的就是 Java 中封装的思想。将多个子系统封装起来，提供一个更简洁的接口供外部调用。</p><blockquote><p>外观模式：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式。</p></blockquote><p>举个例子，比如我们每天打开电脑时，都需要做三件事：</p><ul><li>打开浏览器</li><li>打开 IDE</li><li>打开微信</li></ul><p>每天下班时，关机前需要做三件事：</p><ul><li>关闭浏览器</li><li>关闭 IDE</li><li>关闭微信</li></ul><p>用程序模拟如下：</p><p>新建浏览器类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Browser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开浏览器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭浏览器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​&#125;</span><br></pre></td></tr></table></figure></p><p>新建 IDE 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDE</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开 IDE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭 IDE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新建微信类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wechat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开微信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭微信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"上班:"</span>);</span><br><span class="line">        Browser.open();</span><br><span class="line">        IDE.open();</span><br><span class="line">        Wechat.open();</span><br><span class="line">​</span><br><span class="line">        System.out.println(<span class="string">"下班:"</span>);</span><br><span class="line">        Browser.close();</span><br><span class="line">        IDE.close();</span><br><span class="line">        Wechat.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，输出如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">上班:</span><br><span class="line">打开浏览器</span><br><span class="line">打开 IDE</span><br><span class="line">打开微信</span><br><span class="line">下班:</span><br><span class="line">关闭浏览器</span><br><span class="line">关闭 IDE</span><br><span class="line">关闭微信</span><br></pre></td></tr></table></figure></p><p>由于我们每天都要做这几件事，所以我们可以使用 外观模式，将这几个子系统封装起来，提供更简洁的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Browser.open();</span><br><span class="line">        IDE.open();</span><br><span class="line">        Wechat.open();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Browser.close();</span><br><span class="line">        IDE.close();</span><br><span class="line">        Wechat.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端就可以简化代码，只和这个外观类打交道：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        System.out.println(<span class="string">"上班:"</span>);</span><br><span class="line">        facade.open();</span><br><span class="line">​</span><br><span class="line">        System.out.println(<span class="string">"下班:"</span>);</span><br><span class="line">        facade.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​运行程序，输出与之前一样。</p><p>外观模式就是这么简单，它使得两种不同的类不用直接交互，而是通过一个中间件——也就是外观类——间接交互。外观类中只需要暴露简洁的接口，隐藏内部的细节，所以说白了就是封装的思想。</p><p>外观模式非常常用，（当然了！写代码哪有不封装的！）尤其是在第三方库的设计中，我们应该提供尽量简洁的接口供别人调用。另外，在 MVC 架构中，C 层（Controller）就可以看作是外观类，Model 和 View 层通过 Controller 交互，减少了耦合。</p><h2 id="六、享元模式"><a href="#六、享元模式" class="headerlink" title="六、享元模式"></a>六、享元模式</h2><p>享元模式体现的是 程序可复用 的特点，为了节约宝贵的内存，程序应该尽可能地复用，就像《极限编程》作者 Kent 在书里说到的那样：Don’t repeat yourself. 简单来说 享元模式就是共享对象，提高复用性，官方的定义倒是显得文绉绉的：</p><blockquote><p>享元模式：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。</p></blockquote><p>​有个细节值得注意：有些对象本身不一样，但通过一点点变化后就可以复用，我们编程时可能稍不注意就会忘记复用这些对象。比如说伟大的《超级玛丽》，谁能想到草和云更改一下颜色就可以实现复用呢？</p><p>还有里面的三种乌龟，换一个颜色、加一个装饰就变成了不同的怪：</p><p>在《超级玛丽》中，这样的细节还有很多，正是这些精湛的复用使得这一款红遍全球的游戏仅有 40KB 大小。正是印证了那句名言：神在细节之中。</p><h2 id="七、代理模式"><a href="#七、代理模式" class="headerlink" title="七、代理模式"></a>七、代理模式</h2><p>现在我们有一个 人 类，他整天就只负责吃饭、睡觉：</p><p>人类的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>人 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我在吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我在睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.eat();</span><br><span class="line">        person.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，输出如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​我在吃饭</span><br><span class="line">我在睡觉</span><br></pre></td></tr></table></figure></p><p>我们可以把这个类包装到另一个类中，实现完全一样的行为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> <span class="keyword">implements</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Person person;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonProxy</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.eat();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        person.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将客户端修改为调用这个新的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        PersonProxy proxy = <span class="keyword">new</span> PersonProxy(person);</span><br><span class="line">        proxy.eat();</span><br><span class="line">        proxy.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">​&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，输出如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我在吃饭</span><br><span class="line">我在睡觉</span><br></pre></td></tr></table></figure></p><p>这就是代理模式。</p><p>笔者尽量用最简洁的代码讲解此模式，只要理解了上述这个简单的例子，你就知道代理模式是怎么一回事了。我们在客户端和 Person 类之间新增了一个中间件 PersonProxy，这个类就叫做代理类，他实现了和 Person 类一模一样的行为。</p><blockquote><p>代理模式：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p></blockquote><p>现在这个代理类还看不出任何意义，我们来模拟一下工作中的需求。在实际工作中，我们可能会遇到这样的需求：在网络请求前后，分别打印将要发送的数据和接收到数据作为日志信息。此时我们就可以新建一个网络请求的代理类，让它代为处理网络请求，并在代理类中打印这些日志信息。</p><p>新建网络请求接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHttp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">(String sendData)</span></span>;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String receivedData)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新建 Http 请求工具类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtil</span> <span class="keyword">implements</span> <span class="title">IHttp</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(String sendData)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"网络请求中..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String receivedData)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"网络请求完成。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新建 Http 代理类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProxy</span> <span class="keyword">implements</span> <span class="title">IHttp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpUtil httpUtil;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpProxy</span><span class="params">(HttpUtil httpUtil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpUtil = httpUtil;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(String sendData)</span> </span>&#123;</span><br><span class="line">        httpUtil.request(sendData);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String receivedData)</span> </span>&#123;</span><br><span class="line">        httpUtil.onSuccess(receivedData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，和我们上述吃饭睡觉的代码是一模一样的，现在我们在 HttpProxy 中新增打印日志信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProxy</span> <span class="keyword">implements</span> <span class="title">IHttp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpUtil httpUtil;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpProxy</span><span class="params">(HttpUtil httpUtil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpUtil = httpUtil;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(String sendData)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发送数据:"</span> + sendData);</span><br><span class="line">        httpUtil.request(sendData);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String receivedData)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到数据:"</span> + receivedData);</span><br><span class="line">        httpUtil.onSuccess(receivedData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端验证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpUtil httpUtil = <span class="keyword">new</span> HttpUtil();</span><br><span class="line">        HttpProxy proxy = <span class="keyword">new</span> HttpProxy(httpUtil);</span><br><span class="line">        proxy.request(<span class="string">"request data"</span>);</span><br><span class="line">        proxy.onSuccess(<span class="string">"received result"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，输出如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">发送数据:request data</span><br><span class="line">网络请求中...</span><br><span class="line">收到数据:received result</span><br><span class="line">网络请求完成。</span><br></pre></td></tr></table></figure></p><p>这就是代理模式的一个应用，除了 打印日志，它还可以用来做权限管理。读者看到这里可能已经发现了，这个代理类看起来和装饰模式的 FilterInputStream 一模一样，但两者的目的不同，装饰模式是为了 增强功能或添加功能，代理模式主要是为了加以控制。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>上例中的代理被称之为静态代理，动态代理与静态代理的原理一模一样，只是换了一种写法。使用动态代理，需要把一个类传入，然后根据它正在调用的方法名判断是否需要加以控制。用伪代码表示如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpUtil httpUtil;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpProxy</span><span class="params">(HttpUtil httpUtil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpUtil = httpUtil;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 假设调用 httpUtil 的任意方法时，都要通过这个方法间接调用, methodName 表示方法名，args 表示方法中传入的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">visit</span><span class="params">(String methodName, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">"request"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果方法名是 request，打印日志，并调用 request 方法，args 的第一个值就是传入的参数</span></span><br><span class="line">            System.out.println(<span class="string">"发送数据:"</span> + args[<span class="number">0</span>]);</span><br><span class="line">            httpUtil.request(args[<span class="number">0</span>].toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">"onSuccess"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果方法名是 onSuccess，打印日志，并调用 onSuccess 方法，args 的第一个值就是传入的参数</span></span><br><span class="line">            System.out.println(<span class="string">"收到数据:"</span> + args[<span class="number">0</span>]);</span><br><span class="line">            httpUtil.onSuccess(args[<span class="number">0</span>].toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>伪代码看起来还是很简单的，实现起来唯一的难点就是 怎么让 httpUtil 调用任意方法时，都通过一个方法间接调用。这里需要用到反射技术，不了解反射技术也没有关系，不妨把它记做固定的写法。实际的动态代理类代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HttpUtil httpUtil;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IHttp <span class="title">getInstance</span><span class="params">(HttpUtil httpUtil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpUtil = httpUtil;</span><br><span class="line">        <span class="keyword">return</span> (IHttp) Proxy.newProxyInstance(httpUtil.getClass().getClassLoader(), httpUtil.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 调用 httpUtil 的任意方法时，都要通过这个方法调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"request"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果方法名是 request，打印日志，并调用 request 方法</span></span><br><span class="line">            System.out.println(<span class="string">"发送数据:"</span> + args[<span class="number">0</span>]);</span><br><span class="line">            result = method.invoke(httpUtil, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">"onSuccess"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果方法名是 onSuccess，打印日志，并调用 onSuccess 方法</span></span><br><span class="line">            System.out.println(<span class="string">"收到数据:"</span> + args[<span class="number">0</span>]);</span><br><span class="line">            result = method.invoke(httpUtil, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先看 getInstance 方法，Proxy.newProxyInstance 方法是 Java 系统提供的方法，专门用于动态代理。其中传入的第一个参数是被代理的类的 ClassLoader，第二个参数是被代理类的 Interfaces，这两个参数都是 Object 中的，每个类都有，这里就是固定写法。我们只要知道系统需要这两个参数才能让我们实现我们的目的：调用被代理类的任意方法时，都通过一个方法间接调用。现在我们给系统提供了这两个参数，系统就会在第三个参数中帮我们实现这个目的。</p><p>第三个参数是 InvocationHandler 接口，这个接口中只有一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure></p><p>​那么不用猜就知道，现在我们调用被代理类 httpUtil 的任意方法时，都会通过这个 invoke 方法调用了。invoke 方法中，第一个参数我们暂时用不上，第二个参数 method 就是调用的方法，使用 method.getName() 可以获取到方法名，第三个参数是调用 method 方法需要传入的参数。本例中无论 request 还是 onSuccess 都只有一个 String 类型的参数，对应到这里就是 args[0]。返回的 Object 是 method 方法的返回值，本例中都是无返回值的。</p><p>我们在 invoke 方法中判断了当前调用方法的方法名，如果现在调用的方法是 request，那么打印请求参数，并使用这一行代码继续执行当前方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = method.invoke(httpUtil, args);</span><br></pre></td></tr></table></figure></p><p>这就是 反射调用函数 的写法，如果不了解可以记做固定写法，想要了解的同学可以看之前的这篇文章：详解面试中常考的 Java 反射机制。虽然这个函数没有返回值，但我们还是将 result 返回，这是标准做法。</p><p>如果现在调用的方法是 onSuccess，那么打印接收到的数据，并反射继续执行当前方法。</p><p>修改客户端验证一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpUtil httpUtil = <span class="keyword">new</span> HttpUtil();</span><br><span class="line">        IHttp proxy = <span class="keyword">new</span> HttpProxy().getInstance(httpUtil);</span><br><span class="line">        proxy.request(<span class="string">"request data"</span>);</span><br><span class="line">        proxy.onSuccess(<span class="string">"received result"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，输出与之前一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">发送数据:request data</span><br><span class="line">网络请求中...</span><br><span class="line">收到数据:received result</span><br><span class="line">网络请求完成。</span><br></pre></td></tr></table></figure></p><p>动态代理本质上与静态代理没有区别，它的好处是 节省代码量。比如被代理类有 20 个方法，而我们只需要控制其中的两个方法，就可以用动态代理通过方法名对被代理类进行动态的控制，而如果用静态方法，我们就需要将另外的 18 个方法也写出来，非常繁琐。这就是动态代理的优势所在。</p><h2 id="八-享元模式-Flyweight-Pattern"><a href="#八-享元模式-Flyweight-Pattern" class="headerlink" title="八. 享元模式 Flyweight Pattern"></a>八. 享元模式 Flyweight Pattern</h2><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p><p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中</p><h1 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h1><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p><blockquote><p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p></blockquote><p>本文作者：Alpinist Wang</p><p>声明：本文归 “力扣” 版权所有，如需转载请联系。文章封面图和文中部分图片来源于网络，为非商业用途使用，如有侵权联系删除。</p><p>编辑于 2019-11-28</p>]]></content>
    
    <summary type="html">
    
      连part1的部分
    
    </summary>
    
      <category term="Foundation" scheme="http://yoursite.com/categories/Foundation/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Design Patterns" scheme="http://yoursite.com/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>CV And SoP</title>
    <link href="http://yoursite.com/2019/05/14/CV-AND-SOP/"/>
    <id>http://yoursite.com/2019/05/14/CV-AND-SOP/</id>
    <published>2019-05-13T16:06:50.000Z</published>
    <updated>2019-10-02T09:42:32.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="THE-GUIDELINE-OF-CV-AND-SOP-PS"><a href="#THE-GUIDELINE-OF-CV-AND-SOP-PS" class="headerlink" title="THE GUIDELINE OF CV AND SOP(PS)"></a>THE GUIDELINE OF CV AND SOP(PS)</h2><ul><li><p>美国研究生申请时经常会在Application Requirements部分看到几种不同名称的申请文书，比如：personal statement，PS，Personal history statement，statement，Statement of goals，Personal purpose，personal essay或Statement of Purpose。不管名字如何变化，其实就是我们大家都知道的研究生申请主文书——个人陈述，只不过不同的美国大学在申请时关注申请人的侧重点不同，要求学生主要陈述和介绍自己的内容占比不同，但核心内容并无太多差异。</p></li><li><p>通过上面这些美国大学的官方研究生申请文书的要求，我们可以看出个人陈述文书主要是让申请人要描述个人背景／经历、学习／学术情况、与申请专业相关的研究／实习／工作情况，以及职业目标这四部分。</p></li><li><ol><li>我要申请什么专业／项目？要申请具体哪个分支？</li></ol></li><li><ol start="2"><li>我为什么要申请这个专业？为什么选择这个分支？</li></ol></li><li><ol start="3"><li>我什么特殊经历或个人原因让你开始关注这个专业领域，开始对这个分支方向感兴趣？</li></ol></li><li><ol start="4"><li>我是否之前在学习、研究、实习或工作中有与申请专业和申请分支相关的个人经历、学术能力、专业技能或研究成果？</li></ol></li><li><ol start="5"><li>我觉得我目前在这个专业和这个分支领域还存在哪些不足，还希望进行怎样的专业能力提升和自我完善？</li></ol></li><li><ol start="6"><li>我未来的学习／研究计划是什么？</li></ol></li><li><ol start="7"><li>我未来的短期和长期的职业规划是什么？</li></ol></li><li><ol start="8"><li>我为什么会选择申请这所大学？吸引我的主要因素都有哪些？</li></ol></li><li><ol start="9"><li>除了学术、研究、工作方面经历和能力本身，你还有哪些个人独特的、有别其他人的地方？</li></ol></li></ul><h2 id="UCSD"><a href="#UCSD" class="headerlink" title="UCSD"></a>UCSD</h2><ul><li>看上面官网截图图片内容我们能看出，要求PS篇幅1页，并且需要包括：你感兴趣的具体领域，你关注的分支方向，以及你感兴趣的教授是谁。这个PS的命题要求需要我们注意明确篇幅字数，同时文书内容重点是在学术能力和项目研究方面去介绍自己和展示自己能力，以及要对这个学校的申请部门和教授们有一些了解和关注，因为是要明确具体的回答你感兴趣这个学校的分支方向和某个教授的，如果你不提前进行了解，回答的没有针对性，或者你提到的教授擅长研究领域根本不是你文书中表达的感兴趣方向，那么你这样的内容表述也会给你的申请减分。我不过这个学校的题目要求并不篇，完全可以在通用版PS的基础上最后补充1-2句感兴趣教授和对于这名教授的感兴趣原因就可以了，因为大部分通用版的PS内容中我是会给学生们直接陈述出申请人擅长和感兴趣的领域和分支方向的，所以这部分内容不需要额外新增和补充，只是有针对性的补充感兴趣教授就行了。</li></ul><h2 id="University-of-Michigan–Ann-Arbor的申请文书要求中需要同时递交两种文书，分别是Statement-of-Purpose和Personal-Statement，"><a href="#University-of-Michigan–Ann-Arbor的申请文书要求中需要同时递交两种文书，分别是Statement-of-Purpose和Personal-Statement，" class="headerlink" title="University of Michigan–Ann Arbor的申请文书要求中需要同时递交两种文书，分别是Statement of Purpose和Personal Statement，"></a>University of Michigan–Ann Arbor的申请文书要求中需要同时递交两种文书，分别是Statement of Purpose和Personal Statement，</h2><ul><li>这两个不同名称的文书在内容要求上是有区别的，第一个Statement of Purpose主要是让我们介绍自己关于学术、研究方面的背景和未来职业规划，这些部分正好是我上面提到要在通用版PS中涵盖的第1、2、4、5、6、7问题部分内容。第二个Personal Statement主要是让我们讲述自己的个人经历、想法观点、兴趣倾向，以及选择申请这所大学核心部分原因等内容，这些部分正好是我上面提到要在通用版PS中涵盖的第3、8、9问题部分内容。我们只要根据题目将通用版PS内容进行有效拆分就可以了，也并不需要跟别单独再新写两篇文书的。</li></ul><h2 id="特别、特别、特别重点强调的关键点："><a href="#特别、特别、特别重点强调的关键点：" class="headerlink" title="特别、特别、特别重点强调的关键点："></a>特别、特别、特别重点强调的关键点：</h2><ul><li><p>PS内容不要写的跟resume或CV一样，就是不用再完整的陈述一遍你简历中已经出现过的内容了，因为申请文书之间是相互呼应和结合的，所以PS要有针对性和侧重点的去表述重点，而不是流水账一样的再讲一遍！</p></li><li><p>PS申请文书表述的形式要以学术风格为主，严谨、有条理、有逻辑最重要，要客观陈述，避免使用过多形容词，但不要花很大比重去讲述和体现你的学术或项目研究完成过程和项目调研大篇幅内容，因为这部分是通过Writing sample或Research paper去展示的，而不是PS。</p></li><li><p>如果我们递交申请时会同时递交几篇文书（简历除外），那么请注意每篇文书之间的素材选择和文书内容要有不同，不要有太多相同内容重复出现，因为人是多元的，所以请尽量更多素材选择的去全面展示自己。</p></li></ul><p><a href="https://www.cantabenglish.com/blog/fiona-the-point-of-no-return" target="_blank" rel="noopener">CV SOP寫作心得</a></p><p><a href="http://exploringsharing.blogspot.com/2012/04/10-cv.html" target="_blank" rel="noopener">留學申請(10) - 讓別人一眼就了解你的CV</a></p><p><a href="http://jxyzabc.blogspot.com/2008/08/cs-grad-school-part-4-applications.html" target="_blank" rel="noopener">女博士的申請記錄（她的部落格）</a></p><p><a href="http://www.pgbovine.net/grad-school-app-tips.htm" target="_blank" rel="noopener">UCSD教授給出的指導建議(重要)</a></p><p><a href="http://www.pgbovine.net/PhD-application-tips.htm" target="_blank" rel="noopener">UCSD教授和他的學生在申請斯坦佛博士學位時使用的SOP</a></p><p><a href="https://users.soe.ucsc.edu/~ejw/advice/" target="_blank" rel="noopener">Advice for Foreign Students Wishing to Pursue Graduate Study in Computer Science at UCSC by Professor Jim Whitehead</a></p><p><a href="https://lin698.wixsite.com/essaypro1" target="_blank" rel="noopener">Native Speaker Editor+理工商法專業背景 + 中文客服(高學歷+豐富美國工作經驗) modify</a></p><p><a href="https://myshika.wordpress.com/2012/10/19/personal-statements-advice/" target="_blank" rel="noopener">申請文件：Personal Statement</a></p><ul><li><p>Shau-ru Lin(<a href="mailto:shau.ru.lin@gmail.com" target="_blank" rel="noopener">shau.ru.lin@gmail.com</a>)，費用計算是(2012/2013)：</p></li><li><p>Translation: $0.10/word (72 hours); $0.12/word (24 hours)</p></li><li><p>English Editing: $0.05/word (72 hours); $0.06/word (24 hours)</p></li></ul><p>##字数要求：</p><ul><li><p>personal_statement ： 三版 500 700 1000</p></li><li><p>SOP ：三版 500 700 1000</p></li><li><p>不同學校的SOP可能會有不同的字體, 字數限制, 有些學校的字數限制是死的, 也就是說他不會讓你上傳WORD或PDF檔,而是在申請系統內直接打字, 當你打超過規定的字數時他也不會讓你寫下去了, 而有些學校則是上傳WORD或PDF檔, 可以繳交超過學校字數規定的SOP, 但是超過字數會有甚麼後果有甚麼影響當然還是要先寄信跟學校問清楚, 如果校方說沒問題, 當然可以小超過一些, 我寫SOP的方式是先把第一志願的SOP寫出來, 我的第一志願SOP所限制的字數是1000字, 另外幾間學校都限制500字或800字, 先把最長的寫完, 之後再用1000字的修即可, SOP的格式依照侃威的建議採取5至6段, 第一段的目的是要吸引讀者所以會以類似小說的寫法作為開頭. 二三段分別在描述自己在學校做過的兩個projects, 第四段則是講畢業專題, 五與六段則是在講學校的課程或是學校有哪方面很吸引你, 以及你的未來規劃.</p></li><li><p>CV方面如果你有發publication那當然是非常加分的, publication之下就是在學校做的各個project或自己做的side-project, 你覺得越重要越能吸引審查員眼睛的經歷就要放在越前面, 例如我沒有發過任何的publication, 我就把我在學校做的兩個專題以及畢業專題放在最前面, 因為自己有許多志工經歷也有創立過社團, 這些相比之下比較沒那麼重要的就放在後面的頁數, CV我個人認為不要超過2頁, 而有些人也說審查者通常只會看第一頁, 所以說能盡量抓住他們眼睛的東西就盡量往前移, 排版方面侃威也幫我修了大概5–6次, 網路上也有許多的template可供大家做選擇.</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.1point3acres.com/bbs/thread-146008-1-1.html" target="_blank" rel="noopener">NWU同学的CV</a></li></ul><ul><li><p><a href="https://github.com/jeanqasaur/academic-application-materials/blob/master/phd-application-2007/personal_statement.pdf" target="_blank" rel="noopener">這裡是女博士的申請文件</a></p></li><li><p><a href="https://kan-wei.com/testimonial/calvin/" target="_blank" rel="noopener">NTU_UCLA</a></p></li></ul><p>有伯克利的台大电机系同学的在电脑里面可以拿来参考</p><h3 id="基本知识："><a href="#基本知识：" class="headerlink" title="基本知识："></a>基本知识：</h3><pre><code>1. personal statement→为什么来读（兴趣），为什么选项目，为目标做了什么（经历），可以给项目带来什么（对同学贡献，对教授贡献）2. SOP→要求一篇sop=ps（个人经历，课外活动，志愿者，人生规划等）--学术生活写一篇，要求两篇--sop侧重学术（学术兴趣，职业规划，学术经历）--分开写，适当增减。3. statement of diversity→学生背景多样性（学术领域，兴趣，家庭，社会族群），我的规划能带来什么多样性（什么多样性，怎么带来）eg.中医世家申请生物医药，政府官员家庭（了解中国）申请社会学历史学等，少数民族（语言融合）申请语言类，家庭背景（和本国比）差怎么对自己性格塑造产生影响4. 有些学校有明确要求，按照要求来。eg.有些学校会要求‘不要写什么’，可以打电话/发邮件给小蜜（问ps的明确要求）5. 格式要求：可以有页眉（CV不要有），正文就别再写题目了，一定要有页码，用默认页边距，用TIMES或者Cabrial，字号12，不要有水印/Logo，根据要求（single space，double space），不要分版块，段首缩进五格（敲五下）</code></pre><h3 id="写什么-怎么写："><a href="#写什么-怎么写：" class="headerlink" title="写什么/怎么写："></a>写什么/怎么写：</h3><pre><code>1. 我有什么兴趣，为什么，做了什么，意味着什么（做了哪些思考，得到了什么），为什么选这个项目2. 学校看完ps要能回答的三个问题：        * 为什么能再graduate level的学习中成功（学习能力，学习态度→GPA，基础知识→成绩单，若没有，需要写出‘我有足够的基础’，我有兴趣）        * 为什么能在职业发展中成功（有热情/兴趣，对领域有理解，有经验→细节，有能力）        * 为什么我和你的项目很匹配（为什么项目能帮我实现我的目标，我是你项目要找的人→读选校要求+推荐信）3. 研究兴趣/学术兴趣：        * eg. 申请ME，对燃烧感兴趣（笼统）→改为对公共政策专业里的具体方面感兴趣，如health policy里的与健康相关的XX问题（细化到一个大的研究问题而不是具体的题目）           * eg. 申请media/communication，如何评判social media中一个话题的讨论/影响（不强调什么话题什么影响，而是‘如何’评判）        * 总结：可以被实践探索的问题（PHD必须有研究兴趣，MS不一定，但要有相关的感兴趣的问题or想弄清楚等→体现它促使你努力学），相关兴趣点不要超过三个问题，两个最好，不相关兴趣点不要超过两个（不够focus）。        * 具体到‘哪个教授哪个方向’，</code></pre><ul><li><p>最好写相对general，不要写教授名字（除非套过辞，或者目标及其明确），免得该方向教授不招人（可以多写一个研究兴趣）。</p></li><li><p>要了解领域动态，你感兴趣的（不能太过时）是否跟美国院校主流兴趣match的，这个学校的擅长领域是否跟自己match（如专排），自己的背景是否justify–真实，合理。</p></li><li><p>对于职业型MS，要突出自己的行业领域兴趣（具体哪个行业，government，nonprofit.‍‍‌‍‌‌‌‌‍‌‍‌‌‌‌‍‌‍‍..）公司服务方向（creative，research，analysis，branding，pr）和具体部门</p></li><li><p>若不确定行业/职能→重点写自己要做什么东西（岗位职能），eg. 我想进industry做研发→进什么方向的企业做什么方向的研发，地域也可以作为一个talking point。可以问问小蜜通常出来的学生都做啥。</p></li></ul><h3 id="4-写法-原因（怎么表现兴趣）："><a href="#4-写法-原因（怎么表现兴趣）：" class="headerlink" title="4. 写法/原因（怎么表现兴趣）："></a>4. 写法/原因（怎么表现兴趣）：</h3><ul><li><p>我解决了什么问题，产生了什么好处。</p></li><li><p>我对学科有很深的了解，知道它的魅力，困难，知道怎么去克服。</p></li><li><p>我有探索，有思考，eg我就想知道social media怎么评判，我做了XX调查/思考/分析（充实）。</p></li><li><p>展现整个过程：为什么产生问题，对这个问题又什么了解探索，过程中怎么思考，通过这个过程越来越明确坚定。</p></li></ul><h3 id="5-经历："><a href="#5-经历：" class="headerlink" title="5.经历："></a>5.经历：</h3><ul><li>我做的什么事，为什么这个项目/问题重要，我用了什么方法（为什么用这些方法），遇到了什么困难，怎么克服（是否克服），有什么思考，得到了什么变化（兴趣更坚定之类）。能不能让对你专业不太了解的能知道你做了什么为什么做，让同专业的认可你的成果。每段经历都差不多字数，有选择地讲（最能体现我能力的地方），不要把一个研究分几段写，不同的研究内容可以适当合并在一起。把重要的经历都写上，没有数量限制。不要流水账。不一定要和专业相关。</li></ul><h3 id="6-be-specific："><a href="#6-be-specific：" class="headerlink" title="6. be specific："></a>6. be specific：</h3><ul><li>eg. 我发现X在Y学科很重要→怎么重要，提高了我的研究能力→什么能力</li></ul><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><ul><li><p>such as：到底是什么，做了什么事情（how），what it is， what does it mean（自己问自己）</p><h3 id="8-be-strong："><a href="#8-be-strong：" class="headerlink" title="8. be strong："></a>8. be strong：</h3></li><li><p>主动语态＞被动语态。eg. was used, was obtained→we obtained, I realized…PS不要客观，而是强调‘我’的参与性，CV也是。</p></li><li>solution＞problem。强调解决过程。</li><li><p>wh‍‍‌‍‌‌‌‌‍‌‍‌‌‌‌‍‌‍‍at do you do next＞what do you think。理由同上。</p></li><li><ol start="9"><li>用积极替换消息。不要有‘我知道XXX地方不足“，改成’我会有兴趣地学习XXX”，我做了XXX，虽然影响了GPA，但是收获了XXX，同时其他方面表现了我的能力。不要强调自己多么苦多么惨多么多挑战，而是写成很享受过程。</li></ol></li><li><ol start="10"><li>选校理由：不要写很普遍的东西（比如as we all know…）不需要特别华丽的语言（NO PAIN, NO GAIN这种）。紧密结合所写的东西。选校理由不要千篇一律（位置好，学术好，排名好），不要太personal（男女朋友）。学校的课程设置怎么fit我，学校的课程设置很独特等。为什么喜欢教授，喜欢哪几个（XX的理论对自己印象深刻），我和学长/教授聊了，他们告诉我XXXimpress me，所以想来。</li></ol></li></ul><h3 id="布局："><a href="#布局：" class="headerlink" title="布局："></a>布局：</h3><pre><code>1. 故事型。说明自己的大成就。问题--不impressive，太naive。开头故事要concise。最初怎么感兴趣，做了什么探索，具体的规划，为什么选校。2. 单刀直入型。开头直接写我的兴趣，我的优势，我为什么选这个学校。3. 选择最有利的证据。抛掉水证据。</code></pre><h3 id="怎么评价："><a href="#怎么评价：" class="headerlink" title="怎么评价："></a>怎么评价：</h3><pre><code>1. 是不是每句话都清楚具体，语法上，专业上。2. 是不是回答了’三大问题‘3. 能不能展现我的特点4. 能不能给别人留下印象5. 思考有没有深度（文笔像小学生）6. 是否足够简洁（不要考虑语言是否华丽）推荐看Emily的PS修改建议和前后对比，看黄黄（版主）的ps</code></pre><h3 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h3><pre><code>1. 看要求，一般不超过1K字2. 不要写成流水账3. 英语表达&amp;专业术语4. 不要assume读者什么都不知道解释一大堆，尽量简洁5. 不要太emotional（去掉你的惊叹号），不要写别人的感受做法等，只写自己的6. 段落分配要合理</code></pre><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>科研经历不一定很match，关键体现你的思考方式等<br>不用自爆家门，什么学校什么专业<br>不用写你的论文名<br>不用写项目的全称<br>描述详细到’你想研究什么问题‘就可以了<br>如果是大方向的，要突出研究能力，可以扯一些体现相关性的东西<br>做了大比赛获得很多提高但是没获奖，还是要写，突出收获<br>实习经历不一定要写，看申请学校是否看重</p>]]></content>
    
    <summary type="html">
    
      小技巧
    
    </summary>
    
    
      <category term="Application" scheme="http://yoursite.com/tags/Application/"/>
    
  </entry>
  
</feed>
