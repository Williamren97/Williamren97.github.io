<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>REN WEI&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-26T16:05:06.554Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>William Ren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Array And String LEETCODE-100-DAY6</title>
    <link href="http://yoursite.com/2020/06/27/Array-And-String-LEETCODE-100-DAY6/"/>
    <id>http://yoursite.com/2020/06/27/Array-And-String-LEETCODE-100-DAY6/</id>
    <published>2020-06-26T16:05:06.000Z</published>
    <updated>2020-06-26T16:05:06.554Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Stack And String LEETCODE-100-DAY5</title>
    <link href="http://yoursite.com/2020/06/26/Stack-And-String-LEETCODE-100-DAY5/"/>
    <id>http://yoursite.com/2020/06/26/Stack-And-String-LEETCODE-100-DAY5/</id>
    <published>2020-06-26T03:13:53.000Z</published>
    <updated>2020-06-26T16:02:42.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">155. Min Stack</a></h1><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin(); // return -3</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();    // return 0</span><br><span class="line">minStack.getMin(); // return -2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><p>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=155 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [155] 最小栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">int</span> min;<span class="comment">//Integer比较的是范围，是地址，Interger类型之间的比较应该用equals()</span></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;<span class="comment">//初始化Min</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= min) &#123;</span><br><span class="line">            stack.push(min);</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">            stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.pop() == min) &#123;</span><br><span class="line">            min = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class MinStack &#123;</span></span><br><span class="line"><span class="comment">//     private Stack&lt;Integer&gt; stack;</span></span><br><span class="line"><span class="comment">//     private Stack&lt;Integer&gt; minStack;</span></span><br><span class="line"><span class="comment">//     /** initialize your data structure here. */</span></span><br><span class="line"><span class="comment">//     public MinStack() &#123;</span></span><br><span class="line"><span class="comment">//         stack = new Stack&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         minStack = new Stack&lt;&gt;();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public void push(int x) &#123;</span></span><br><span class="line"><span class="comment">//         stack.push(x);</span></span><br><span class="line"><span class="comment">//         if(!minStack.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//             int min = minStack.peek();</span></span><br><span class="line"><span class="comment">//             if(x &lt;= min) &#123;</span></span><br><span class="line"><span class="comment">//                 minStack.push(x); </span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             minStack.push(x);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public void pop() &#123;</span></span><br><span class="line"><span class="comment">//         int x = stack.pop();</span></span><br><span class="line"><span class="comment">//         if(!minStack.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//             if(x == minStack.peek()) &#123;</span></span><br><span class="line"><span class="comment">//                 minStack.pop();</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public int top() &#123;</span></span><br><span class="line"><span class="comment">//         return stack.peek();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public int getMin() &#123;</span></span><br><span class="line"><span class="comment">//         return minStack.peek();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232.Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232.Implement Queue using Stacks</a></h1><p>Implement the following operations of a queue using stacks.</p><ul><li>push(x) – Push element x to the back of queue.</li><li>pop() – Removes the element from in front of queue.</li><li>peek() – Get the front element.</li><li>empty() – Return whether the queue is empty.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  // returns 1</span><br><span class="line">queue.pop();   // returns 1</span><br><span class="line">queue.empty(); // returns false</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ul><li>You must use <em>only</em> standard operations of a stack – which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li><li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li><li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">没有的注释的为O(<span class="number">1</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue1</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1;</span><br><span class="line">    Stack&lt;Integer&gt; s2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Stack();</span><br><span class="line">        s2 = <span class="keyword">new</span> Stack();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//O(n)</span></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//s1代表没进行过处理的,queue的反方向，则S2代表处理过的。</span></span><br><span class="line">        <span class="keyword">if</span>(!s2.isEmpty()) <span class="keyword">return</span> s2.pop();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty()) s2.push(s1.pop());</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//O(n)</span></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s2.isEmpty()) <span class="keyword">return</span> s2.peek();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.isEmpty()) s2.push(s1.pop());</span><br><span class="line">            <span class="keyword">return</span> s2.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Methods 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue2</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1;</span><br><span class="line">    Stack&lt;Integer&gt; s2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Stack();</span><br><span class="line">        s2 = <span class="keyword">new</span> Stack();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="comment">//O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.isEmpty()) &#123;</span><br><span class="line">            front = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">            s2.push(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        s2.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!s2.isEmpty()) &#123;</span><br><span class="line">            s1.push(s2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//s1代表没进行过处理的,queue的反方向，则S2代表处理过的。</span></span><br><span class="line">        <span class="keyword">int</span> res = s1.pop();</span><br><span class="line">        <span class="keyword">if</span>(!s1.isEmpty()) &#123;</span><br><span class="line">            front = s1.peek();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. Implement Stack using Queues</a></h1><p>Implement the following operations of a stack using queues.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>empty() – Return whether the stack is empty.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyStack stack = new MyStack();</span><br><span class="line"></span><br><span class="line">stack.push(1);</span><br><span class="line">stack.push(2);  </span><br><span class="line">stack.top();   // returns 2</span><br><span class="line">stack.pop();   // returns 2</span><br><span class="line">stack.empty(); // returns false</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ul><li>You must use <em>only</em> standard operations of a queue – which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li><li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li><li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=225 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [225] 用队列实现栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//queue 4321</span></span><br><span class="line">    <span class="comment">//stack 1234</span></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前后开口，所以一个queue就可以实现</span></span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queue.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure><h1 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. Valid Parentheses</a></h1><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=20 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [20] 有效的括号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">//case1 ()[]&#123;&#125;</span></span><br><span class="line"><span class="comment">//stack: pop value is )</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack  = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>)</span><br><span class="line">                stack.push(<span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'&#123;'</span>)</span><br><span class="line">                stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c== <span class="string">'['</span>) </span><br><span class="line">                stack.push(<span class="string">']'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty() || c != stack.pop())<span class="comment">//当不为左括号时候，说明c是右括号，</span></span><br><span class="line">            <span class="comment">//stack.pop弹出栈元素中存储的右括号元素，比较这两个右括号是否相等。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())<span class="comment">//判断相对情况下的第一个字符是否为’），｝，】‘这种类型的。</span></span><br><span class="line">        <span class="comment">//当stack为空时输入一个c=）时，stack内没有（与之对应，则认为false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. Evaluate Reverse Polish Notation</a></h1><p>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank" rel="noopener">Reverse Polish Notation</a>.</p><p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p><p><strong>Note:</strong></p><ul><li>Division between two integers should truncate toward zero.</li><li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: (4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: </span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li><p>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + *</code>也可以依据次序计算出正确结果。</p></li><li><p><strong>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=150 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [150] 逆波兰表达式求值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">                stack.push(stack.pop() + stack.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = stack.pop();<span class="comment">//先pop出来的数是减数</span></span><br><span class="line">                <span class="keyword">int</span> b = stack.pop();</span><br><span class="line">                stack.push(b - a);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> b = stack.pop();</span><br><span class="line">                stack.push(b / a);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(Integer.parseInt(s));<span class="comment">//从String转为Int</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="224-Basic-Calculator"><a href="#224-Basic-Calculator" class="headerlink" title="224. Basic Calculator"></a><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="noopener">224. Basic Calculator</a></h1><p>Share</p><p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the plus <code>+</code> or minus sign <code>-</code>, <strong>non-negative</strong> integers and empty spaces <code></code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1 + 1&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot; 2-1 + 2 &quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>You may assume that the given expression is always valid.</li><li><strong>Do not</strong> use the <code>eval</code> built-in library function.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=224 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [224] 基本计算器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack  = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//判断当前是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//判断下一位是不是还是数字，case:123</span></span><br><span class="line">                <span class="keyword">while</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s.charAt(i + <span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                res += num * sign;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>) &#123;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'-'</span>) &#123;</span><br><span class="line">                sign = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="comment">//1 - 2可以看成 1 + (-2)</span></span><br><span class="line">                stack.push(res);</span><br><span class="line">                stack.push(sign);<span class="comment">//sign会先Pop出来</span></span><br><span class="line">                <span class="comment">//恢复到初始化状态</span></span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                res = res * stack.pop() + stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure><h1 id="161-One-Edit-Distance"><a href="#161-One-Edit-Distance" class="headerlink" title="161. One Edit Distance"></a><a href="https://leetcode.com/problems/one-edit-distance/" target="_blank" rel="noopener">161. One Edit Distance</a></h1><p>字符串<code>S</code>和<code>T</code>只差一个距离,返回<code>True</code>, 否则返回<code>False</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">case1:abcre Abere</span><br><span class="line"></span><br><span class="line">case2:abdc abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span>:<span class="number">3</span> abc abdc</span><br><span class="line"><span class="comment">//TIME O(n) Math.min(s,length(), t.length());</span></span><br><span class="line"><span class="comment">//Space:O(1) 因为substring虽然是O(n)，但是只在return时候调用一次。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOneEditDistance</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//case 1:找到第一个不同，让越过去，判断后面是否相同</span></span><br><span class="line">  <span class="comment">//如果两个长度不等，取长的会越界，所以用Math.min()</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(s,length(), t.length()); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) != t.charAt(i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.length() == t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(i + <span class="number">1</span>).equals(t.substring(i + <span class="number">1</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.length() &gt; t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(i + <span class="number">1</span>).equals(t.substring(i));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.substring(i + <span class="number">1</span>).equals(s.substring(i));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// abc和abcdef,在这里判断是不是只多1个，还是多了几个</span></span><br><span class="line">    <span class="keyword">return</span> Math.abs(s.length() - t.length()) == <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="168-Excel-Sheet-Column-Title"><a href="#168-Excel-Sheet-Column-Title" class="headerlink" title="168. Excel Sheet Column Title"></a><a href="https://leetcode.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">168. Excel Sheet Column Title</a></h1><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;A&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 28</span><br><span class="line">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 701</span><br><span class="line">Output: &quot;ZY&quot;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=168 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [168] Excel表列名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">// 26Z 27AA 28AB,这里是对26的一个循环， 用%26+ 'A'算, 在26之后用/的方法</span></span><br><span class="line"><span class="comment">//time O(n) logN因为是/26</span></span><br><span class="line"><span class="comment">// Space O(n) 对应n，每次加一个字母</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n--;<span class="comment">//28 % 26 =  2 + 'A' = 2 + 1 = 3 = 'C',所以Index要从0开始，但是这里对应的是A=1</span></span><br><span class="line">            sb.append((<span class="keyword">char</span>)(<span class="string">'A'</span> + n % <span class="number">26</span>));</span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();<span class="comment">//得到的结果是反过来的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure><h1 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171. Excel Sheet Column Number"></a><a href="https://leetcode.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">171. Excel Sheet Column Number</a></h1><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;A&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AB&quot;</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ZY&quot;</span><br><span class="line">Output: 701</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=171 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [171] Excel表列序号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            res = res * <span class="number">26</span> + (s.charAt(i) - <span class="string">'A'</span> + <span class="number">1</span>);<span class="comment">//A对应的是1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure><h1 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38. Count and Say"></a><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">38. Count and Say</a></h1><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure><p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p><p>Given an integer <em>n</em> where 1 ≤ <em>n</em> ≤ 30, generate the <em>n</em>th term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.</p><p>Note: Each term of the sequence of integers will be represented as a string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: This is the base case.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;1211&quot;</span><br><span class="line">Explanation: For n = 3 the term was &quot;21&quot; in which we have two groups &quot;2&quot; and &quot;1&quot;, &quot;2&quot; can be read as &quot;12&quot; which means frequency = 1 and value = 2, the same way &quot;1&quot; is read as &quot;11&quot;, so the answer is the concatenation of &quot;12&quot; and &quot;11&quot; which is &quot;1211&quot;.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=38 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [38] 外观数列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解题思路：</span></span><br><span class="line"><span class="comment">     * 本题的难点在于：报数的概念理解，至少我从题意中没有很清晰的理解，但是感觉像是个递推式</span></span><br><span class="line"><span class="comment">     * 从4-&gt;5分析，将4个每一位拆开看（个数+数字），4=1211 =&gt; 1=11，2=12，11=21，所以5=111221</span></span><br><span class="line"><span class="comment">     * 所以解题用循环，从1-&gt;n可求解出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">char</span> pre = str.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = str.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (c == pre) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    builder.append(count).append(pre);</span><br><span class="line">                    pre = c;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            builder.append(count).append(pre);</span><br><span class="line">            str = builder.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;155-Min-Stack&quot;&gt;&lt;a href=&quot;#155-Min-Stack&quot; class=&quot;headerlink&quot; title=&quot;155. Min Stack&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/min-sta
      
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Sorting And Array LEETCODE-100-DAY4</title>
    <link href="http://yoursite.com/2020/06/25/Sorting-And-Array-LEETCODE-100-DAY4/"/>
    <id>http://yoursite.com/2020/06/25/Sorting-And-Array-LEETCODE-100-DAY4/</id>
    <published>2020-06-25T06:49:23.000Z</published>
    <updated>2020-06-26T03:13:09.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">75. Sort Colors</a></h1><p>Given an array with <em>n</em> objects colored red, white or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><ul><li>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</li><li>Could you come up with a one-pass algorithm using only constant space?</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//left控制0最后出现的位置，right控制1最开始出现的位置（倒序）</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, index++, left++);<span class="comment">//原地交换</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[index] == <span class="number">1</span>) &#123;</span><br><span class="line">                index++;<span class="comment">//不动</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(nums, index, right--);<span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. Merge Sorted Array</a></h1><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p><p><strong>Note:</strong></p><ul><li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li><li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//nums1和2都是排过序的，从后向前放，最大的放在最后</span></span><br><span class="line">            nums1[k--] = nums1[i] &gt;= nums2[j] ? nums1[i--] : nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">            <span class="comment">//i到极限，但是j还有剩余</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="189. Rotate Array"></a><a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">189. Rotate Array</a></h1><p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p><p><strong>Follow up:</strong></p><ul><li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li><li>Could you do it in-place with O(1) extra space?</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,-100,3,99], k = 2</span><br><span class="line">Output: [3,99,-1,-100]</span><br><span class="line">Explanation: </span><br><span class="line">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class="line">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li>It’s guaranteed that <code>nums[i]</code> fits in a 32 bit-signed integer.</li><li><code>k &gt;= 0</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time O(n)，虽然三次翻转，但是没有累乘的操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//三次翻转</span></span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);<span class="comment">//整体翻转</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);<span class="comment">//翻转前k</span></span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);<span class="comment">//翻转剩下的n - k</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start++] = nums[end];</span><br><span class="line">            nums[end--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public void rotate(int[] nums, int k) &#123;</span></span><br><span class="line"><span class="comment">//         int[] temp = new int[nums.length];</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//             //如果K = 10，轮了一圈再往前轮三个，大于nums.length, 一开始i = 0, k = 3,把i当前的数给三这个位置</span></span><br><span class="line"><span class="comment">//             //[1 ,2, 3, 4, 5, 6, 7]，因为0 + 3 % 7 = 3</span></span><br><span class="line"><span class="comment">//             //          1</span></span><br><span class="line"><span class="comment">//             temp[(i + k) % nums.length] = nums[i];</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         //返回的是空，所以在原有的基础上操作，重新赋值</span></span><br><span class="line"><span class="comment">//         //上面得到的结果存在temp里，要重新赋值</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//             nums[i] = temp[i];</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h1 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. First Missing Positive</a></h1><p>Given an unsorted integer array, find the smallest missing positive integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>Your algorithm should run in <em>O</em>(<em>n</em>) time and uses constant extra space.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bucket Sort</span></span><br><span class="line"><span class="comment">// [1 ,2, 0] index + 1</span></span><br><span class="line"><span class="comment">// [3, 4, -1, 1] 判断数是否大于0</span></span><br><span class="line"><span class="comment">// [1, 99, 3, 4]太大 </span></span><br><span class="line"><span class="comment">// nums[nums[i] - 1] != nums[i] [3, 4, 1, 3] i = 0 nums[0] = 3,</span></span><br><span class="line"><span class="comment">// nums[nums[i] - 1]就是当前的数应该放在的位置上 nums[0] = 3 - 1 = 2 -&gt; nums[2]= -1 != nums[i]=3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//输出的是最小的正整数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//这里是while,不是if [3, 1, 4, -1],if是单次</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums.length &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;75-Sort-Colors&quot;&gt;&lt;a href=&quot;#75-Sort-Colors&quot; class=&quot;headerlink&quot; title=&quot;75. Sort Colors&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/sort
      
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Bitwise And Array LEETCODE-100-DAY3</title>
    <link href="http://yoursite.com/2020/06/24/Bitwise-And-Array-LEETCODE-100-DAY3/"/>
    <id>http://yoursite.com/2020/06/24/Bitwise-And-Array-LEETCODE-100-DAY3/</id>
    <published>2020-06-24T06:34:14.000Z</published>
    <updated>2020-06-24T12:19:08.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">66. Plus One</a></h1><p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p><p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p><p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//case1 1011 1012</span></span><br><span class="line"><span class="comment">//case2 1099 1100</span></span><br><span class="line"><span class="comment">//case3 9999 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//time : O(n)</span></span><br><span class="line"><span class="comment">//space : O(n)在最后开辟了一个新的数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length == <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//case 1</span></span><br><span class="line">            <span class="keyword">if</span>(digits[i] &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//case2</span></span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//case 3</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">136. Single Number</a></h1><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p><p><strong>Note:</strong></p><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="🐘异或-相同为0-不同为1"><a href="#🐘异或-相同为0-不同为1" class="headerlink" title="🐘异或:相同为0,不同为1"></a>🐘异或:相同为0,不同为1</h1><h1 id="389-Find-The-Difference"><a href="#389-Find-The-Difference" class="headerlink" title="389. Find The Difference"></a><a href="https://leetcode.com/problems/find-the-difference/" target="_blank" rel="noopener">389. Find The Difference</a></h1><p>Given two strings <strong><em>s\</em></strong> and <strong><em>t\</em></strong> which consist of only lowercase letters.</p><p>String <strong><em>t\</em></strong> is generated by random shuffling string <strong><em>s\</em></strong> and then add one more letter at a random position.</p><p>Find the letter that was added in <strong><em>t\</em></strong>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;abcd&quot;</span><br><span class="line">t = &quot;abcde&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">e</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&apos;e&apos; is the letter that was added.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//性质：4与6进行异或的结果,再与4进行异或,得到了6.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//t的长度比s长，所以直接取t的最后一位</span></span><br><span class="line">        <span class="keyword">char</span> c = t.charAt(t.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            c ^= s.charAt(i);</span><br><span class="line">            c ^= t.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性质（1）：4与6进行异或的结果-再与4进行异或-得到了6"><a href="#性质（1）：4与6进行异或的结果-再与4进行异或-得到了6" class="headerlink" title="性质（1）：4与6进行异或的结果,再与4进行异或,得到了6."></a>性质（1）：4与6进行异或的结果,再与4进行异或,得到了6.</h2><h1 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="191. Number of 1 Bits"></a><a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. Number of 1 Bits</a></h1><p>Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 00000000000000000000000000001011</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The input binary string 00000000000000000000000000001011 has a total of three &apos;1&apos; bits.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 00000000000000000000000010000000</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The input binary string 00000000000000000000000010000000 has a total of one &apos;1&apos; bit.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 11111111111111111111111111111101</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &apos;1&apos; bits.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.</li><li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement" target="_blank" rel="noopener">2’s complement notation</a>. Therefore, in <strong>Example 3</strong> above the input represents the signed integer <code>-3</code>.</li></ul><p><strong>Follow up</strong>:</p><p>If this function is called many times, how would you optimize it?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp,前N个数的和就是它的DP值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">             dp[i] = nums[i] + (dp[i - <span class="number">1</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>]);</span><br><span class="line">             res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     //dp,前N个数的和就是它的DP值</span></span><br><span class="line"><span class="comment">//     public int maxSubArray(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">//         int[] dp = new int[nums.length];</span></span><br><span class="line"><span class="comment">//         dp[0] = nums[0];</span></span><br><span class="line"><span class="comment">//         int res = nums[0];</span></span><br><span class="line"><span class="comment">//         for(int i = 1; i &lt; nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//              dp[i] = nums[i] + (dp[i - 1] &lt; 0 ? 0 : dp[i - 1]);</span></span><br><span class="line"><span class="comment">//              res = Math.max(res, dp[i]);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="性质（2）n-amp-n-1-将n的二进制表示中的最低位为1的改成0（在这里注意重复操作）"><a href="#性质（2）n-amp-n-1-将n的二进制表示中的最低位为1的改成0（在这里注意重复操作）" class="headerlink" title="性质（2）n&amp;(n-1):将n的二进制表示中的最低位为1的改成0（在这里注意重复操作）"></a>性质（2）n&amp;(n-1):将n的二进制表示中的最低位为1的改成0（在这里注意重复操作）</h2><h1 id="231-Power-of-Two"><a href="#231-Power-of-Two" class="headerlink" title="231. Power of Two"></a><a href="https://leetcode.com/problems/power-of-two/" target="_blank" rel="noopener">231. Power of Two</a></h1><p>Given an integer, write a function to determine if it is a power of two.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: true </span><br><span class="line">Explanation: 20 = 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 24 = 16</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 218</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 : 10</span></span><br><span class="line"><span class="comment">// 4 : 100</span></span><br><span class="line"><span class="comment">// 8 : 1000</span></span><br><span class="line"><span class="comment">// 16: 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// n : 16 10000</span></span><br><span class="line"><span class="comment">// n - 1 : 01111</span></span><br><span class="line"><span class="comment">//如果与的结果都为0,那么就是2的次方倍</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; ((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190. Reverse Bits"></a><a href="https://leetcode.com/problems/reverse-bits/" target="_blank" rel="noopener">190. Reverse Bits</a></h1><p>Reverse bits of a given 32 bits unsigned integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 00000010100101000001111010011100</span><br><span class="line">Output: 00111001011110000010100101000000</span><br><span class="line">Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 11111111111111111111111111111101</span><br><span class="line">Output: 10111111111111111111111111111111</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.</li><li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement" target="_blank" rel="noopener">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li></ul><p><strong>Follow up</strong>:</p><p>If this function is called many times, how would you optimize it?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1011 右移变成0101</span></span><br><span class="line"><span class="comment">// 0001</span></span><br><span class="line"><span class="comment">//    1</span></span><br><span class="line"><span class="comment">// res = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果是偶数，为0，并且判断最低位是不是1</span></span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) res++;</span><br><span class="line">            <span class="comment">// 1011 右移变成0101</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a><a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">27. Remove Element</a></h1><p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure><p><strong>Clarification:</strong></p><p>Confused why the returned value is an integer but your answer is an array?</p><p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p><p>Internally you can think of this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在List中是相等，在Array中是不等</span></span><br><span class="line"><span class="comment">//双指针法：一个从前向后扫，一个记录结果，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果和val相等，i向前走，r不变</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val) &#123;</span><br><span class="line">                nums[res++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public int removeElement(int[] nums, int val) &#123;</span></span><br><span class="line"><span class="comment">//         int ans = 0;</span></span><br><span class="line"><span class="comment">//         for(int num: nums) &#123;</span></span><br><span class="line"><span class="comment">//             if(num != val) &#123;</span></span><br><span class="line"><span class="comment">//                 nums[ans] = num;</span></span><br><span class="line"><span class="comment">//                 ans++;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return ans;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public int removeElement(int[] nums, int val) &#123;</span></span><br><span class="line"><span class="comment">//         int i  = 0;</span></span><br><span class="line"><span class="comment">//         for (int j = 0; j &lt; nums.length; ++j) &#123;</span></span><br><span class="line"><span class="comment">//             if (nums[j] != val) &#123;</span></span><br><span class="line"><span class="comment">//                 nums[i] = nums[j];</span></span><br><span class="line"><span class="comment">//                 i++;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return i;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h1 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. Remove Duplicates from Sorted Array</a></h1><p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure><p><strong>Clarification:</strong></p><p>Confused why the returned value is an integer but your answer is an array?</p><p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p><p>Internally you can think of this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一个数一定被保持，</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="comment">//如果相同,那么count不变,i++</span></span><br><span class="line">                nums[count++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public int removeDuplicates(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">//         if (nums == null || nums.length == 0) return 0;</span></span><br><span class="line"><span class="comment">//         int i = 0;</span></span><br><span class="line"><span class="comment">//         for (int j = 1; j &lt; nums.length; ++j) &#123;</span></span><br><span class="line"><span class="comment">//             if (nums[j] != nums[i]) &#123;</span></span><br><span class="line"><span class="comment">//                 i++;</span></span><br><span class="line"><span class="comment">//                 nums[i] = nums[j];</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return i + 1;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> * [<span class="number">80</span>] 删除排序数组中的重复项 II</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[count - <span class="number">2</span>])&#123;</span><br><span class="line">                nums[count++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> * [<span class="number">83</span>] 删除排序链表中的重复元素</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;<span class="comment">// movre forward when do not have replcaited item;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. Maximum Subarray</a></h1><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp,前N个数的和就是它的DP值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">             dp[i] = nums[i] + (dp[i - <span class="number">1</span>] &lt; <span class="number">0</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>]);</span><br><span class="line">             res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;66-Plus-One&quot;&gt;&lt;a href=&quot;#66-Plus-One&quot; class=&quot;headerlink&quot; title=&quot;66. Plus One&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/plus-one/&quot; ta
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>String-LEETCODE-100-DAY2</title>
    <link href="http://yoursite.com/2020/06/23/String-LEETCODE-100-DAY2/"/>
    <id>http://yoursite.com/2020/06/23/String-LEETCODE-100-DAY2/</id>
    <published>2020-06-23T03:25:12.000Z</published>
    <updated>2020-06-24T06:31:15.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="186-reverse-words-in-a-string-ii"><a href="#186-reverse-words-in-a-string-ii" class="headerlink" title="186.reverse-words-in-a-string-ii)"></a><a href="https://leetcode.com/problems/reverse-words-in-a-string-ii/" target="_blank" rel="noopener">186.reverse-words-in-a-string-ii)</a></h1><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度为<code>O(n)</code>，因为整体遍历和单个单词遍历的的复杂度都为n，<code>r</code>从0走到最右的复杂度也是n，这样就是3n的复杂度，忽略指数，即可得到<code>O(n)</code></li><li>空间复杂度为<code>O(1)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先整体翻转，然后使用双指针法，将r指向单词后的空格部分，再逐一翻转单词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        reverse(s, <span class="number">0</span>, s.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; s.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = r;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; s.length &amp;&amp; s[r] != <span class="string">' '</span>) &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//因为r在空格上，所以要删除单词的话，就要前进一格。</span></span><br><span class="line">            reverse(s, l, r - <span class="number">1</span>);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s[i];</span><br><span class="line">            s[i++] = s[j];</span><br><span class="line">            s[j--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a><a href="https://leetcode.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. Reverse Words in a String</a></h1><h6 id="trim去掉前后空格-split-中的-s指所有的空格回车-指有一个或者多个"><a href="#trim去掉前后空格-split-中的-s指所有的空格回车-指有一个或者多个" class="headerlink" title="trim去掉前后空格,split 中的\\s指所有的空格回车,+指有一个或者多个"></a><code>trim</code>去掉前后空格,<code>split</code> 中的<code>\\s</code>指所有的空格回车,<code>+</code>指有一个或者多个</h6><p>Given an input string, reverse the string word by word.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;the sky is blue&quot;</span><br><span class="line">Output: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;  hello world!  &quot;</span><br><span class="line">Output: &quot;world! hello&quot;</span><br><span class="line">Explanation: Your reversed string should not contain leading or trailing spaces.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;a good   example&quot;</span><br><span class="line">Output: &quot;example good a&quot;</span><br><span class="line">Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>A word is defined as a sequence of non-space characters.</li><li>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</li><li>You need to reduce multiple spaces between two words to a single space in the reversed string.</li></ul><p><strong>Follow up:</strong></p><p>For C programmers, try to solve it <em>in-place</em> in <em>O</em>(1) extra space.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] words = s.trim().split(<span class="string">"\\s+"</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = words.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sb.append(words[i] + <span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"><span class="comment">// //先整体翻转，然后使用双指针法，将r指向单词后的空格部分，再逐一翻转单词</span></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public String reverseWords(char[] s) &#123;</span></span><br><span class="line"><span class="comment">//         reverse(s, 0, s.length - 1);</span></span><br><span class="line"><span class="comment">//         int r = 0;</span></span><br><span class="line"><span class="comment">//         while (r &lt; s.length) &#123;</span></span><br><span class="line"><span class="comment">//             int l = r;</span></span><br><span class="line"><span class="comment">//             while (r &lt; s.length &amp;&amp; s[r] != ' ') &#123;</span></span><br><span class="line"><span class="comment">//                 r++;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             //因为r在空格上，所以要删除单词的话，就要前进一格。</span></span><br><span class="line"><span class="comment">//             reverse(s, l, r - 1);</span></span><br><span class="line"><span class="comment">//             r++;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     public void reverse(char[] s, int i, int j) &#123;</span></span><br><span class="line"><span class="comment">//         while (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//             char temp = s[i];</span></span><br><span class="line"><span class="comment">//             s[i++] = s[j];</span></span><br><span class="line"><span class="comment">//             s[j--] = temp;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h1 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345. Reverse Vowels of a String"></a><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. Reverse Vowels of a String</a></h1><p>Write a function that takes a string as input and reverse only the vowels of a string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;hello&quot;</span><br><span class="line">Output: &quot;holle&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;leetcode&quot;</span><br><span class="line">Output: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>The vowels does not include the letter “y”.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        String vowel = <span class="string">"aeiouAEIOU"</span>;</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//如果找不到，就前进</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; vowel.indexOf(str[left]) == -<span class="number">1</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; vowel.indexOf(str[right]) == -<span class="number">1</span>) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> temp = str[left];</span><br><span class="line">            str[left++] = str[right];</span><br><span class="line">            str[right--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13.Roman to Integer"></a><a href="https://cspiration.com/course/video?id=2679" target="_blank" rel="noopener">13.Roman to Integer</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先将所有的组合可能性列出并添加到哈希表中</span></span><br><span class="line"><span class="comment">// 然后对字符串进行遍历，由于组合只有两种，一种是 1 个字符，一种是 2 个字符，其中 2 个字符优先于 1 个字符</span></span><br><span class="line"><span class="comment">// 先判断两个字符的组合在哈希表中是否存在，存在则将值取出加到结果 ans 中，并向后移2个字符。不存在则将判断当前 1 个字符是否存在，存在则将值取出加到结果 ans 中，并向后移 1 个字符</span></span><br><span class="line"><span class="comment">// 遍历结束返回结果 ans</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"I"</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">"IV"</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">"V"</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">"IX"</span>, <span class="number">9</span>);</span><br><span class="line">        map.put(<span class="string">"X"</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">"XL"</span>, <span class="number">40</span>);</span><br><span class="line">        map.put(<span class="string">"L"</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">"XC"</span>, <span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">"C"</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">"CD"</span>, <span class="number">400</span>);</span><br><span class="line">        map.put(<span class="string">"D"</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">"CM"</span>, <span class="number">900</span>);</span><br><span class="line">        map.put(<span class="string">"M"</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; map.containsKey(s.substring(i, i+<span class="number">2</span>))) &#123;</span><br><span class="line">                ans += map.get(s.substring(i, i+<span class="number">2</span>));</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += map.get(s.substring(i, i+<span class="number">1</span>));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a><a href="https://cspiration.com/course/video?id=2680" target="_blank" rel="noopener">12. Integer to Roman</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;    </span><br><span class="line">        String[] strs = &#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= values[i]) &#123;</span><br><span class="line">                num -= values[i];</span><br><span class="line">                sb.append(strs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="273-Integer-to-English-Words"><a href="#273-Integer-to-English-Words" class="headerlink" title="273. Integer to English Words"></a><a href="https://cspiration.com/course/video?id=2681" target="_blank" rel="noopener">273. Integer to English Words</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String[] less20 = &#123;<span class="string">""</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>, <span class="string">"Four"</span>, <span class="string">"Five"</span>, <span class="string">"Six"</span>, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>, <span class="string">"Ten"</span>, <span class="string">"Eleven"</span>, <span class="string">"Twelve"</span>, <span class="string">"Thirteen"</span>, <span class="string">"Fourteen"</span>, <span class="string">"Fifteen"</span>, <span class="string">"Sixteen"</span>, <span class="string">"Seventeen"</span>, <span class="string">"Eighteen"</span>, <span class="string">"Nineteen"</span>&#125;;</span><br><span class="line">    String[] tens = &#123;<span class="string">""</span>, <span class="string">"Ten"</span>, <span class="string">"Twenty"</span>, <span class="string">"Thirty"</span>, <span class="string">"Forty"</span>, <span class="string">"Fifty"</span>, <span class="string">"Sixty"</span>, <span class="string">"Seventy"</span>, <span class="string">"Eighty"</span>, <span class="string">"Ninety"</span>&#125;;</span><br><span class="line">    String[] thousands  = &#123;<span class="string">""</span>, <span class="string">"Thousand"</span>, <span class="string">"Million"</span>, <span class="string">"Billion"</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Zero"</span>;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">1000</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = helper(num % <span class="number">1000</span>)+ thousands[i] + <span class="string">" "</span> + res;</span><br><span class="line">            &#125;</span><br><span class="line">            num /= <span class="number">1000</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.trim();          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helper</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> less20[num % <span class="number">20</span>] + <span class="string">" "</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tens[num / <span class="number">10</span>] + <span class="string">" "</span> + helper(num % <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> less20[num / <span class="number">100</span>] + <span class="string">" Hundred "</span> + helper(num % <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1.Two Sum"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1.Two Sum</a></h1><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong><em>exactly\</em></strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(complement), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; nums.length; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = i + 1; j &lt; nums.length; ++j) &#123;</span></span><br><span class="line">        <span class="comment">//         if (nums[j] == target - nums[i]) &#123;</span></span><br><span class="line">        <span class="comment">//             return new int[] &#123;i, j&#125;;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// throw new IllegalArgumentException("No solution");</span></span><br></pre></td></tr></table></figure><h1 id="15-Three-Sum"><a href="#15-Three-Sum" class="headerlink" title="15.Three Sum"></a><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">15.Three Sum</a></h1><p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong></p><p>The solution set must not contain duplicate triplets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Arrays.sort(nums);<span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">int</span> L = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++;<span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) R--;<span class="comment">// 去重</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 3Sum Closest</a></h1><p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,2,1,-4], target = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><p><code>3 &lt;= nums.length &lt;= 10^3</code></p></li><li><p><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></p></li><li><p><code>-10^4 &lt;= target &lt;= 10^4</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">//只有在从小到大排序后，才能移动left和right（因为排序是为了去重）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[nums.length - <span class="number">1</span>];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = i + <span class="number">1</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[start] + nums[end];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(sum - target) &lt; Math.abs(res - target)) &#123;</span><br><span class="line">                    <span class="comment">//绝对值偏小,说明更接近</span></span><br><span class="line">                    res = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="18-4-Sum"><a href="#18-4-Sum" class="headerlink" title="18. 4 Sum"></a><a href="https://leetcode.com/problems/4sum/" target="_blank" rel="noopener">18. 4 Sum</a></h1><p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p><p><strong>Note:</strong></p><p>The solution set must not contain duplicate quadruplets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="comment">/*定义一个返回值*/</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/*当数组为null或元素小于4个时，直接返回*/</span></span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*对数组进行从小到大排序*/</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">/*数组长度*/</span></span><br><span class="line">        <span class="keyword">int</span> length=nums.length;</span><br><span class="line">        <span class="comment">/*定义4个指针k，i，j，h  k从0开始遍历，i从k+1开始遍历，留下j和h，j指向i+1，h指向数组最大值*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;length-<span class="number">3</span>;k++)&#123;</span><br><span class="line">            <span class="comment">/*当k的值与前面的值相等时忽略*/</span></span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;nums[k]==nums[k-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*获取当前最小值，如果最小值比目标值大，说明后面越来越大的值根本没戏*/</span></span><br><span class="line">            <span class="keyword">int</span> min1=nums[k]+nums[k+<span class="number">1</span>]+nums[k+<span class="number">2</span>]+nums[k+<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(min1&gt;target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*获取当前最大值，如果最大值比目标值小，说明后面越来越小的值根本没戏，忽略*/</span></span><br><span class="line">            <span class="keyword">int</span> max1=nums[k]+nums[length-<span class="number">1</span>]+nums[length-<span class="number">2</span>]+nums[length-<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(max1&lt;target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*第二层循环i，初始值指向k+1*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="comment">/*当i的值与前面的值相等时忽略*/</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;k+<span class="number">1</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*定义指针j指向i+1*/</span></span><br><span class="line">                <span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">/*定义指针h指向数组末尾*/</span></span><br><span class="line">                <span class="keyword">int</span> h=length-<span class="number">1</span>;</span><br><span class="line">                <span class="comment">/*获取当前最小值，如果最小值比目标值大，说明后面越来越大的值根本没戏，忽略*/</span></span><br><span class="line">                <span class="keyword">int</span> min=nums[k]+nums[i]+nums[j]+nums[j+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(min&gt;target)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*获取当前最大值，如果最大值比目标值小，说明后面越来越小的值根本没戏，忽略*/</span></span><br><span class="line">                <span class="keyword">int</span> max=nums[k]+nums[i]+nums[h]+nums[h-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(max&lt;target)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*开始j指针和h指针的表演，计算当前和，如果等于目标值，j++并去重，h--并去重，当当前和大于目标值时h--，当当前和小于目标值时j++*/</span></span><br><span class="line">                <span class="keyword">while</span> (j&lt;h)&#123;</span><br><span class="line">                    <span class="keyword">int</span> curr=nums[k]+nums[i]+nums[j]+nums[h];</span><br><span class="line">                    <span class="keyword">if</span>(curr==target)&#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[k],nums[i],nums[j],nums[h]));</span><br><span class="line">                        j++;</span><br><span class="line">                        <span class="keyword">while</span>(j&lt;h&amp;&amp;nums[j]==nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                            j++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        h--;</span><br><span class="line">                        <span class="keyword">while</span>(j&lt;h&amp;&amp;i&lt;h&amp;&amp;nums[h]==nums[h+<span class="number">1</span>])&#123;</span><br><span class="line">                            h--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr&gt;target)&#123;</span><br><span class="line">                        h--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                       j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">242. Valid Anagram</a></h1><p>Given two strings <em>s</em> and <em>t</em> , write a function to determine if <em>t</em> is an anagram of <em>s</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p><p><strong>Follow up:</strong><br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            count[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            count[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a><a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">49. Group Anagrams</a></h1><p>Given an array of strings, group anagrams together.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>All inputs will be in lowercase.</li><li>The order of your output does not matter.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=49 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [49] 字母异位词分组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">//time:O（m + n） m:strs长度 n:strs中最大String的长度</span></span><br><span class="line"><span class="comment">//space: O（n）级别</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="comment">//counting为key, 字符串为value</span></span><br><span class="line">        <span class="comment">//讲aabbc和ababc存入a2b2c1</span></span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : strs) &#123;</span><br><span class="line">            <span class="comment">//对当前的单个单词进行counting sort</span></span><br><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(Character ch : str.toCharArray()) &#123;</span><br><span class="line">                count[ch - <span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置基准</span></span><br><span class="line">            String s = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">                <span class="comment">//等于0，说明字母没有出现，在这里只数出现过的字母</span></span><br><span class="line">                <span class="keyword">if</span>(count[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//valueOf将字母出现的次数从Int型转换成String类型</span></span><br><span class="line">                    s += String.valueOf(count[i]) + String.valueOf((<span class="keyword">char</span>)(i + <span class="string">'a'</span>));</span><br><span class="line">                    <span class="comment">//之前减去a,现在加上a，就恢复到了a</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">                <span class="comment">//如果已经包含了，就取出来，然后加进去</span></span><br><span class="line">                List&lt;String&gt; list = map.get(s);</span><br><span class="line">                list.add(str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果第一次出现</span></span><br><span class="line">                List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//初始化List</span></span><br><span class="line">                list.add(str);<span class="comment">//将2a2b1c和aabbc加入到list中</span></span><br><span class="line">                map.put(s, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure><h1 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. Longest Common Prefix</a></h1><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>All given inputs are in lowercase letters <code>a-z</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=14 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [14] 最长公共前缀</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String ans = strs[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(;j &lt; ans.length() &amp;&amp; j &lt; strs[i].length();j++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(ans.charAt(j) != strs[i].charAt(j))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           ans = ans.substring(<span class="number">0</span>, j);</span><br><span class="line">           <span class="keyword">if</span>(ans.equals(<span class="string">""</span>))</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">       &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;186-reverse-words-in-a-string-ii&quot;&gt;&lt;a href=&quot;#186-reverse-words-in-a-string-ii&quot; class=&quot;headerlink&quot; title=&quot;186.reverse-words-in-a-strin
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search and LinkedList LEETCODE 100 DAY1</title>
    <link href="http://yoursite.com/2020/06/22/Binary-Search-and-LinkedList-LEETCODE-100-DAY1/"/>
    <id>http://yoursite.com/2020/06/22/Binary-Search-and-LinkedList-LEETCODE-100-DAY1/</id>
    <published>2020-06-22T01:52:34.000Z</published>
    <updated>2020-06-23T01:17:03.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="74-Search-a-2D-Matrix"><a href="#74-Search-a-2D-Matrix" class="headerlink" title="74. Search a 2D Matrix"></a><a href="https://leetcode.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. Search a 2D Matrix</a></h1><p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted from left to right.</li><li>The first integer of each row is greater than the last integer of the previous row.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = row * col - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> value = matrix[mid / col][mid % col]; </span><br><span class="line">            <span class="keyword">if</span> (value == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; target) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240.Search a 2D Matrix II"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240.Search a 2D Matrix II</a></h1><p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p><strong>Example:</strong></p><p>Consider the following matrix:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Given target = <code>5</code>, return <code>true</code>.</p><p>Given target = <code>20</code>, return <code>false</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (col &gt;= <span class="number">0</span> &amp;&amp; row &lt;= matrix.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[row][col]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[row][col]) &#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener">35. Search Insert Position</a></h1><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，插入位置有可能在数组的末尾（题目中的示例 3），需要单独判断；</span></span><br><span class="line"><span class="comment">// 其次，如果待插入元素比最后一个元素严格小，并且在这个数组中有和插入元素一样的元素，返回任意一个位置即可；</span></span><br><span class="line"><span class="comment">// 否则，插入的位置应该是严格大于 target 的第 1 个元素的位置。</span></span><br><span class="line"><span class="comment">//因此，严格小于 target 的元素一定不是解，根据这个思路，可以写出如下代码。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 严格小于 target 的元素一定不是解</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="374-Guess-Number-Higher-or-Lower-https-leetcode-com-problems-guess-number-higher-or-lower"><a href="#374-Guess-Number-Higher-or-Lower-https-leetcode-com-problems-guess-number-higher-or-lower" class="headerlink" title="[374. Guess Number Higher or Lower]https://leetcode.com/problems/guess-number-higher-or-lower/"></a>[374. Guess Number Higher or Lower]<a href="https://leetcode.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">https://leetcode.com/problems/guess-number-higher-or-lower/</a></h1><p>We are playing the Guess Game. The game is as follows:</p><p>I pick a number from <strong>1</strong> to <strong><em>n\</em></strong>. You have to guess which number I picked.</p><p>Every time you guess wrong, I’ll tell you whether the number is higher or lower.</p><p>You call a pre-defined API <code>guess(int num)</code> which returns 3 possible results (<code>-1</code>, <code>1</code>, or <code>0</code>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 : My number is lower</span><br><span class="line"> 1 : My number is higher</span><br><span class="line"> 0 : Congrats! You got it!</span><br></pre></td></tr></table></figure><p><strong>Example :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 10, pick = 6</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> guessNum = guess(mid);</span><br><span class="line">            <span class="keyword">if</span> (guessNum == -<span class="number">1</span>) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;<span class="comment">// 中位数比猜的数大，因此比中位数大的数包括中位数都不是目标元素</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="278-First-Bad-Version"><a href="#278-First-Bad-Version" class="headerlink" title="278. First Bad Version"></a><a href="https://leetcode.com/problems/first-bad-version/" target="_blank" rel="noopener">278. First Bad Version</a></h1><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given n = 5, and version = 4 is the first bad version.</span><br><span class="line"></span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;               </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. Find First and Last Position of Element in Sorted Array</a></h1><p>Given an array of integers <code>nums</code> sorted in ascending order, find the starting and ending position of a given <code>target</code> value.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><p>If the target is not found in the array, return <code>[-1, -1]</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> start = findFirst(nums, target);</span><br><span class="line">        <span class="keyword">if</span>(start == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> end = findLast(nums, target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == target) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">if</span>(nums[end] == target) <span class="keyword">return</span> end;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLast</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[end] == target) <span class="keyword">return</span> end;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == target) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162.Find Peak Element"></a><a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">162.Find Peak Element</a></h1><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array <code>nums</code>, where <code>nums[i] ≠ nums[i+1]</code>, find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,1,3,5,6,4]</span><br><span class="line">Output: 1 or 5 </span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, </span><br><span class="line">             or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == end) <span class="keyword">return</span> start;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. Linked List Cycle</a></h1><p>Given a linked list, determine if it has a cycle in it.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1], pos = -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><p><strong>Follow up:</strong></p><p>Can you solve it using <em>O(1)</em> (i.e. constant) memory?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. Linked List Cycle II</a></h1><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1], pos = -1</span><br><span class="line">Output: no cycle</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><p><strong>Follow-up</strong>:<br>Can you solve it without using extra space?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode slow2 = head;</span><br><span class="line">                <span class="keyword">while</span>(slow != slow2) &#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    slow2 = slow2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. Remove Duplicates from Sorted List</a></h1><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;<span class="comment">// movre forward when do not have replcaited item;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82. Remove Duplicates from Sorted List II"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. Remove Duplicates from Sorted List II</a></h1><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p><p>Return the linked list sorted as well.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">Output: 2-&gt;3</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//删除当前节点的方法是在将要删除的节点前面再加一个dummy节点，这样才能指向dummy.next.next,也就是删除dummy.next。</span></span><br><span class="line">        dummy.next = head;<span class="comment">//这样才能删除头指针节点</span></span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span> &amp;&amp; p.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next.val == p.next.next.val) &#123;</span><br><span class="line">                <span class="comment">//用来删除全部的重复节点，保存一下重复值</span></span><br><span class="line">                <span class="keyword">int</span> sameNum = p.next.val;</span><br><span class="line">                <span class="keyword">while</span> (p.next != <span class="keyword">null</span> &amp;&amp; p.next.val == sameNum) &#123;</span><br><span class="line">                    p.next = p.next.next;</span><br><span class="line">                &#125; </span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 p = p.next;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;74-Search-a-2D-Matrix&quot;&gt;&lt;a href=&quot;#74-Search-a-2D-Matrix&quot; class=&quot;headerlink&quot; title=&quot;74. Search a 2D Matrix&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetc
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BFS AND DFS</title>
    <link href="http://yoursite.com/2020/06/05/BFS-AND-DFS/"/>
    <id>http://yoursite.com/2020/06/05/BFS-AND-DFS/</id>
    <published>2020-06-05T07:03:58.000Z</published>
    <updated>2020-06-18T04:37:33.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h2 id="图的BFS"><a href="#图的BFS" class="headerlink" title="图的BFS"></a>图的BFS</h2><h4 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162. 地图分析"></a><a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">1162. 地图分析</a></h4><p>对于图的BFS也是一样滴～ 与Tree的BFS区别如下：<br>1、tree只有1个root，而图可以有多个源点，所以首先需要把多个源点都入队。<br>2、tree是有向的因此不需要标志是否访问过，而对于无向图来说，必须得标志是否访问过！<br>并且为了防止某个节点多次入队，需要在入队之前就将其设置成已访问！</p><p>作者：sweetiee<br>链接：<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/jian-dan-java-miao-dong-tu-de-bfs-by-sweetiee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/jian-dan-java-miao-dong-tu-de-bfs-by-sweetiee/</a></p><p><img src="https://pic.leetcode-cn.com/367df5172fd16d2637e591f6586d146772758438c66660c86719ffb2d36eb14d-image.png" alt="BFS"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 先把所有的陆地都入队。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从各个陆地开始，一圈一圈的遍历海洋，最后遍历到的海洋就是离陆地最远的海洋。</span></span><br><span class="line">        <span class="keyword">boolean</span> hasOcean = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] point = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            point = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 取出队列的元素，将其四周的海洋入队。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newX = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> newY = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (newX &lt; <span class="number">0</span> || newX &gt;= m || newY &lt; <span class="number">0</span> || newY &gt;= n || grid[newX][newY] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                grid[newX][newY] = grid[x][y] + <span class="number">1</span>; <span class="comment">// 这里我直接修改了原数组，因此就不需要额外的数组来标志是否访问</span></span><br><span class="line">                hasOcean = <span class="keyword">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;newX, newY&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有陆地或者没有海洋，返回-1。</span></span><br><span class="line">        <span class="keyword">if</span> (point == <span class="keyword">null</span> || !hasOcean) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最后一次遍历到的海洋的距离。</span></span><br><span class="line">        <span class="keyword">return</span> grid[point[<span class="number">0</span>]][point[<span class="number">1</span>]] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS遍历矩阵"><a href="#BFS遍历矩阵" class="headerlink" title="BFS遍历矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shun-shi-zhen-da-yin-ju-zhen-by-leetcode-solution/" target="_blank" rel="noopener">BFS遍历矩阵</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">        <span class="keyword">int</span> total = rows * columns;</span><br><span class="line">        <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[total];</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            order[i] = matrix[row][column];</span><br><span class="line">            visited[row][column] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>], nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="number">0</span> || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123;</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            column += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考目录"><a href="#参考目录" class="headerlink" title="参考目录"></a>参考目录</h1><ul><li><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzA5ODk3ODA4OQ==&amp;hid=1&amp;sn=55c59cffea8c1340fa26bd05a5da3fcd&amp;scene=1&amp;devicetype=iOS13.3.1&amp;version=17000b24&amp;lang=en&amp;nettype=WIFI&amp;ascene=7&amp;session_us=gh_cc856cc5e4d6&amp;fontScale=100&amp;wx_header=1" target="_blank" rel="noopener">甜姨</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/G2I57RPxGC913-BUcOLCUQ" target="_blank" rel="noopener">小号算法目录</a></p></li><li><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzA5ODk3ODA4OQ==&amp;hid=1&amp;sn=55c59cffea8c1340fa26bd05a5da3fcd&amp;scene=1&amp;devicetype=iOS13.3.1&amp;version=17000b24&amp;lang=en&amp;nettype=WIFI&amp;ascene=7&amp;session_us=gh_cc856cc5e4d6&amp;fontScale=100&amp;wx_header=1" target="_blank" rel="noopener">大象🐘</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BFS&quot;&gt;&lt;a href=&quot;#BFS&quot; class=&quot;headerlink&quot; title=&quot;BFS&quot;&gt;&lt;/a&gt;BFS&lt;/h1&gt;&lt;h2 id=&quot;图的BFS&quot;&gt;&lt;a href=&quot;#图的BFS&quot; class=&quot;headerlink&quot; title=&quot;图的BFS&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search.</title>
    <link href="http://yoursite.com/2020/06/04/Binary-Search/"/>
    <id>http://yoursite.com/2020/06/04/Binary-Search/</id>
    <published>2020-06-04T02:28:54.000Z</published>
    <updated>2020-06-08T05:37:47.379Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.leetcode-cn.com/e120bac189db2fc912dce550d9c46746a312f362ee3d6d40e799aad8db69ae6f-image.png" alt="BS Mind"></p><p><img src="/Users/WilliamRen/Nutstore Files/博客图床/排除法找二分.png" alt="排除法找二分"></p><p><img src="/Users/WilliamRen/Nutstore Files/博客图床/边界收缩问题.png" alt="边界收缩问题"></p><p><img src="/Users/WilliamRen/Nutstore Files/博客图床/限制条件.png" alt="限制条件"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> des)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> low = <span class="number">0</span>, high = array.length - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">         <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;<span class="comment">//int mid = (left + right) &gt;&gt; 1;</span></span><br><span class="line">         <span class="keyword">if</span> (des == array[mid]) &#123;</span><br><span class="line">             <span class="keyword">return</span> mid;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (des &lt; array[mid]) &#123;</span><br><span class="line">             high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：针对特殊测试用例，例如 2147395599</span></span><br><span class="line">        <span class="comment">// 要把搜索的范围设置成长整型</span></span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环</span></span><br><span class="line">            <span class="comment">// long mid = left + (right - left + 1) / 2;</span></span><br><span class="line">            <span class="keyword">long</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> square = mid * mid;</span><br><span class="line">            <span class="keyword">if</span> (square &gt; x) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为一定存在，因此无需后处理</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/fIDeC5yQUJUO4KCwfjziow" target="_blank" rel="noopener">二分查找</a></p><p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">Binary Search Solution  in Leetcode</a></p><p><a href="https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/" target="_blank" rel="noopener">二分查找细节详解_labuladong</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://pic.leetcode-cn.com/e120bac189db2fc912dce550d9c46746a312f362ee3d6d40e799aad8db69ae6f-image.png&quot; alt=&quot;BS Mind&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Everything About TreeMap</title>
    <link href="http://yoursite.com/2020/03/21/Everything-About-TreeMap/"/>
    <id>http://yoursite.com/2020/03/21/Everything-About-TreeMap/</id>
    <published>2020-03-21T06:07:11.000Z</published>
    <updated>2020-03-21T06:11:03.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>文章的内容基于JDK1.7进行分析，之所以选用这个版本，是因为1.8的有些类做了改动，增加了阅读的难度，虽然是1.7，但是对于1.8做了重大改动的内容，文章也会进行说明。</p><p>TreeMap实现了SotredMap接口，它是有序的集合。而且是一个红黑树结构，每个key-value都作为一个红黑树的节点。如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。这点会在接下来的代码中做说明，如果指定了比较器则按照比较器来进行排序。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serializable, Cloneable, Map&lt;K,V&gt;, NavigableMap&lt;K,V&gt;, SortedMap&lt;K,V&gt;</span><br></pre></td></tr></table></figure><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;  <span class="comment">//比较器，是自然排序，还是定制排序 ，使用final修饰，表明一旦赋值便不允许改变</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="keyword">null</span>;  <span class="comment">//红黑树的根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;     <span class="comment">//TreeMap中存放的键值对的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;   <span class="comment">//修改的次数</span></span><br></pre></td></tr></table></figure><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>由于TreeMap中源码较长，接下来将分段解析部分源码。既然是红黑树存储，肯定要有数据结构（Node）节点的。看一下TreeMap中关于节点的定义部分。</p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;    <span class="comment">//键</span></span><br><span class="line">    V value;    <span class="comment">//值</span></span><br><span class="line">    Entry&lt;K,V&gt; left = <span class="keyword">null</span>;     <span class="comment">//左孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; right = <span class="keyword">null</span>;    <span class="comment">//右孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;          <span class="comment">//父节点</span></span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;      <span class="comment">//节点的颜色，在红黑树种，只有两种颜色，红色和黑色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，用指定的key,value ,parent初始化，color默认为黑色</span></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回该节点对应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换节点的值，并返回旧值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写equals()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="comment">//两个节点的key相等，value相等，这两个节点才相等</span></span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写hashCode()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> keyHash = (key==<span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> valueHash = (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="comment">//key和vale hash值得异或运算，相同则为零，不同则为1 </span></span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写toString()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法，comparator用键的顺序做比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法，提供比较器，用指定比较器排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    his.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将m中的元素转化daoTreeMap中，按照键的顺序做比较排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法，指定的参数为SortedMap</span></span><br><span class="line"><span class="comment">//采用m的比较器排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeMap提供了四个构造方法，实现了方法的重载。无参构造方法中比较器的值为null,采用自然排序的方法，如果指定了比较器则称之为定制排序.</p><ul><li>自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象</li><li>定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。</li></ul><p>对于Map来说，使用的最多的就是put()/get()/remove()等方法，下面依次进行分析</p><h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;     <span class="comment">//红黑树的根节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;        <span class="comment">//红黑树是否为空</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        <span class="comment">//构造根节点，因为根节点没有父节点，传入null值。 </span></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);  </span><br><span class="line">        size = <span class="number">1</span>;     <span class="comment">//size值加1</span></span><br><span class="line">        modCount++;    <span class="comment">//改变修改的次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">//返回null </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;    <span class="comment">//定义节点</span></span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;     <span class="comment">//获取比较器</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;      <span class="comment">//如果定义了比较器，采用自定义比较器进行比较</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;      <span class="comment">//将红黑树根节点赋值给parent</span></span><br><span class="line">            cmp = cpr.compare(key, t.key);     <span class="comment">//比较key, 与根节点的大小</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)      <span class="comment">//如果key &lt; t.key , 指向左子树</span></span><br><span class="line">                t = t.left;   <span class="comment">//t = t.left  , t == 它的做孩子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;  <span class="comment">//如果key &gt; t.key , 指向它的右孩子节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);      <span class="comment">//如果它们相等，替换key的值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);        <span class="comment">//循环遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//自然排序方式，没有指定比较器</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  <span class="comment">//抛出异常</span></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;    <span class="comment">//类型转换</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)     <span class="comment">// key &lt; t.key </span></span><br><span class="line">                t = t.left;   <span class="comment">//左孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)   <span class="comment">// key &gt; t.key </span></span><br><span class="line">                t = t.right;    <span class="comment">//右孩子</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);   <span class="comment">//t == t.key , 替换value值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);   <span class="comment">//创建新节点，并制定父节点</span></span><br><span class="line">    <span class="comment">//根据比较结果，决定新节点为父节点的左孩子或者右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);   <span class="comment">//新插入节点后重新调整红黑树 </span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较方法，如果comparator==null ,采用comparable.compartTo进行比较，否则采用指定比较器比较大小</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入的节点默认的颜色为红色</span></span><br><span class="line">    x.color = RED;    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//情形1： 新节点x 是树的根节点，没有父节点不需要任何操作</span></span><br><span class="line">    <span class="comment">//情形2： 新节点x 的父节点颜色是黑色的，也不需要任何操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">    <span class="comment">//情形3：新节点x的父节点颜色是红色的</span></span><br><span class="line">    <span class="comment">//判断x的节点的父节点位置，是否属于左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">          <span class="comment">//获取x节点的父节点的兄弟节点，上面语句已经判断出x节点的父节点为左孩子，所以直接取右孩子</span></span><br><span class="line">         Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">         <span class="comment">//判断是否x节点的父节点的兄弟节点为红色。</span></span><br><span class="line">         <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">              setColor(parentOf(x), BLACK); <span class="comment">// x节点的父节点设置为黑色</span></span><br><span class="line">              setColor(y, BLACK);           <span class="comment">// y节点的颜色设置为黑色</span></span><br><span class="line">              setColor(parentOf(parentOf(x)), RED); <span class="comment">// x.parent.parent设置为红色</span></span><br><span class="line">              x = parentOf(parentOf(x)); <span class="comment">// x == x.parent.parent ,进行遍历。</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//x的父节点的兄弟节点是黑色或者缺少的</span></span><br><span class="line">               <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;   <span class="comment">//判断x节点是否为父节点的右孩子</span></span><br><span class="line">                    x = parentOf(x);     <span class="comment">//x == 父节点</span></span><br><span class="line">                    rotateLeft(x);    <span class="comment">//左旋转操作</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//x节点是其父的左孩子</span></span><br><span class="line">               setColor(parentOf(x), BLACK);</span><br><span class="line">               setColor(parentOf(parentOf(x)), RED);  <span class="comment">//上面两句将x.parent 和x.parent.parent的颜色做调换</span></span><br><span class="line">               rotateRight(parentOf(parentOf(x)));   <span class="comment">//进行右旋转</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));  <span class="comment">//y 是x 节点的祖父节点的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;    <span class="comment">//判断颜色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);    <span class="comment">//父节点设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);         <span class="comment">//父节点的兄弟节点设置为黑色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);   <span class="comment">//祖父节点设置为红色</span></span><br><span class="line">                x = parentOf(parentOf(x));   <span class="comment">//将祖父节点作为新插入的节点，遍历调整</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;     <span class="comment">//x 是其父亲的左孩子</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);    <span class="comment">//以父节点为旋转点，进行右旋操作</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);    <span class="comment">//父节点为设置为黑色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);  <span class="comment">//祖父节点设置为红色</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));  <span class="comment">//以父节点为旋转点，进行左旋操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK; <span class="comment">//通过节点位置的调整，最终将红色的节点条调换到了根节点的位置，根节点重新设置为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>红黑树是一个更高效的检索二叉树，有如下特点：</p><ol><li>每个节点只能是红色或者黑色</li><li>根节点永远是黑色的</li><li>所有的叶子的子节点都是空节点，并且都是黑色的</li><li>每个红色节点的两个子节点都是黑色的（不会有两个连续的红色节点）</li><li>从任一个节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点（叶子节点到根节点的黑色节点数量每条路径都相同）</li></ol><p>上面的代码，详细的标注了每条语句的作用，但是我相信，如果你没有一定的功力，即使注释已经很详细了，你也会是一脸懵逼 ，二脸懵逼，全脑懵逼中，下面配合图片来梳理一下代码所表示的含义：<br>当一个默认为红色的节点插入树中，其实对应的是7中可能发生的情况，分别进行叙述：</p><ul><li>情形1：新插入的节点时红黑树的根节点，没有父节点，无需任何的操作，直接将颜色设置为黑色就可以了</li><li>情形2：新节点的父节点颜色是黑色的，新插入的节点是红色的。也无需任何的操作。因为新节点的插入并没有影响到红黑书的特点</li><li>情形3：新节点的父节点（左孩子节点）颜色是红色的，而父节点的兄弟节点颜色也是红色的。那么情况就出现了，此时插入的节点就违反了红黑树的特点4 ，需要对红黑树进行调整。 操作看下图：<img src="https://static.oschina.net/uploads/space/2018/0228/120104_Rfsm_2927759.png" alt="img"><br>调整操作如上图，将父节点和父节点的兄弟节点，都修改为红色，然后将祖父节点修改为红色，因为修改了祖父节点的颜色，祖父节点可能会发生颜色的冲突，所以将新插入的节点修改为祖父节点，在进行调整。</li><li>情形4：父节点（左孩子节点）的颜色为红色，父节点的兄弟节点的颜色为黑色或者为null，新插入的节点为父节点的右孩子节点。如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/120219_SNXd_2927759.png" alt="img"><br>此时以父节点为旋转点，就新插入的节点进行左旋操作。便变成了情形5对应的情况，将执行情形5的操作</li><li>情形5：父节点（左孩子节点）的颜色为红色，父节点的兄弟节点颜色为黑色或者null,新插入节点为父亲的左孩子节点。如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/120301_ZnNC_2927759.png" alt="img"></li><li>情形6 和情形7的操作与情形4和情形5的操作相同，它们之前的区别是父节点为有孩子节点，再次不再赘述。</li></ul><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);  <span class="comment">//根据key查找节点，并返回该节点</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    V oldValue = p.value;    <span class="comment">//获取key对应的值</span></span><br><span class="line">    deleteEntry(p);     <span class="comment">//删除节点</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;   <span class="comment">//返回key对应的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据键寻找节点，有非为两种方式，如果定制了比较器，采用定制排序方式，否则使用自然排序</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key); <span class="comment">//循环遍历树，寻找和key相等的节点</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;  <span class="comment">//循环遍历树，寻找和key相等的节点</span></span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;  <span class="comment">//记录修改的次数</span></span><br><span class="line">    size--;   <span class="comment">//数量减1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的两个孩子都不为空</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//寻找继承者，继承者为当前节点的右孩子节点或者右孩子节点的最小左孩子</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;     <span class="comment">//key - value  的替换 ，并没有替换颜色</span></span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;  <span class="comment">//指向继承者</span></span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line">    <span class="comment">//开始修复树结构，继承者的左孩子不为空，返回左孩子，否则返回右孩子</span></span><br><span class="line">    <span class="comment">//不可能存在左右两个孩子都存在的情况，successor寻找的就是最小节点，它的左孩子节点为null</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Link replacement to parent</span></span><br><span class="line">        <span class="comment">//已经被选为继承者，当前拥有的一切放弃，所以将孩子交给爷爷抚养</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="comment">//p节点没有父节点，则指向根节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">           root = replacement;</span><br><span class="line">        <span class="comment">//如果p为左孩子，如果p为左孩子，则将p.parent.left = p.left</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除p节点到左右分支，和父节点的引用</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fix replacement</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            <span class="comment">//恢复颜色分配</span></span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">        <span class="comment">//红黑书中父节点为空的只能是根节点。</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不是根节点，颜色为黑色，调整结构</span></span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断x是否为左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            <span class="comment">//x的兄弟节点</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            <span class="comment">//若兄弟节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);   <span class="comment">//设置兄弟节点变为黑色</span></span><br><span class="line">                setColor(parentOf(x), RED);  <span class="comment">//父节点设置为红色</span></span><br><span class="line">                rotateLeft(parentOf(x));   <span class="comment">//左旋父节点</span></span><br><span class="line">                sib = rightOf(parentOf(x)); <span class="comment">//重新设置x的兄弟节点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED); <span class="comment">//兄弟节点的两个孩子都是黑色的重新设置兄弟节点的颜色，修改为红色</span></span><br><span class="line">                x = parentOf(x);   <span class="comment">//将x定位到父节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;   <span class="comment">//兄弟节点的右孩子是黑色的，左孩子是红色的</span></span><br><span class="line">                    setColor(leftOf(sib), BLACK);  <span class="comment">//设置左孩子节点为黑色</span></span><br><span class="line">                    setColor(sib, RED); <span class="comment">//兄弟节点为红色</span></span><br><span class="line">                    rotateRight(sib);   <span class="comment">//右旋</span></span><br><span class="line">                    sib = rightOf(parentOf(x));  <span class="comment">//右旋后重新设置兄弟节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));  <span class="comment">//兄弟节点颜色设置和父节点的颜色相同</span></span><br><span class="line">                setColor(parentOf(x), BLACK);   <span class="comment">//父节点设置为黑色</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);  <span class="comment">//将兄弟节点的有孩子设置为黑色</span></span><br><span class="line">                rotateLeft(parentOf(x));   <span class="comment">//左旋</span></span><br><span class="line">                x = root;  <span class="comment">//设置x为根节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            <span class="comment">//x为父节点的右节点，参考上面的操作</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除红黑树的操作比插入操作要稍微麻烦一点，分为两步：</p><ul><li>以排序二叉树的方法删除指定节点。删除的节点存在三种情况：<ul><li>被删除节点，没有左右孩子节点，直接删除即可</li><li>被删除节点，有一个孩子节点，那么让它的孩子节点指向它的父节点即可</li><li>本删除的节点，有两个非空的孩子节点，那么需要找到该节点的前驱或者后继节点，更换元素值，在将前驱或者后继节点删除（任意一个节点的前驱或者后继都必定至多有一个非空的子节点，可以按照前面的两种情形进行操作）</li></ul></li><li>进行颜色的调换和树的旋转，满足红黑树的特征</li></ul><p>下面来分情形讨论一下可能发生的情况：</p><ul><li>情形1：被删除的节点为根节点或者颜色为空色，此时删除该节点不影响红黑树的特点。无需操作</li><li>情形2：被删除节点为黑色，兄弟节点为红色，如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/120648_lZYh_2927759.png" alt="img"><br>若删除上图中的x节点，将缺少一个黑节点，与红黑树的性质冲突，所以修改sib颜色为黑色，设置p节点为红色，并进行左旋操作。在进行后续的处理。</li><li>情形3：被删除节点为黑色，x节点的兄弟节点的子节点都是黑色，如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/120742_LGd3_2927759.png" alt="img"><br>x节点是黑色的，兄弟节点（黑色的）的子节点也是黑色的，p节点的颜色无法确定，有可能是红色的，也有可能是黑色的。如果是红色的直接设置为黑色即可，如果为黑色的，则需要将x定位的p节点，在进行处理。</li><li>情形4：被删除节点为黑色，x的兄弟节点的右自子节点为黑色。如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/120844_0oQ7_2927759.png" alt="img"><br>情形4的调整为了转变成情形5的情况，来进行处理。</li><li>情形5：被删除节点为黑色，x的兄弟节点右子节点为红色。如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/124855_O7NA_2927759.png" alt="img"><br>sib的左子节点的颜色不确定，可能是红色也可能是黑色，但是对它并没有什么影响，因为变换前后它的上层分支的黑色节点数并没有改变。</li></ul><p>上面的情形只是针对删除的节点是左孩子的情况，进行的分析，被删除的节点也可能是右分支。情况完全相同只不过左右顺序发生了颠倒，不再进行复述。</p><p>至此TreeMap中实现的最重要已经说完了。</p><p>下面简单说一下一些方法的作用</p><ul><li>firstEntry() 返回Map中最小的key</li><li>higherEntry(Object key ) 返回该Map中位于key后一位的key-value</li><li>lowerEntry(Object key ) 返回该Map中唯一key前一位的key-value</li><li>tailMap(Object key , boolean inclusive) 返回该Map的子Map</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><ul><li>关于红黑树的节点插入操作，首先是改变新节点，新节点的父节点，祖父节点，和新节点的颜色，能在当前分支通过节点的旋转改变的，则通过此种操作，来满足红黑书的特点。</li><li>如果当前相关节点的旋转解决不了红黑树的冲突，则通过将红色的节点移动到根节点解决，最后在将根节点设置为黑色</li></ul>]]></content>
    
    <summary type="html">
    
      Find Everything about TreeMap IN There.
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>Everything About ConcurrentHashMap</title>
    <link href="http://yoursite.com/2020/03/21/Everything-About-ConcurrentHashMap/"/>
    <id>http://yoursite.com/2020/03/21/Everything-About-ConcurrentHashMap/</id>
    <published>2020-03-21T06:06:48.000Z</published>
    <updated>2020-03-21T06:09:34.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ConcurrentHashMap常用于并发编程，这里就从源码上来分析一下ConcurrentHashMap数据结构和底层原理。</p><p>在开始之前先介绍一个算法， 这个算法和Concurrent的实现是分不开的。<br>CAS算法：</p><ul><li>CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</li><li>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</li><li>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B</li></ul><p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><p><strong>ConcurrentHashMap是一个线程安全的Map集合，可以应对高并发的场景，保证线程安全。</strong>相比较HashTable，它的锁粒度更加的细化，因为HashTable的方法都是用Synchronized修饰的，效率灰常的底下。</p><p>1.8之前ConcurrentHashMap使用锁分段技术，将数据分成一段段的存储，每一个数据段配置一把锁，相互之间不影响，而1.8之后摒弃了Segment（锁段）的概念，启用了全新的实现，也就是利用<strong>CAS+Synchronized</strong>来保证并发更新的安全，底层采用的依然是数组+链表+红黑树。</p><p>本篇文章是基于JDK1.8 。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 继承了AbstractMap ,并且实现了ConcurrentMap接口。</p><h2 id="与HashMap比对："><a href="#与HashMap比对：" class="headerlink" title="与HashMap比对："></a>与HashMap比对：</h2><ul><li>相同点：都集成了AbstractMap接口</li><li>不同点：HashMap实现了Map接口，ConcurrentHashMap实现了ConcurrentMap接口，而ConcurrentMap继承了Map接口，使用default关键字定义了一些方法 。</li></ul><p>从继承关系上看ConcurrentHashMap与HashMap并没有太大的区别。</p><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//最大容量2的30次方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>; <span class="comment">//默认容量  1&lt;&lt;4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;  <span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;  <span class="comment">//链表转为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;  <span class="comment">//树转列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// forwarding nodes 的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// roots of trees 的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// transient reservations 的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors(); <span class="comment">//可用处理器数量</span></span><br></pre></td></tr></table></figure><p>重点说一下 <strong>sizeCtrl</strong> 属性，这个属性在 ConcurrentHashMap 中扮演者重要的角色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表初始化或者扩容的一个控制标识位</span></span><br><span class="line"><span class="comment">//负数代表正在进行初始化或者扩容的操作</span></span><br><span class="line"><span class="comment">// -1 代表初始化</span></span><br><span class="line"><span class="comment">// -N 代表有n-1个线程在进行扩容操作</span></span><br><span class="line"><span class="comment">//正数或者0表示没有进行初始化操作，这个数值表示初始化或者下一次要扩容的大小。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//transient 修饰的属性不会被序列化，volatile保证可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造方法，没有进行任何操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//指定初始化大小构造方法，判断参数的合法性，并创建了计算初始化的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//将指定的集合转化为ConcurrentHashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//指定初始化大小和负载因子的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//指定初始化大小，负载因子和concurrentLevel并发更新线程的数量，也可以理解为segment的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ConcurrentHashMap的构造方法并没做太多的工作，主要是进行了参数的合法性校验，和初始值大小的转换。这个方法 tableSizeFor()说明一下， 主要的功能就是将指定的初始化参数转换为2的幂次方形式， 如果初始化参数为9 ，转换后初始大小为16 。</p></blockquote><h2 id="内部数据结构"><a href="#内部数据结构" class="headerlink" title="内部数据结构"></a>内部数据结构</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a><strong>Node</strong></h3><p>首当其冲，因为它是ConcurrentHashMap的核心，它包装了key-value的键值对，所有插入的数据都包装在这里面，与HashMap很相似，但是有一些差别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">     <span class="keyword">final</span> K key;</span><br><span class="line">     <span class="keyword">volatile</span> V val;</span><br><span class="line">     <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">     Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.hash = hash;</span><br><span class="line">         <span class="keyword">this</span>.key = key;</span><br><span class="line">         <span class="keyword">this</span>.val = val;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 和 next使用了volatile修饰，保证了线程之间的可见性。也不允许调用setValue()方法直接改变Node的值。并增加了find()方法辅助map.get()方法。</p><h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a><strong>TreeNode</strong></h3><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap集成自Node类，而并非HashMap中的集成自LinkedHashMap.Entry类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。</p><h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a><strong>TreeBin</strong></h3><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。</p><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a><strong>ForwardingNode</strong></h3><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找</p><h1 id="ConcurrentHashMap常用方法"><a href="#ConcurrentHashMap常用方法" class="headerlink" title="ConcurrentHashMap常用方法"></a><strong>ConcurrentHashMap常用方法</strong></h1><h2 id="initTable-初始化方法"><a href="#initTable-初始化方法" class="headerlink" title="initTable 初始化方法"></a><strong>initTable 初始化方法</strong></h2><p>初始化方法是很重要的一个方法，因为在ConcurrentHashMap的构造方法中只是简单的进行了一些参数校验和参数转换的操作。整个Map的初始化是在插入元素的时候触发的。这一点在下面的put方法中会进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行初始化操作，单线程操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//sizeCtl &lt; 0 表示有线程正在进行初始化操作，从运行状态变为就绪状态。</span></span><br><span class="line">                Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment">//设置SIZECTL的值为-1，阻塞其他线程的操作</span></span><br><span class="line">            <span class="comment">//该方法有四个参数</span></span><br><span class="line">            <span class="comment">//第一个参数：需要改变的对象</span></span><br><span class="line">            <span class="comment">//第二个参数：偏移量</span></span><br><span class="line">            <span class="comment">//第三个参数：期待的值</span></span><br><span class="line">            <span class="comment">//第四个参数：更新后的值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//再次检查是否有线程进行了初始化操作</span></span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        <span class="comment">//初始化Node对象数组</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        <span class="comment">//sc的值设置为n的0.75倍</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);  <span class="comment">//相当于n*0.75</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;  <span class="comment">//更改sizeCtl的值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//中断循坏返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> tab; <span class="comment">//返回初始化的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a><strong>扩容方法</strong></h2><p>当ConcurrentHashMap 容量不足的时候，需要对table进行扩容，这个方法是支持多个线程并发扩容的，我们所说的扩容，从本质上来说，无非是从一个数组到另外一个数组的拷贝。</p><p>扩容方法分为两个部分：</p><ul><li>创建扩容后的新数组，容量变为原来的两倍 ，新数组的创建时单线程完成</li><li>将原来的数组元素复制到新的数组中，这个是多线程操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//帮助扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">      <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;(nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;(sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tab = table ,nextTab 一个Node&lt;Key,Value&gt;[]类型的变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n 是tab的长度 ， stride 初始值为0 </span></span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="comment">//判断cpu处理多线程的能力，如果小于16就直接赋值为16</span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="comment">//构造一个容量是原来两倍的Node&lt;K ,V&gt; 类型数组</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;  <span class="comment">//赋值</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;  <span class="comment">//赋值</span></span><br><span class="line">            transferIndex = n;    <span class="comment">//将数组长度赋值给transferIndex</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;  <span class="comment">//获取新数组的长度</span></span><br><span class="line">        </span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);  <span class="comment">//创建fwd节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">//使用for循环来处理每个槽位中的链表元素，CAS设置transferIndex属性值，并初始化i和bound值</span></span><br><span class="line">         <span class="comment">// i 指当前的槽位序号，bound值需要处理的边界，先处理槽位为15的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//创建两个变量，一个为Node&lt;K,V&gt; 类型，一个为int类型</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//将transferIndex的值赋值给 nextIndex ,并判断nextIndex的值是否小于等于0</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;   </span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//更新nextIndex的值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="comment">//如果table已经复制结束</span></span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="keyword">null</span>;   <span class="comment">//清空nextTable</span></span><br><span class="line">                    table = nextTab;    <span class="comment">//把nextTab 赋值给 table </span></span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);  <span class="comment">//阈值设置为容量的1.5倍</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS算法获取某个数组节点，为空就设置为fwd</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果某个节点的hash为-1，跳过</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//对头节点加锁，禁止其他线程进入</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//构造两个链表 ，将该节点的列表拆分为两个部分，一个是原链表的排列顺序，一个是反序</span></span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;  </span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;   <span class="comment">// fh 当前节点的hash值   若 &gt;= 0 </span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;    <span class="comment">//将当前节点赋值给 lastRun  节点  </span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//差分列表操作</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//在nextTab 的i 位置上放置ln节点</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            <span class="comment">//在nextTab 的 i+n 位置上放置 hn节点</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">//在tab节点i位置上插入插入forwardNode节点，表示该节点已经处理</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//对TreeBin对象进行处理，过程与上面有些类似 </span></span><br><span class="line">                        <span class="comment">//也把节点分类，分别插入到lo和hi为头节点的链表中</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//如果扩容后 不在需要tree结构，反向转换成链表结构</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a><strong>put方法</strong></h2><p>put操作是最长用的方法，接下来看一下put()方法的具体实现：</p><ul><li>put()要求键值都不能为空</li><li>需要经过两次散列， 是数据均匀分散，减少碰撞的次数</li><li>判断tab是否进行了初始化，没有则调用initTable进行初始化操作（单线程）</li><li>数组i的位置没有元素存在，直接放入</li><li>如果i的位置在进行MOVE操作，也就是在进行扩容操作，则多线程帮助扩容</li><li>如果i的位置有元素存在，则在该节点加锁Synchronized，判断是链表还是红黑树，按照相应的插入规则插入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key|value == null  抛出异常</span></span><br><span class="line">    <span class="comment">//ConcurrentHashMap不允许键或者值为null的这种情况发生</span></span><br><span class="line">    <span class="comment">//这一点和HashMap有区别</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//散列在散列， 让数据均匀分布，减少碰撞次数</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());     --&gt;<span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;<span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;&#125;   </span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//死循环   相当于while(true) ,将table赋值给 tab </span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个Node类型的变量f , int 类型的变量 n i fh </span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断tab是否为null  ,是否进行了初始化操作，如果没有执行初始化，执行初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">            <span class="comment">//tabAt 获取值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//添加到table中</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">//退出循环               // no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//node的hash值为 -1 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//key 相等，使用新值替换旧值</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;((ek = e.key) == key ||(ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//放在链表的尾部</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;   </span><br><span class="line">                    <span class="comment">//红黑树替换</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a><strong>Get方法</strong></h2><p>Get方法也是最长用的方法，元素放入了，总要取出来</p><ul><li>根据传入的key,获取相应的hash值</li><li>然后判断当前的table数组是否为空</li><li>计算指定的key在table中存储的位置</li><li>链表或者红黑树转换相依的方法处理</li><li>不存在则返回null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//eh&lt; 0 表示红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//链表遍历</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK6，7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，把HashMap分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。</p><p>jdk7中ConcurrentHashmap中，当长度过长，碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能，所以jdk8 中完全重写了concurrentHashmap,代码量从原来的1000多行变成了 6000多 行，实现上也和原来的分段式存储有很大的区别。</p><p>主要设计上的变化有以下几点:</p><ol><li>不采用segment而采用node，锁住node来实现减小锁粒度。</li><li>设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。</li><li>使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。</li><li>sizeCtl的不同值来代表不同含义，起到了控制的作用。</li></ol><p>参考：</p><p><a href="https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Fu010723709%2Farticle%2Fdetails%2F48007881" target="_blank" rel="noopener">http://blog.csdn.net/u010723709/article/details/48007881</a></p>]]></content>
    
    <summary type="html">
    
      Find Everything about ConcurrentHashMap IN There.
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>Everything About HashSet</title>
    <link href="http://yoursite.com/2020/03/21/Everything-About-HashSet/"/>
    <id>http://yoursite.com/2020/03/21/Everything-About-HashSet/</id>
    <published>2020-03-21T05:39:21.000Z</published>
    <updated>2020-03-21T05:44:54.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>文章的内容基于JDK1.7进行分析，之所以选用这个版本，是因为1.8的有些类做了改动，增加了阅读的难度，虽然是1.7，但是对于1.8做了重大改动的内容，文章也会进行说明。</p><p>HashSet是Set接口的典型实现，HashSet按照Hash算法来存储集合中的元素。存在以下特点：</p><ul><li>不能保证元素的顺序，元素是无序的</li><li>HashSet不是同步的，需要外部保持线程之间的同步问题</li><li>集合元素值允许为null</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">    java.util.AbstractCollection&lt;E&gt; </span><br><span class="line">        java.util.AbstractSet&lt;E&gt; </span><br><span class="line">            java.util.HashSet&lt;E&gt;</span><br></pre></td></tr></table></figure><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serializable, Cloneable, Iterable&lt;E&gt;, Collection&lt;E&gt;, Set&lt;E&gt;</span><br></pre></td></tr></table></figure><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  <span class="comment">//map集合，HashSet存放元素的容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object(); <span class="comment">//map，中键对应的value值</span></span><br></pre></td></tr></table></figure><h1 id="重要方法深度解析"><a href="#重要方法深度解析" class="headerlink" title="重要方法深度解析"></a>重要方法深度解析</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造方法，完成map的创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定集合转化为HashSet, 完成map的创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">   map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始化大小，和负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始化大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始化大小和负载因子，dummy 无实际意义</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造函数，不难发现，HashSet的底层是采用HashMap实现的。</p><h2 id="Add-方法"><a href="#Add-方法" class="headerlink" title="Add()方法"></a>Add()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PRESENT为HashSet类中定义的一个使用static final 修饰的常量，并无实际的意义，HashSet的add方法调用HashMap的put()方法实现，如果键已经存在，map.put()放回的是旧值，添加失败，如果添加成功map.put()方法返回的是null ,HashSet.add()方法返回true,要添加的元素可作为map中的key 。</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除方法，调用map.remove()方法实现，map.remove()能找到指定的key,则返回key对应的value,对于Hashset而言，它所有的key对应的值都是PRESENT。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>; <span class="comment">//序列化版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  <span class="comment">//HashMap变量，用于存放HashSet的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object(); <span class="comment">//map中的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，将指定的集合转化为HashSet</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，指定初始化的大小和负载因子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指定初始化大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，采用default修饰，只能是同一个包下的成员访问。包不相同无法访问</span></span><br><span class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HashSet的遍历操作</span></span><br><span class="line">    <span class="comment">//通过这个方法可以发现，HashSet调用了HashMap存放，因为HashSet并不是键值对存储，所以它只是把它的值做了Map中的键，在遍历HashSet的集合元素时，实际上是遍历的Map中Key的集合。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回集合中元素的容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否包含指定的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素，添加的元素作为了Map中的key,value使用了一个常量表示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//克隆方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">            <span class="keyword">return</span> newSet;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入输出流操作。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out HashMap capacity and load factor</span></span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size</span></span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从输入流中读取对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in HashMap capacity and load factor and create backing HashMap</span></span><br><span class="line">        <span class="keyword">int</span> capacity = s.readInt();</span><br><span class="line">        <span class="keyword">float</span> loadFactor = s.readFloat();</span><br><span class="line">        map = (((HashSet)<span class="keyword">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">               <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               <span class="keyword">new</span> HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size</span></span><br><span class="line">        <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            E e = (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>HashSet的底层通过HashMap实现的。而HashMap在1.7之前使用的是数组+链表实现，在1.8+使用的数组+链表+红黑树实现。其实也可以这样理解，HashSet的底层实现和HashMap使用的是相同的方式，因为Map是无序的，因此HashSet也无法保证顺序。</li><li>HashSet的方法，也是借助HashMap的方法来实现的。</li></ul>]]></content>
    
    <summary type="html">
    
      Find Everything about HashSet IN There.
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>2019-2In TaiwanTech</title>
    <link href="http://yoursite.com/2020/02/17/2019-2In-TaiwanTech/"/>
    <id>http://yoursite.com/2020/02/17/2019-2In-TaiwanTech/</id>
    <published>2020-02-17T10:10:48.000Z</published>
    <updated>2020-03-30T04:19:58.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大四上學期的成績單"><a href="#大四上學期的成績單" class="headerlink" title="大四上學期的成績單"></a>大四上學期的成績單</h2><p><img src="https://i.loli.net/2020/02/17/M5U9XmiwQfFJ3bZ.png" alt="1082.png"></p><p>後面再補內容，已經錯過實習和秋招了。現在抓緊搞搞春招。</p><blockquote><p>學校的課實在太多，30學分忙8過來</p></blockquote><p>回家以后发现钙hub也打不开了…..除了科学上网的解决方法，另外一种就是<a href="https://blog.csdn.net/ustccw/article/details/84543284" target="_blank" rel="noopener">设置静态IP地址</a></p><p>图床也加载不出来了，这里推荐<a href="https://sm.ms/" target="_blank" rel="noopener">SM SM的图床服务</a></p><h2 id="新年新FLAG"><a href="#新年新FLAG" class="headerlink" title="新年新FLAG"></a>新年新FLAG</h2><h3 id="专业技术"><a href="#专业技术" class="headerlink" title="专业技术"></a>专业技术</h3><ul><li>按照zuochengyun大哥的建议读JDK重要包的源代码,<br><code>java.lang</code>,<code>java.util</code>.<code>java.io</code></li><li><p>Spring源码,</p></li><li><p>学习分布式缓存技术.</p></li><li><p>PASS THE FRM Certification RANK1</p></li></ul><h3 id="语言水平"><a href="#语言水平" class="headerlink" title="语言水平"></a>语言水平</h3><ul><li>日语达到N3水平</li></ul><p><a href="https://www.zhihu.com/question/59051017/answer/161476178" target="_blank" rel="noopener">如何自学备考日语N3？</a></p><ul><li>TOEFL破百</li></ul><h3 id="📚书单"><a href="#📚书单" class="headerlink" title="📚书单"></a>📚书单</h3><ul><li><p>Thinking In Java</p><p>Bruce Eckel 的《Java 编程思想》（Thinking in Java），非常有名的经典书籍。这本书的特点是，不仅仅介绍 Java 编程的基础知识点，也会思考编程中的各种选择与判断，包括穿插设计模式的使用，作者从理论到实践意义从不同的角度进行探讨，构建稳固的 Java 编程知识体系。</p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1849198902,3579180612&amp;fm=26&amp;gp=0.jpg" alt="img" style="zoom:33%;"></p></li><li><p>Effective Java</p><p>这本书的英文第三版已经在国内上市，涵盖了 Java 7 到 Java 9 的各种新特性。严格来说，这本书不算是一本基础书籍，但当你有一定基础后，还是非常建议通读一下的。关于这本书的阅读，我的建议是边学习边回顾，在吸收书中的经验时，多去想想自己在实际应用中是如何处理的。虽然《Effective Java》的具体章节可能是从某个点出发，但可以说都是对 Java、JVM、面向对象等各种知识的综合运用，对于设计和实现高质量的代码很有帮助。</p><p><img src="https://static001.geekbang.org/resource/image/bf/06/bf6e3f87d162595ddaa5d0786c0ed806.jpg" alt="img"></p></li><li><p>Java 并发编程实战</p><p>作者全是响当当的人物，比如 Brian Goetz，我多次在专栏里引用他的观点，众多强力作者也保证了书的质量。抛开作者光环，这本书的内容全部建立在理论之上，先讲清道理再谈实践，可以真正让你知其然也知其所以然。这本书更加侧重并发编程中有哪些问题，如何来深刻地理解和定义问题，如何利用可靠的手段指导工程实践，并没有过分纠结于并发类库的源码层面。</p><p><img src="https://static001.geekbang.org/resource/image/04/3f/0432ac1e431256fb894144aa2e66b03f.jpg" alt="img"></p></li><li><p>深入理解 Java 虚拟机</p><p><img src="https://static001.geekbang.org/resource/image/98/5f/98d02b66e1d3fdf8cc1f7f7c6f974b5f.jpg" alt="img"></p></li><li><p>性能优化</p><p>性能优化，我推荐 Charlie Hunt 和 Binu John 所著的《Java 性能优化权威指南》（Java Performance），也是我上次在直播时向大家推荐的。Java 之父 James Gosling。</p><p><img src="https://static001.geekbang.org/resource/image/c9/10/c9fae97c8a4954cb91b59dc7e59ab710.jpg" alt="img"></p></li><li><p>Spring实战</p><p>可以说 Spring 等相关框架已经成为业务开发的事实标准，系统性地掌握 Spring 框架的设计和实践，是必需的技能之一。</p><p><img src="https://static001.geekbang.org/resource/image/75/61/7559562971dc2eadd8fd03f02980a461.jpg" alt="img"></p></li><li><p>Netty实战</p><p>Netty 在性能、可扩展性等方面的突出表现，已经得到充分验证，作为基础的通信框架，已经广泛应用在各种互联网架构、游戏等领域，甚至可以说，如果没有仔细分析过 Netty，对 NIO 等方面的理解很可能还在很肤浅的阶段。</p><p><img src="https://static001.geekbang.org/resource/image/f8/d9/f8b11bdcb1559e472b77e23fcf184dd9.jpg" alt="img"></p></li><li><p>Cloud Native Java</p><p>Java 应用程序架构处于飞快的演进之中，微服务等新的架构应用越来越广泛，即使未必是使用 Spring Boot、Spring Cloud 等框架，但是系统的学习其设计思想和实践技术，绝对是有必要的。当然如果你在实践中使用 Dubbo 等框架，也可以选择相关书籍。前沿领域的变化非常快，很多风靡一时的开源软件，在实践中逐渐被证明存在各种弊端，或者厂商停止维护。所以这部分的学习，我建议不要盲目追新，最好是关注于分布式设计中的问题和解决的思路，做到触类旁通，并且注重书籍之外的学习渠道。下面两本并不算是 Java 书籍，但 Java 程序员进阶少不了对互联网主流架构的学习，了解分布式架构、缓存、消息中间件等令人眼花缭乱的技术，对于有志于成为架构师的 Java 工程师来说非常有帮助。</p><p><img src="https://static001.geekbang.org/resource/image/d2/12/d286554382cbba791f85e667ea124e12.jpg" alt="img"></p></li><li><p>大型分布式网站架构设计与实践</p><p>这本书总结了作者在构建安全、可稳定性、高扩展性、高并发的分布式网站方面的心得。</p><p><img src="https://static001.geekbang.org/resource/image/4a/4f/4ab17456a34278a8ca18de54fea76f4f.jpg" alt="img"></p></li><li><p>深入分布式缓存：从原理到实战</p><p>这本书融合了原理、架构和一线互联网公司的案例实践，值得参考。</p><p><img src="https://static001.geekbang.org/resource/image/3d/b8/3d70890354f556d1b3acbc2f2fdd99b8.jpg" alt="img"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大四上學期的成績單&quot;&gt;&lt;a href=&quot;#大四上學期的成績單&quot; class=&quot;headerlink&quot; title=&quot;大四上學期的成績單&quot;&gt;&lt;/a&gt;大四上學期的成績單&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/17/M5
      
    
    </summary>
    
    
      <category term="TaiwanTech" scheme="http://yoursite.com/tags/TaiwanTech/"/>
    
  </entry>
  
  <entry>
    <title>Garbage Collection In JVM</title>
    <link href="http://yoursite.com/2020/02/15/Garbage-Collection-In-JVM/"/>
    <id>http://yoursite.com/2020/02/15/Garbage-Collection-In-JVM/</id>
    <published>2020-02-14T17:52:18.000Z</published>
    <updated>2020-02-28T18:02:57.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么我们要了解JVM"><a href="#为什么我们要了解JVM" class="headerlink" title="为什么我们要了解JVM"></a>为什么我们要了解JVM</h1><p><img src="https://i.loli.net/2020/02/29/HvzDCcBqPuLmiOR.jpg" alt="FULLGC.jpg"></p><p><img src="https://i.loli.net/2020/02/26/rY2Q6bXhUDLNSkR.png" alt="JVM.png"></p><h4 id="私有线程区域："><a href="#私有线程区域：" class="headerlink" title="私有线程区域："></a>私有线程区域：</h4><ul><li>栈：函数当前运行过程中的一些函数变量。存对象的引用类型和地址</li><li>本地方法栈：存放C++运行时的native栈。</li><li>程序计数器：指向当前程序运行的位置。<h4 id="线程共享区域："><a href="#线程共享区域：" class="headerlink" title="线程共享区域："></a>线程共享区域：</h4></li><li>堆：存对象(最终)，老年代。</li><li>方法区：存储元数据信息，在JDK1.7前作永久代，1.8以后改为元数据空间，存储静态变量和常量、类加载器。</li></ul><p>Java的基础数据和指针都是值类型，所以直接存到内存里面去，不是去存地址寻址。</p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><ul><li>GC Root本地方法栈,方法区,栈不能被删除<blockquote><p>删除方法</p><ul><li><strong>标记清理</strong>，==会产生内存碎片==。</li><li><strong>标记整理</strong>(删了后面的顶上来，减少内存碎片)，==前移空间移动代价太大==。</li><li><strong>复制算法</strong>(分为两个区)，不直接删除，不被删除的复制到新区，==需要2倍的内存==。</li></ul></blockquote></li></ul><h3 id="实际："><a href="#实际：" class="headerlink" title="实际："></a>实际：</h3><h5 id="Minor-GC当在-Eden-区分配内存不足时，则会发生-minorGC-，由于-Java-对象多数是朝生夕灭的特性，所以-minorGC通常会比较频繁，效率也比较高。"><a href="#Minor-GC当在-Eden-区分配内存不足时，则会发生-minorGC-，由于-Java-对象多数是朝生夕灭的特性，所以-minorGC通常会比较频繁，效率也比较高。" class="headerlink" title="Minor GC当在 Eden 区分配内存不足时，则会发生 minorGC ，由于 Java 对象多数是朝生夕灭的特性，所以 minorGC通常会比较频繁，效率也比较高。"></a>Minor GC当在 Eden 区分配内存不足时，则会发生 minorGC ，由于 Java 对象多数是朝生夕灭的特性，所以 minorGC通常会比较频繁，效率也比较高。</h5><ul><li>年轻代：<strong>E区</strong>(伊甸园，满了触发YoungGC,用复制算法)，，<strong>两个Survive区</strong>(S0.S1) 8：1：1，两个S区交替工作（E+S1到S0,E+S0到S1）。每次Young GC完年龄会加一，满15岁就直接都去老年代区了。ParNew垃圾收集器(复制)。<h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5></li><li>老年代：只有一块，存满15岁到去老年代区的对象。和大对象，Old满了就和年轻的一起Full GC,发生STOPPED WORLD,整个Java程序直接暂停，就用标记清理或者标记整理。CMS垃圾收集器(标记清理)。</li></ul><p><strong>和GC Root无关的才能被删除</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么我们要了解JVM&quot;&gt;&lt;a href=&quot;#为什么我们要了解JVM&quot; class=&quot;headerlink&quot; title=&quot;为什么我们要了解JVM&quot;&gt;&lt;/a&gt;为什么我们要了解JVM&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Principle of JVM</title>
    <link href="http://yoursite.com/2020/02/08/Principle-of-JVM/"/>
    <id>http://yoursite.com/2020/02/08/Principle-of-JVM/</id>
    <published>2020-02-07T18:08:41.000Z</published>
    <updated>2020-02-17T10:19:31.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM原理速记复习Java虚拟机总结思维导图面试必备"><a href="#JVM原理速记复习Java虚拟机总结思维导图面试必备" class="headerlink" title="JVM原理速记复习Java虚拟机总结思维导图面试必备"></a>JVM原理速记复习Java虚拟机总结思维导图面试必备</h1><p><div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"></div></p><p><img src="https://images.cnblogs.com/cnblogs_com/neverth/1592425/o_191116143745Java%E8%99%9A%E6%8B%9F%E6%9C%BA-min.png" alt="JVM"><br><br></p><h1 id="java虚拟机">Java虚拟机</h1><br><h2 id="一运行时数据区域">一、运行时数据区域</h2><br><h3 id="线程私有">线程私有</h3><br><ul><br><li><p>程序计数器</p><br><ul><br><li>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是Native方法则为空），是唯一一个没有规定OOM（OutOfMemoryError）的区域。</li><br></ul></li><br><li><p>Java虚拟机栈</p><br><ul><br><li>每个Java方法在执行的同时会创建一个栈桢用于存储局部变量表、操作数栈、动态链接、方法出口等信息。从方法调用直到执行完成的过程，对应着一个栈桢在Java虚拟机栈中入栈和出栈的过程。（局部变量包含基本数据类型、对象引用reference和returnAddress类型）</li><br></ul></li><br><li><p>本地方法栈</p><br><ul><br><li>本地方法栈与Java虚拟机栈类似，它们之间的区别只不过是本地方法栈为Native方法服务。</li><br></ul></li><br></ul><br><h3 id="线程公有">线程公有</h3><br><ul><br><li><p>Java堆（GC区）（Java Head）</p><br><ul><br><li>几乎所有的对象实例都在这里分配内存，是垃圾收集器管理的主要区域。分为新生代和老年代。对于新生代又分为Eden空间、From Survivor空间、To Survivor空间。</li><br></ul></li><br><li><p>JDK1.7 方法区（永久代）</p><br><ul><br><li>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br><br>对这块区域进行垃圾回收的主要目的是对常量池的回收和对类的卸载，但是一般难以实现。<br><br>HotSpot虚拟机把它当做永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素的影响，并且每次Full GC之后永久代的大小都会改变，所以经常抛出OOM异常。<br><br>从JDK1.8开始，移除永久代，并把方法区移至元空间。</li><br><li><p>运行时常量池</p><br><ul><br><li>是方法区的一部分<br><br>Class文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。<br><br>允许动态生成，例如String类的intern()</li><br></ul></li><br></ul></li><br><li><p>JDK1.8 元空间</p><br><ul><br><li>原本存在方法区（永久代）的数据，一部分移到了Java堆里面，一部分移到了本地内存里面（即元空间）。元空间存储类的元信息，静态变量和常量池等放入堆中。</li><br></ul></li><br><li><p>直接内存</p><br><ul><br><li>在NIO中，会使用Native函数库直接分配堆外内存。</li><br></ul></li><br></ul><br><h2 id="二hotspot虚拟机">二、HotSpot虚拟机</h2><br><h3 id="对象的创建">对象的创建</h3><br><ul><br><li>当虚拟机遇到一条new指令时</li><br></ul><br><ol><br><li>检查参数能否在常量池中找到符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始过，没有的话先执行相应的类加载过程。</li><br><li>在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。</li><br><li>内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</li><br><li>对对象头进行必要的设置。</li><br><li>执行构造方法按照程序员的意愿进行初始化。</li><br></ol><br><h3 id="对象的内存布局">对象的内存布局</h3><br><ul><br><li><ol><br><li>对象头</li><br></ol><br><ul><br><li><ol><br><li>第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向实现戳等。</li><br></ol></li><br><li><ol><br><li>第二部分是类型指针，即对象指向它的类元数据的指针（如果使用直接对象指针访问），虚拟机通过这个指针来确定这个对象是哪个类的实例。</li><br></ol></li><br><li><ol><br><li>如果对象是一个Java数组的话，还需要第三部分记录数据长度的数据。</li><br></ol></li><br></ul></li><br><li><ol><br><li>实例数据</li><br></ol><br><ul><br><li>是对象真正存储的有效信息，也就是在代码中定义的各种类型的字段内容。</li><br></ul></li><br><li><ol><br><li>对齐填充</li><br></ol><br><ul><br><li>不是必然存在的，仅仅起着占位符的作用。<br><br>HotSpot需要对象的大小必须是8字节的整数倍。</li><br></ul></li><br></ul><br><h3 id="对象的访问定位">对象的访问定位</h3><br><ul><br><li><p>句柄访问</p><br><ul><br><li>在Java堆中划分出一块内存作为句柄池。<br><br>Java栈上的对象引用reference中存储的就是对象的句柄地址，而句柄中包含了到对象实例数据的指针和到对象类型数据的指针。<br><br>对象实例数据在Java堆中，对象类型数据在方法区（永久代）中。<br><br>优点：在对象被移动时只会改变句柄中的实例数据指针，而对象引用本身不需要修改。</li><br></ul></li><br><li><p>直接指针访问（HotSpot使用）</p><br><ul><br><li>Java栈上的对象引用reference中存储的就是对象的直接地址。<br><br>在堆中的对象实例数据就需要包含到对象类型数据的指针。<br><br>优点：节省了一次指针定位的时间开销，速度更快。</li><br></ul></li><br></ul><br><h2 id="三垃圾收集">三、垃圾收集</h2><br><h3 id="概述">概述</h3><br><ul><br><li>垃圾收集主要是针对Java堆和方法区。<br><br>程序计数器、Java虚拟机栈个本地方法栈三个区域属于线程私有，线程或方法结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</li><br></ul><br><h3 id="判断对象是否可以被回收">判断对象是否可以被回收</h3><br><ul><br><li><p>第一次标记（缓刑）</p><br><ul><br><li><p>引用计数算法</p><br><ul><br><li>给对象添加一个引用计数器，当对象增加一个引用时引用计数值++，引用失效时引用计数值–，引用计数值为0时对象可以被回收。</li><br></ul></li><br></ul></li><br></ul><br><p>但是它难以解决对象之间的相互循环引用的情况，此时这个两个对象引用计数值为1，但是永远无法用到这两个对象。</p><ul><li><p>可达性分析算法（Java使用）</p><ul><li>以一系列GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连是，则证明此对象不可用，可以被回收。<p>GC Roots对象包括</p><br><ol><br><li>虚拟机栈（栈桢中的本地变量表）中引用的对象。</li><br><li>方法区中共类静态属性引用的对象。</li><br><li>方法区中常量引用的对象。</li><br><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li><br></ol><br><ul><br><li><p>第二次标记</p><br><ul><br><li>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过。<br><br>如果对象在finalize方法中重新与引用链上的任何一个对象建立关联则将不会被回收。</li><br><li><p>finalize()</p><br><ul><br><li>任何一个对象的finalize()方法都只会被系统调用一次。<br><br>它的出现是一个妥协，运行代价高昂，不确定性大，无法保证各个对象的调用顺序。<br><br>finalize()能做的所有工作使用try-finally或者其他方式都可以做的更好，完全可以忘记在这个函数的存在。</li><br></ul></li><br></ul></li><br></ul><br><h3 id="方法区的回收">方法区的回收</h3><br><ul><br><li>在方法区进行垃圾回收的性价比一般比较低。<br><br>主要回收两部分，废弃常量和无用的类。</li><br></ul><br><p>满足无用的类三个判断条件才仅仅代表可以进行回收，不是必然关系，可以使用-Xnoclassgc参数控制。</p><br><ol><br><li>该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><br><li>加载该类的ClassLoader已经被回收。</li><br><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问到该类的方法。</li><br></ol><br><h3 id="引用类型">引用类型</h3><br><ul><br><li><ol><br><li>强引用</li><br></ol><br><ul><br><li>使用new一个新对象的方式来创建强引用。<br><br>只要强引用还存在，被引用的对象则永远不会被回收。</li><br></ul></li><br><li><ol><br><li>软引用</li><br></ol><br><ul><br><li>使用SoftReference类来实现软引用。<br><br>用来描述一些还有用但是并非必须的对象，被引用的对象在将要发生内存溢出异常之前会被回收。</li><br></ul></li><br><li><ol><br><li>弱引用</li><br></ol><br><ul><br><li>使用WeakReference类来实现弱引用。<br><br>强度比软引用更弱一些，被引用的对象在下一次垃圾收集时会被回收。</li><br></ul></li><br><li><ol><br><li>虚引用</li><br></ol><br><ul><br><li>使用PhantomReference类来实现虚引用。<br><br>最弱的引用关系，不会对被引用的对象生存时间构成影响，也无法通过虚引用来取得一个对象实例。<br><br>唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li><br></ul></li><br></ul><br><h3 id="垃圾收集算法">垃圾收集算法</h3><br><ul><br><li><ol><br><li>标记 - 清除</li><br></ol><br><ul><br><li>首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象并取消标记。</li><br></ul></li><br></ul><br><p>不足：</p><br><ol><br><li>效率问题，标记和清除两个过程的效率都不高。</li><br><li>空间问题，标记清除之后会产生大量不连续的内存碎片，没有连续内存容纳较大对象而不得不提前触发另一次垃圾收集。</li><br></ol><br><ul><br><li><ol><br><li>标记 - 整理</li><br></ol><br><ul><br><li>和标记 - 清除算法一样，但标记之后让所有存活对象都向一段移动，然后直接清理掉端边界以外的内存。<br><br>解决了标记 - 清除算法的空间问题，但需要移动大量对象，还是存在效率问题。</li><br></ul></li><br><li><ol><br><li>复制</li><br></ol><br><ul><br><li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用多的内存空间一次清理掉。<br><br>代价是将内存缩小为原来的一般，太高了。</li><br></ul></li><br></ul><br><p>现在商业虚拟机都采用这种算法用于新生代。<br><br>因为新生代中的对象98%都是朝生暮死，所以将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间。<br><br>当回收时，如果另外一块Survivor空间没有足够的空间存放存活下来的对象时，这些对象将直接通过分配担保机制进入老年代。</p><br><ul><br><li><ol><br><li>分代收集</li><br></ol><br><ul><br><li>一般把Java堆分为新生代和老年代。<br><br>在新生代中使用复制算法，在老年代中使用标记 -清除 或者 标记 - 整理 算法来进行回收。</li><br></ul></li><br></ul><br><h3 id="hotspot的算法实现">HotSpot的算法实现</h3><br><ul><br><li><p>枚举根节点（GC Roots）</p><br><ul><br><li>目前主流Java虚拟机使用的都是准确式GC。<br><br>GC停顿的时候，虚拟机可以通过OopMap数据结构（映射表）知道，在对象内的什么偏移量上是什么类型的数据，而且特定的位置记录着栈和寄存器中哪些位置是引用。因此可以快速且准确的完成GC Roots枚举。</li><br></ul></li><br><li><p>安全点</p><br><ul><br><li>为了节省GC的空间成本，并不会为每条指令都生成OopMap，只是在“特定的位置”记录OopMap，这些位置称为安全点。</li><br></ul></li><br></ul><br><p>程序执行只有到达安全点时才能暂停，到达安全点有两种方案。</p><br><ol><br><li>抢断式中断（几乎不使用）。GC时，先把所有线程中断，如果有线程不在安全点，就恢复该线程，让他跑到安全点。</li><br><li>主动式中断（主要使用）。GC时，设置一个标志，各个线程执行到安全点时轮询这个标志，发现标志为直则挂起线程。</li><br></ol><br><p>但是当线程sleep或blocked时无法响应JVM的中断请求走到安全点中断挂起，所以引出安全区域。</p><br><ul><br><li><p>安全区域</p><br><ul><br><li>安全区域是指在一段代码片段之中，引用关系不会发生变化，是扩展的安全点。</li><br></ul></li><br></ul><br><p>线程进入安全区域时表示自己进入了安全区域，这个发生GC时，JVM就不需要管这个线程。<br><br>线程离开安全区域时，检查系统是否完成GC过程，没有就等待可以离开安全区域的信号为止，否者继续执行。</p><br><h3 id="垃圾收集器">垃圾收集器</h3><br><ul><br><li><p>新生代</p><br><ul><br><li><ol><br><li>serial收集器</li><br></ol><br><ul><br><li>它是单线程收集器，只会使用一个线程进行垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程。</li><br></ul></li><br></ul></li><br></ul><br><p>优点：对比其他单线程收集器简单高效，对于单个CPU环境来说，没有线程交互的开销，因此拥有最高的单线程收集效率。</p><br><p>它是Client场景下默认新生代收集器，因为在该场景下内存一般来说不会很大。</p></li><li><ol start="2"><li>parnew收集器</li></ol></li><li><p>它是Serial收集器的多线程版本，公用了相当多的代码。</p><p>在单CPU环境中绝对不会有比Serial收集器更好的效果，甚至在2个CPU环境中也不能百分之百超越。</p><br><p>它是Server场景下默认的新生代收集器，主要因为除了Serial收集器，只用它能与CMS收集器配合使用。</p></li><li><ol start="3"><li>parallel scavenge收集器</li></ol></li><li><p>“吞吐优先”收集器，与ParNew收集器差不多。</p><p>但是其他收集器的目标是尽可能缩短垃圾收集时用户线程停顿的时间，而它的目标是达到一个可控制的吞吐量。这里的吞吐量指CPU用于运行用户程序的时间占总时间的比值。</p><br><ul><br><li><p>老年代</p><br><ul><br><li><ol><br><li>serial old收集器</li><br></ol><br><ul><br><li>是Serial收集器老年代版本。</li><br></ul></li><br></ul></li><br></ul><br><p>也是给Client场景下的虚拟机使用的。</p></li><li><ol start="5"><li>parallel old收集器</li></ol></li><li><p>是Parallel Scavenge收集器的老年代版本。</p><p>在注重吞吐量已经CPU资源敏感的场合，都可以优先考虑Parallel Scavenge和Parallel Old收集器。</p></li><li><ol start="6"><li>cms收集器</li></ol></li><li><p>Concurrent Mark Sweep收集器是一种以获取最短回收停顿时间为目标的收集器。</p></li><li><p>运作过程</p><ul><li><ol><li>初始标记（最短）。仍需要暂停用户线程。只是标记一下GC Roots能直接关联到的对象，速度很快<br><ol><br><li>并发标记（耗时最长）。进行GC Roots Tracing（根搜索算法）的过程。</li><br><li>重新标记。修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比初始标记长但远小于并发标记时间。</li><br><li>并发清除</li><br></ol><p>1 和4 两个步骤并没有带上并发两个字，即这两个步骤仍要暂停用户线程。</p></li></ol></li></ul></li><li><p>优缺点</p><ul><li>并发收集、低停顿。<br><ol><br><li>CMS收集器对CPU资源非常敏感。虽然不会导致用户线程停顿，但是占用CPU资源会使应用程序变慢。</li><br><li>无法处理浮动垃圾。在并发清除阶段新垃圾还会不断的产生，所以GC时要控制“-XX:CMSinitiatingOccupancyFraction参数”预留足够的内存空间给这些垃圾，当预留内存无法满足程序需要时就会出现”Concurrent Mode Failure“失败，临时启动Serial Old收集。</li><br><li>由于使用标记 - 清除算法，收集之后会产生大量空间碎片。</li><br></ol><br><ul><br><li><ol><br><li>g1收集器</li><br></ol><br><ul><br><li>Garbage First是一款面向服务端应用的垃圾收集器</li><br><li><p>运作过程</p><br><ul><br><li><ol><br><li>初始标记</li><br></ol></li><br></ul></li><br></ul></li><br></ul><br><ol><br><li>并发标记</li><br><li>最终标记</li><br><li>删选标记</li><br></ol><br><h2 id="五类加载机制">五、类加载机制</h2><br><h3 id="概述-1">概述</h3><br><ul><br><li>虚拟机把描述类的数据从Class问价加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。<br><br>Java应用程序的高度灵活性就是依赖运行期动态加载和动态连接实现的。</li><br></ul><br><h3 id="类的生命周期">类的生命周期</h3><br><ul><br><li>加载 -&gt; 连接（验证 -&gt; 准备 -&gt; 解析） -&gt; 初始化 -&gt; 使用 - &gt;卸载</li><br></ul><br><h3 id="类初始化时机">类初始化时机</h3><br><ul><br><li><p>主动引用</p><br><ul><br><li>虚拟机规范中没有强制约束何时进行加载，但是规定了有且只有五种情况必须对类进行初始化（加载、验证、准备都会随之发生）</li><br></ul></li><br></ul><br><ol><br><li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时没有初始化。</li><br><li>反射调用时没有初始化。</li><br><li>发现其父类没有初始化则先触发其父类的初始化。</li><br><li>包含psvm（mian（）方法）的那个类。</li><br><li>动态语言支持时，REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄。</li><br></ol><br><ul><br><li><p>被动引用</p><br><ul><br><li>除上面五种情况之外，所有引用类的方式都不会触发初始化，称为被动引用。</li><br></ul></li><br></ul><br><ol><br><li>通过子类引用父类的静态字段，不会导致子类的初始化。</li><br><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承Object的子类，其中包含数组的属性和方法，用户只能使用public的length和clone()。</li><br><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li><br></ol><br><h3 id="类加载过程">类加载过程</h3><br><ul><br><li><ol><br><li>加载</li><br></ol><br><ul><br><li><ol><br><li>通过类的全限定名来获取定义此类的二进制字节流。</li><br></ol></li><br></ul></li><br></ul><br><ol><br><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><br><li>在内存中生成一个代表这个类的java.lang.Class对象（HotSpot将其存放在方法区中），作为方法区这个类的各种数据的访问入口。</li><br></ol><br><ul><br><li><ol><br><li>验证</li><br></ol><br><ul><br><li>为了确保Class文件的字节类中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。可以通过-Xverify:none关闭大部分类验证。</li><br></ul></li><br></ul><br><ol><br><li>文件格式验证。确保输入字节流能正确的解析并存储于方法区，后面的3个验证全部基于方法区的存储结构进行，不会再操作字节流。</li><br><li>元数据验证。对字节码描述信息进行语义分析，确保其符合Java语法规范。（Java语法验证）</li><br><li>字节码验证。最复杂，通过数据流和控制流分析，确定程序语义时合法的、符合逻辑的。可以通过参数关闭。（验证指令跳转范围，类型转换有效等）</li><br><li>符号引用验证。将符号引用转化为直接引用，发生在第三个阶段——解析阶段中发生。</li><br></ol><br><ul><br><li><ol><br><li>准备</li><br></ol><br><ul><br><li>类变量是被static修饰的变量，准备阶段为类变量分配内存并设置零值（final直接设置初始值），使用的是方法区的内存。</li><br></ul></li><br><li><ol><br><li>解析</li><br></ol><br><ul><br><li>将常量池内的符号引用替换为直接引用的过程。<br><br>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的动态绑定。<br><br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、和调用点限定符。</li><br></ul></li><br><li><ol><br><li>初始化</li><br></ol><br><ul><br><li><p>初始化阶段才真正执行类中定义的Java程序代码，是执行类构造器<clinit>()方法的过程。<br><br>在准备阶段，类变量已经给过零值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。</clinit></p><br><ul><br><li><p><clinit>()</clinit></p><br><ul><br><li>类构造器方法。是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的的语句合并产生的。</li><br></ul></li><br></ul></li><br></ul></li><br></ul><br><ol><br><li>不需要显式调用父类构造器，JVM会保证在子类clinit执行之前，父类的clinit已经执行完成。</li><br><li>接口中不能使用静态语句块但仍可以有类变量的赋值操作。当没有使用父接口中定义的变量时子接口的c</li></ol></li></ul></li></ul></li></ul><p><li>接口中不能使用静态语句块但仍可以有类变量的赋值操作。当没有使用父接口中定义的变量时子接口的clinit不需要先执行父接口的clinit方法。接口的实现类也不会执行接口的clinit方法。</li></p><p><li><p>虚拟机会保证clinit在多线程环境中被正确的加锁、同步。其他线性唤醒之后不会再进入clinit方法，同一个类加载器下，一个类型只会初始化一次。</p></li></p><ul><li><p>&lt;init&gt;()</p><ul><li>对象构造器方法。Java对象被创建时才会进行实例化操作，对非静态变量解析初始化。</li><br><li><p>会显式的调用父类的init方法，对象实例化过程中对实例域的初始化操作全部在init方法中进行。</p></li><br><br><h3 id="类加载-器">类（加载） 器</h3><ul><br><li><p>类与类加载器</p><br><ul><br><li>类加载器实现类的加载动作。<br><br>类加载器和这个类本身一同确立这个类的唯一性，每个类加载器都有独立的类命名空间。在同一个类加载器加载的情况下才会有两个类相等。<br><br>相等包括类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()、instanceof关键字。</li><br></ul></li><br><li><p>类加载器分类</p><br><ul><br><li><p>启动类加载器</p><br><ul><br><li>由C++语言实现，是虚拟机的一部分。负责将JAVA_HOME/lib目录中，或者被-Xbootclasspath参数指定的路径，但是文件名要能被虚拟机识别，名字不符合无法被启动类加载器加载。启动类加载器无法被Java程序直接引用。</li><br></ul></li><br><li><p>扩展类加载器</p><br><ul><br><li>由Java语言实现，负责加载JAVA_HOME/lib/ext目录，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li><br></ul></li><br><li><p>应用程序类加载器</p><br><ul><br><li>由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称他为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，一般情况下这个就是程序中默认的类加载器。</li><br></ul></li><br><li><p>自定义类加载器</p><br><ul><br><li>由用户自己实现。</li><br></ul></li><br></ul></li><br></ul><br><ol><br><li>如果不想打破双亲委派模型，那么只需要重写findClass方法即可。</li><br><li>否则就重写整个loadClass方法。</li><br></ol><br><ul><br><li><p>双亲委派模型</p><br><ul><br><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。父子不会以继承的关系类实现，而是都是使用组合关系来服用父加载器的代码。<br><br>在java.lang.ClassLoader的loadClass()方法中实现。</li><br><li><p>工作过程</p><br><ul><br><li>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成（它的搜索范围中没有找到所需要的类）时才尝试自己加载</li><br></ul></li><br><li><p>好处</p><br><ul><br><li>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，从而使得基础类库得到同意。</li><br></ul></li><br></ul></li><br></ul><br><h2 id="四内存分配与回收策略">四、内存分配与回收策略</h2><br><h3 id="minor-gc-和-full-gc">Minor GC 和 Full GC</h3><br><ul><br><li><p>Minor GC</p><br><ul><br><li>发生在新生代的垃圾收集动作，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行速度快。</li><br><li><p>时机</p><br><ul><br><li>Eden不足</li><br></ul></li><br></ul></li><br><li><p>Full GC</p><br><ul><br><li>发生在老年区的GC，出现Full GC时往往伴随着Minor GC，比Minor GC慢10倍以上。</li><br><li><p>时机</p><br><ul><br><li><ol><br><li>调用System.gc()</li><br></ol><br><ul><br><li>只是建议虚拟机执行Full GC，但是虚拟机不一定真正去执行。<br><br>不建议使用这种方式，而是让虚拟机管理内存。</li><br></ul></li><br><li><ol><br><li>老年代空间不足</li><br></ol><br><ul><br><li>常见场景就是大对象和长期存活对象进入老年代。<br><br>尽量避免创建过大的对象以及数组，调大新生代大小，让对象尽量咋新生代中被回收，不进入老年代。</li><br></ul></li><br><li><ol><br><li>JDK1.7 之前方法区空间不足</li><br></ol><br><ul><br><li>当系统中要加载的类、反射的类和常量较多时，永久代可能会被占满，在未配置CMS GC的情况下也会执行Full GC，如果空间仍然不够则会抛出OOM异常。<br><br>可采用增大方法区空间或转为使用CMS GC。</li><br></ul></li><br><li><ol><br><li>空间分配担保失败</li><br></ol><br><ul><br><li>发生Minor GC时分配担保的两个判断失败</li><br></ul></li><br><li><ol><br><li>Concurrent Mode Failure</li><br></ol><br><ul><br><li>CMS GC 并发清理阶段用户线程还在执行，不断有新的浮动垃圾产生，当预留空间不足时报Concurrent Mode Failure错误并触发Full GC。</li><br></ul></li><br></ul></li><br></ul></li><br></ul><br><h3 id="内存分配策略">内存分配策略</h3><br><ul><br><li><ol><br><li>对象优先在Eden分配</li><br></ol><br><ul><br><li>大多数情况下，对象在新生代Eden上分配，当Eden空间不够时，发起Minor GC，当另外一个Survivor空间不足时则将存活对象通过分配担保机制提前转移到老年代。</li><br></ul></li><br><li><ol><br><li>大对象直接进入老年代</li><br></ol><br><ul><br><li>配置参数-XX:PretenureSizeThreshold，大于此值得对象直接在老年代分配，避免在Eden和Survivor之间的大量内存复制。</li><br></ul></li><br><li><ol><br><li>长期存活对象进入老年代</li><br></ol><br><ul><br><li>虚拟机为每个对象定义了一个Age计数器，对象在Eden出生并经过Minor GC存活转移到另一个Survivor空间中时Age++，增加到默认16则转移到老年代。</li><br></ul></li><br><li><ol><br><li>动态对象年龄绑定</li><br></ol><br><ul><br><li>虚拟机并不是永远要求对象的年龄必须到达MaxTenuringThreshold才能晋升老年代，如果在Survivor中相同年龄所有对象大小总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。</li><br></ul></li><br><li><ol><br><li>空间分配担保</li><br></ol><br><ul><br><li>在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代的所有对象，如果条件成立，那么Minor GC可以认为是安全的。<br><br>可以通过HandlePromotionFailure参数设置允许冒险，此时虚拟机将与历代晋升到老年区对象的平均大小比较，仍小于则要进行一次Full GC。<br><br>在JDK1.6.24之后HandlePromotionFailure已无作用，即虚拟机默认为true。</li><br></ul></li><br></ul></ul></li></ul>]]></content>
    
    <summary type="html">
    
      JVM原理速记复习Java虚拟机总结思维导图面试必备
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Everything about ArrayList</title>
    <link href="http://yoursite.com/2020/02/08/Everything-about-ArrayList/"/>
    <id>http://yoursite.com/2020/02/08/Everything-about-ArrayList/</id>
    <published>2020-02-07T16:53:26.000Z</published>
    <updated>2020-03-21T06:09:41.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-ArrayList底层实现原理源码详细分析Jdk8"><a href="#Java-ArrayList底层实现原理源码详细分析Jdk8" class="headerlink" title="Java ArrayList底层实现原理源码详细分析Jdk8"></a>Java ArrayList底层实现原理源码详细分析Jdk8</h1><p><li>ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。</li></p><p><li><strong>ArrayList不是线程安全的</strong>，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。</li></p><p><li>ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。</li><br></p><h4 id="存储结构">存储结构</h4><br><pre class="java"><code>// 当前数据对象存放地方，当前对象不参与序列化<br>// 这个关键字最主要的作用就是当序列化时，被transient修饰的内容将不会被序列化<br>transient Object[] elementData;</code></pre><br><ul><br><li><p>Object类型数组。</p><br><h4 id="数据域">数据域</h4></li><br></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化ID</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">  <span class="comment">// 默认初始容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 一个空数组，方便使用，主要用于带参构造函数初始化和读取序列化对象等。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 和官方文档写的一样，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和EMPTY_ELEMENTDATA 的区别</span></span><br><span class="line"><span class="comment">   * 仅仅是为了区别用户带参为0的构造和默认构造的惰性初始模式对象。</span></span><br><span class="line"><span class="comment">   * 当用户带参为0的构造，第一次add时，数组容量grow到1。</span></span><br><span class="line"><span class="comment">   * 当用户使用默认构造时，第一次add时，容量直接grow到DEFAULT_CAPACITY（10）。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前数据对象存放地方，当前对象不参与序列化</span></span><br><span class="line">  <span class="comment">// 这个关键字最主要的作用就是当序列化时，被transient修饰的内容将不会被序列化</span></span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">  <span class="comment">// 当前数组中元素的个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// 数组最大可分配容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">  <span class="comment">// 集合数组修改次数的标识（由AbstractList继承下来）（fail-fast机制）</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>ArrayList的无参构造函数。<strong>初始化的时候并没有真正的创建10个空间，这是惰性初始模式对象。</strong></li><br><li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和EMPTY_ELEMENTDATA 的区别仅仅是为了区别用户带参为0的构造和默认构造的惰性初始模式对象。</li><br><li>modCount用来记录ArrayList结构发生变化的次数。用于<a href="#q1">Fail-Fast机制</a></li><br></ul><br><br><h4 id="构造函数">构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 只有这个地方会引用DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">     <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 使用 EMPTY_ELEMENTDATA，在其他的多个地方可能会引用EMPTY_ELEMENTDATA</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(&amp;quot;Illegal Capacity: &amp;quot;+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&amp;lt;? extends E&amp;gt; c)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 把传入集合传化成[]数组并浅拷贝给elementData</span></span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="comment">// 转化后的数组长度赋给当前ArrayList的size,并判断是否为0</span></span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//c.toArray可能不会返回 Object[]，可以查看 java 官方编号为 6260652 的 bug</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             <span class="comment">// 若 c.toArray() 返回的数组类型不是 Object[]，则利用 Arrays.copyOf(); 来构造一个大小为 size 的 Object[] 数组</span></span><br><span class="line">             <span class="comment">// 此时elementData是指向传入集合的内存，还需要创建新的内存区域深拷贝给elementData</span></span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 传入数组size为零替换空数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><br><li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和EMPTY_ELEMENTDATA 的区别仅仅是为了区别用户带参为0的构造和默认构造的惰性初始模式对象。</li><br><li>注意<strong>深拷贝和浅拷贝</strong>。</li><br><li><p>带参为0的构造会惰性初始化，不为0的构造则不会惰性初始化。</p><br><h4 id="add源码解析">add()源码解析</h4></li><br></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确保数组已使用长度（size）加1之后足够存下 下一个数据</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">// 数组的下一个index存放传入元素。</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="comment">// 始终返回true。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里就是DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和</span></span><br><span class="line">        <span class="comment">// EMPTY_ELEMENTDATA 最主要的区别。</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">// 默认构造第一次add返回10。</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 带参为0构造第一次add返回 1 （0 + 1）。</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自增修改计数</span></span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">// 当前数组容量小于需要的最小容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &amp;gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 准备扩容数组</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">// 获得当前数组容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">// 新数组容量为1.5倍的旧数组容量</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &amp;lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 若 newCapacity 依旧小于 minCapacity</span></span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">            <span class="comment">// 判断是需要的容量是否超过最大的数组容量。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &amp;gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        <span class="comment">// 在Arrays.copyOf()中会将原数组整个赋值到扩容的数组中。</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>扩容操作需要调用Arrays.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建ArrayList对象时就指定大概的容量大小，减少扩容操作的次数。</li><br></ul><br><h4 id="addint-index-e-element源码分析">add(int index, E element)源码分析</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个本地方法，由C语言实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  // 源数组</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span>  srcPos, // 源数组要复制的起始位置</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, // 目标数组（将原数组复制到目标数组）</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> destPos, // 目标数组起始位置（从目标数组的哪个下标开始复制操作）</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length   // 复制源数组的长度</span></span></span><br><span class="line"><span class="function"><span class="params">                                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断索引是否越界</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">// 确保数组已使用长度（size）加1之后足够存下 下一个数据</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">// 运行到这里代表数组容量满足。</span></span><br><span class="line">        <span class="comment">// 数组从传入形参index处开始复制，复制size-index个元素（即包括index在内后面的元素全部复制），</span></span><br><span class="line">        <span class="comment">// 从数组的index + 1处开始粘贴。</span></span><br><span class="line">        <span class="comment">// 这时，index 和 index + 1处元素数值相同。</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        <span class="comment">// 把index处的元素替换成新的元素。</span></span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">// 数组内元素长度加一。</span></span><br><span class="line">        size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>需要调用System.arraycopy()将包括index在内后面的元素都复制到index + 1位置上，该操作的时间复杂度为O(N)，可以看出ArrayList数组头增加元素的代价是非常高的。</li><br></ul><br><h4 id="removeint-index源码分析">remove(int index)源码分析</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查index</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &amp;gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 和 add(int index, E element)原理想通。</span></span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        <span class="comment">// 引用计数为0，会自动进行垃圾回收。</span></span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="comment">// 返回旧元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>需要调用System.arraycopy()将包括index + 1在内后面的元素都复制到index位置上，该操作的时间复杂度为O(N)，可以看出ArrayList数组头增加元素的代价是非常高的。</li><br></ul><br><h4 id="q1">Fail-Fast机制</h4><br><p>fail-fast 机制，即快速失败机制，是java集合(Collection)中的一种错误检测机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出ConcurrentModificationException异常。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。</p><br><ul><br><li>结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组大小，仅仅只是设置元素的值不算结构发生变化。</li><br><li>在进行序列化或者迭代操作时，需要比较操作前后modCount是否改变，如果改变了需要跑出ConcurrentModificationException</li><br></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&amp;<span class="title">lt</span></span>;E&amp;gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;</span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 期待的修改值等于当前修改次数（modCount）</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 检查 expectedModCount是否等于modCount，不相同则抛出ConcurrentModificationException</span></span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">/** 省略此处代码 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lastRet &amp;lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">/** 省略此处代码 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount == <span class="keyword">this</span>.expectedModCount)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><p>一个单线程环境下的fail-fast的例子</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&amp;lt;String&amp;gt; list = <span class="keyword">new</span> ArrayList&amp;lt;&amp;gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &amp;lt; <span class="number">10</span> ; i++ ) &#123;</span><br><span class="line">            list.add(i + &amp;quot;&amp;quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       Iterator&amp;lt;String&amp;gt; iterator = list.iterator();</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                 list.remove(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            i ++;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><br><h4 id="序列化">序列化</h4><br><p>ArrayList 实现了 java.io.Serializable 接口，但是自己定义了序列化和反序列化。因为ArrayList基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没有<strong>必要全部进行序列化</strong>。因此 elementData 数组使用 transient 修饰，可以防止被自动序列化。</p><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        <span class="comment">// 将当前类的非静态(non-static)和非瞬态(non-transient)字段写入流</span></span><br><span class="line">        <span class="comment">// 在这里也会将size字段写入。</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        <span class="comment">// 序列化数组包含元素数量，为了向后兼容</span></span><br><span class="line">        <span class="comment">// 两次将size写入流</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="comment">// 按照顺序写入，只写入到数组包含元素的结尾，并不会把数组的所有容量区域全部写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否触发Fast-Fail</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置数组引用空数组。</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        <span class="comment">// 将流中的的非静态(non-static)和非瞬态(non-transient)字段读取到当前类</span></span><br><span class="line">        <span class="comment">// 包含 size</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            <span class="comment">// 根据size计算容量。</span></span><br><span class="line">            <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">            <span class="comment">// SharedSecrets 一个“共享机密”存储库，它是一种机制，</span></span><br><span class="line">            <span class="comment">// 用于调用另一个包中的实现专用方法，而不使用反射。TODO</span></span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">            <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><p>ArrayList中为什么size要序列化两次？</p><br><blockquote><br><p>在代码中s.defaultWriteObject();中size应该也被序列化了，为什么下边还要再单独序列化一次呢？<br><br>这样写是出于兼容性考虑。<br><br>旧版本的JDK中，ArrayList的实现有所不同，会对length字段进行序列化。<br><br>而新版的JDK中，对优化了ArrayList的实现，不再序列化length字段。<br><br>这个时候，如果去掉s.writeInt(size)，那么新版本JDK序列化的对象，在旧版本中就无法正确读取，<br><br>因为缺少了length字段。<br><br>因此这种写法看起来多此一举，实际上却保证了兼容性。</p><br></blockquote><br><br>### 小结<br><ul><br><li>ArrayList基于数组方式实现，无容量的限制（会扩容）</li><br><li>添加元素时可能要扩容（所以最好预判一下），删除元素时不会减少容量（若希望减少容量可以使用trimToSize()），删除元素时，将删除掉的位置元素置为null，下次gc就会回收这些元素所占的内存空间。</li><br><li>线程不安全</li><br><li>add(int index, E element)：添加元素到数组中指定位置的时候，需要将该位置及其后边所有的元素都整块向后复制一位</li><br><li>get(int index)：获取指定位置上的元素时，可以通过索引直接获取（O(1)）</li><br><li>remove(Object o)需要遍历数组</li><br><li>remove(int index)不需要遍历数组，只需判断index是否符合条件即可，效率比remove(Object o)高</li><br><li>contains(E)需要遍历数组</li><br></ul><p><a href="https://www.cnblogs.com/renjiaqi/p/10403725.html" target="_blank" rel="noopener">面试必会之ArrayList源码分析&amp;手写ArrayList</a></p>]]></content>
    
    <summary type="html">
    
      Java ArrayList底层实现原理源码详细分析Jdk8
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>The data structure and algorithm behind the MySQL index</title>
    <link href="http://yoursite.com/2020/02/05/The-data-structure-and-algorithm-behind-the-MySQL-index/"/>
    <id>http://yoursite.com/2020/02/05/The-data-structure-and-algorithm-behind-the-MySQL-index/</id>
    <published>2020-02-05T15:14:29.000Z</published>
    <updated>2020-02-27T09:15:26.658Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>文章主要内容分为三个部分。</p><p></p><p></p><p>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。</p><p></p><p></p><p>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</p><p></p><p></p><p>第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。<br><a id="more"></a><br></p><p></p><p></p><h1><a name="nav-2"></a>数据结构及算法基础</h1><p></p><p></p><h2><a name="nav-2-1"></a>索引的本质</h2><p></p><p></p><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p></p><p></p><p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是<a href="http://en.wikipedia.org/wiki/Linear_search" target="_blank">顺序查找</a>（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm" target="_blank">二分查找</a>（binary search）、<a href="http://en.wikipedia.org/wiki/Binary_search_tree" target="_blank">二叉树查找</a>（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于<a href="http://en.wikipedia.org/wiki/Binary_search_tree" target="_blank">二叉查找树</a>上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p></p><p></p><p>看一个例子：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/1.png"></p><p></p><p></p><p align="center">图1</p><p></p><p></p><p>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在(O(log_2n))的复杂度内获取到相应数据。</p><p></p><p></p><p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种<a href="http://en.wikipedia.org/wiki/Red-black_tree" target="_blank">红黑树</a>（red-black tree）实现的，原因会在下文介绍。</p><p></p><p></p><h2><a name="nav-2-2"></a>B-Tree和B+Tree</h2><p></p><p></p><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p><p></p><p></p><h3>B-Tree</h3><p></p><p></p><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p><p></p><p></p><p>d为大于1的一个正整数，称为B-Tree的度。</p><p></p><p></p><p>h为一个正整数，称为B-Tree的高度。</p><p></p><p></p><p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p><p></p><p></p><p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p><p></p><p></p><p>所有叶节点具有相同的深度，等于树高h。</p><p></p><p></p><p>key和指针互相间隔，节点两端是指针。</p><p></p><p></p><p>一个节点中的key从左到右非递减排列。</p><p></p><p></p><p>所有节点组成树结构。</p><p></p><p></p><p>每个指针要么为null，要么指向另外一个节点。</p><p></p><p></p><p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于(v(key_1))，其中(v(key_1))为node的第一个key的值。</p><p></p><p></p><p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于(v(key_m))，其中(v(key_m))为node的最后一个key的值。</p><p></p><p></p><p>如果某个指针在节点node的左右相邻key分别是(key_i)和(key_{i+1})且不为null，则其指向节点的所有key小于(v(key_{i+1}))且大于(v(key_i))。</p><p></p><p></p><p>图2是一个d=2的B-Tree示意图。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/2.png"></p><p></p><p></p><p align="center">图2</p><p></p><p></p><p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre <span class="class"><span class="keyword">class</span></span>=<span class="string">"prettyprint linenums"</span>&gt;BTree_Search(node, key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    foreach(node.key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.key[i] == key) <span class="keyword">return</span> node.data[i];</span><br><span class="line">            <span class="keyword">if</span>(node.key[i] &amp;gt; key) <span class="keyword">return</span> BTree_Search(point[i]-&amp;gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BTree_Search(point[i+<span class="number">1</span>]-&amp;gt;node);</span><br><span class="line">&#125;</span><br><span class="line">data = BTree_Search(root, my_key);&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p></p><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为(log_d((N+1)/2))，检索一个key，其查找节点个数的渐进复杂度为(O(log_dN))。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><p></p><p></p><p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p><p></p><p></p><h3>B+Tree</h3><p></p><p></p><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p><p></p><p></p><p>与B-Tree相比，B+Tree有以下不同点：</p><p></p><p></p><p>每个节点的指针上限为2d而不是2d+1。</p><p></p><p></p><p>内节点不存储data，只存储key；叶子节点不存储指针。</p><p></p><p></p><p>图3是一个简单的B+Tree示意。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/3.png"></p><p></p><p></p><p align="center">图3</p><p></p><p></p><p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p><p></p><p></p><p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p><p></p><p></p><h3>带有顺序访问指针的B+Tree</h3><p></p><p></p><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/4.png"></p><p></p><p></p><p align="center">图4</p><p></p><p></p><p>如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><p></p><p></p><p>这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p><p></p><p></p><h2><a name="nav-2-3"></a>为什么使用B-Tree（B+Tree）</h2><p></p><p></p><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p><p></p><p></p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><p></p><p></p><h3>主存存取原理</h3><p></p><p></p><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/5.png"></p><p></p><p></p><p align="center">图5</p><p></p><p></p><p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p><p></p><p></p><p>主存的存取过程如下：</p><p></p><p></p><p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p><p></p><p></p><p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p><p></p><p></p><p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><p></p><p></p><h3>磁盘存取原理</h3><p></p><p></p><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p></p><p></p><p>图6是磁盘的整体结构示意图。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/6.png"></p><p></p><p></p><p align="center">图6</p><p></p><p></p><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p></p><p></p><p>图7是磁盘结构的示意图。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/7.png"></p><p></p><p></p><p align="center">图7</p><p></p><p></p><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p></p><p></p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><p></p><p></p><h3>局部性原理与磁盘预读</h3><p></p><p></p><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><p></p><p></p><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p><p></p><p></p><p>程序运行期间所需要的数据通常比较集中。</p><p></p><p></p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p></p><p></p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p></p><p></p><h3>B-/+Tree索引的性能分析</h3><p></p><p></p><p>到这里终于可以分析B-/+Tree索引的性能了。</p><p></p><p></p><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p></p><p></p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p></p><p></p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为(O(h)=O(log_dN))。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p></p><p></p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p></p><p></p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p><p></p><p></p><p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p><p></p><p></p><p>(d_{max}=floor(pagesize / (keysize + datasize + pointsize)))</p><p></p><p></p><p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p><p></p><p></p><p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p><p></p><p></p><h1><a name="nav-3"></a>MySQL索引实现</h1><p></p><p></p><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><p></p><p></p><h2><a name="nav-3-1"></a>MyISAM索引实现</h2><p></p><p></p><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/8.png"></p><p></p><p></p><p align="center">图8</p><p></p><p></p><p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/9.png"></p><p></p><p></p><p align="center">图9</p><p></p><p></p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><p></p><p></p><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><p></p><p></p><h2><a name="nav-3-2"></a>InnoDB索引实现</h2><p></p><p></p><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p></p><p></p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/10.png"></p><p></p><p></p><p align="center">图10</p><p></p><p></p><p>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p></p><p></p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/11.png"></p><p></p><p></p><p align="center">图11</p><p></p><p></p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p></p><p></p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><p></p><p></p><p>下一章将具体讨论这些与索引有关的优化策略。</p><p></p><p></p><h1><a name="nav-4"></a>索引使用策略及优化</h1><p></p><p></p><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。</p><p></p><p></p><h2><a name="nav-4-1"></a>示例数据库</h2><p></p><p></p><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/12.png"></p><p></p><p></p><p align="center">图12</p><p></p><p></p><p>MySQL官方文档中关于此数据库的页面为<a title="http://dev.mysql.com/doc/employee/en/employee.html" href="http://dev.mysql.com/doc/employee/en/employee.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/employee/en/employee.html</a>。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。</p><p></p><p></p><h2><a name="nav-4-2"></a>最左前缀原理与相关优化</h2><p></p><p></p><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p><p></p><p></p><p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</p><p></p><p></p><p>以employees.titles表为例，下面先查看其上都有哪些索引：</p><p></p><p><pre class="prettyprint linenums">SHOW INDEX FROM employees.titles;<br>+——–+————+———-+————–+————-+———–+————-+——+————+<br>| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |<br>+——–+————+———-+————–+————-+———–+————-+——+————+<br>| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      |<br>| titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      |<br>| titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      |<br>| titles |          1 | emp_no   |            1 | emp_no      | A         |      443308 |      | BTREE      |<br>+——–+————+———-+————–+————-+———–+————-+——+————+</pre></p><p></p><p>从结果中可以到titles表的主索引为&lt;emp_no, title, from_date&gt;，还有一个辅助索引&lt;emp_no&gt;。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：</p><p></p><p><pre class="prettyprint linenums">ALTER TABLE employees.titles DROP INDEX emp_no;</pre></p><p></p><p>这样就可以专心分析索引PRIMARY的行为了。</p><p></p><p></p><h3>情况一：全列匹配。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND title=’Senior Engineer’ AND from_date=’1986-06-26’;<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+</pre></p><p></p><p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE from_date=’1986-06-26’ AND emp_no=’10001’ AND title=’Senior Engineer’;<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+</pre></p><p></p><p>效果是一样的。</p><p></p><p></p><h3>情况二：最左前缀匹配。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’;<br>+—-+————-+——–+——+—————+———+———+——-+——+——-+<br>| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |<br>+—-+————-+——–+——+—————+———+———+——-+——+——-+<br>|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |<br>+—-+————-+——–+——+—————+———+———+——-+——+——-+</pre></p><p></p><p>当查询条件精确匹配索引的左边连续一个或几个列时，如&lt;emp_no&gt;或&lt;emp_no, title&gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</p><p></p><p></p><h3>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND from_date=’1986-06-26’;<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+</pre></p><p></p><p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p><p></p><p></p><p>首先我们看下title一共有几种不同的值：</p><p></p><p><pre class="prettyprint linenums">SELECT DISTINCT(title) FROM employees.titles;<br>+——————–+<br>| title              |<br>+——————–+<br>| Senior Engineer    |<br>| Staff              |<br>| Engineer           |<br>| Senior Staff       |<br>| Assistant Engineer |<br>| Technique Leader   |<br>| Manager            |<br>+——————–+</pre></p><p></p><p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no=’10001’<br>AND title IN (‘Senior Engineer’, ‘Staff’, ‘Engineer’, ‘Senior Staff’, ‘Assistant Engineer’, ‘Technique Leader’, ‘Manager’)<br>AND from_date=’1986-06-26’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |    7 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：</p><p></p><p><pre class="prettyprint linenums">SHOW PROFILES;<br>+———-+————+——————————————————————————-+<br>| Query_ID | Duration   | Query                                                                         |<br>+———-+————+——————————————————————————-+<br>|       10 | 0.00058000 | SELECT <em> FROM employees.titles WHERE emp_no=’10001’ AND from_date=’1986-06-26’|<br>|       11 | 0.00052500 | SELECT </em> FROM employees.titles WHERE emp_no=’10001’ AND title IN …          |<br>+———-+————+——————————————————————————-+</pre></p><p></p><p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p><p></p><p></p><h3>情况四：查询条件没有指定索引第一列。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE from_date=’1986-06-26’;<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+</pre></p><p></p><p>由于不是最左前缀，索引这样的查询显然用不到索引。</p><p></p><p></p><h3>情况五：匹配某列的前缀字符串。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND title LIKE ‘Senior%’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 56      | NULL |    1 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>此时可以用到索引，<strike>但是如果通配符不是只出现在末尾，则无法使用索引。</strike>（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）</p><p></p><p></p><h3>情况六：范围查询。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; ‘10010’ and title=’Senior Engineer’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no &lt; ‘10010’<br>AND title=’Senior Engineer’<br>AND from_date BETWEEN ‘1986-01-01’ AND ‘1986-12-31’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no BETWEEN ‘10001’ AND ‘10010’<br>AND title=’Senior Engineer’<br>AND from_date BETWEEN ‘1986-01-01’ AND ‘1986-12-31’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p><p></p><p></p><h3>情况七：查询条件中含有函数或表达式。</h3><p></p><p></p><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND left(title, 6)=’Senior’;<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+</pre></p><p></p><p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1=’10000’;<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+</pre></p><p></p><p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p><p></p><p></p><h2><a name="nav-4-3"></a>索引选择性与前缀索引</h2><p></p><p></p><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p><p></p><p></p><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p><p></p><p></p><p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p><p></p><p></p><p>Index Selectivity = Cardinality / #T</p><p></p><p></p><p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.0000 |<br>+————-+</pre></p><p></p><p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p><p></p><p></p><p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p><p></p><p></p><p>从图12可以看到employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.employees WHERE first_name=’Eric’ AND last_name=’Anido’;<br>+—-+————-+———–+——+—————+——+———+——+——–+————-+<br>| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |<br>+—-+————-+———–+——+—————+——+———+——+——–+————-+<br>|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |<br>+—-+————-+———–+——+—————+——+———+——+——–+————-+</pre></p><p></p><p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建&lt;first_name&gt;或&lt;first_name, last_name&gt;，看下两个索引的选择性：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(first_name))/count(<em>) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.0042 |<br>+————-+<br>SELECT count(DISTINCT(concat(first_name, last_name)))/count(</em>) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.9313 |<br>+————-+</pre></p><p></p><p>&lt;first_name&gt;显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.7879 |<br>+————-+</pre></p><p></p><p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.9007 |<br>+————-+</pre></p><p></p><p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上：</p><p></p><p><pre class="prettyprint linenums">ALTER TABLE employees.employees<br>ADD INDEX <code>first_name_last_name4</code> (first_name, last_name(4));</pre></p><p></p><p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p><p></p><p><pre class="prettyprint linenums">SHOW PROFILES;<br>+———-+————+———————————————————————————+<br>| Query_ID | Duration   | Query                                                                           |<br>+———-+————+———————————————————————————+<br>|       87 | 0.11941700 | SELECT <em> FROM employees.employees WHERE first_name=’Eric’ AND last_name=’Anido’ |<br>|       90 | 0.00092400 | SELECT </em> FROM employees.employees WHERE first_name=’Eric’ AND last_name=’Anido’ |<br>+———-+————+———————————————————————————+</pre></p><p></p><p>性能的提升是显著的，查询速度提高了120多倍。</p><p></p><p></p><p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p><p></p><p></p><h2><a name="nav-4-4"></a>InnoDB的主键选择与插入优化</h2><p></p><p></p><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p><p></p><p></p><p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p><p></p><p></p><p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p></p><p></p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/13.png"></p><p></p><p></p><p align="center">图13</p><p></p><p></p><p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p></p><p></p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/14.png"></p><p></p><p></p><p align="center">图14</p><p></p><p></p><p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><p></p><p></p><p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p><p></p><p></p><h1><a name="nav-5"></a>后记</h1><p></p><p></p><p>这篇文章断断续续写了半个月，主要内容就是上面这些了。不可否认，这篇文章在一定程度上有纸上谈兵之嫌，因为我本人对MySQL的使用属于菜鸟级别，更没有太多数据库调优的经验，在这里大谈数据库索引调优有点大言不惭。就当是我个人的一篇学习笔记了。</p><p></p><p></p><p>其实数据库索引调优是一项技术活，不能仅仅靠理论，因为实际情况千变万化，而且MySQL本身存在很复杂的机制，如查询优化策略和各种引擎的实现差异等都会使情况变得更加复杂。但同时这些理论是索引调优的基础，只有在明白理论的基础上，才能对调优策略进行合理推断并了解其背后的机制，然后结合实践中不断的实验和摸索，从而真正达到高效使用MySQL索引的目的。</p><p></p><p></p><p>另外，MySQL索引及其优化涵盖范围非常广，本文只是涉及到其中一部分。如与排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）的话题本文并未涉及，同时除B-Tree索引外MySQL还根据不同引擎支持的哈希索引、全文索引等等本文也并未涉及。如果有机会，希望再对本文未涉及的部分进行补充吧。</p><br><p></p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理 作者 张洋 | 发布于 2011-10-18</a></p>]]></content>
    
    <summary type="html">
    
      本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论
    
    </summary>
    
    
      <category term="MySQL, Index, Database" scheme="http://yoursite.com/tags/MySQL-Index-Database/"/>
    
  </entry>
  
  <entry>
    <title>The Difference between Process and Thread</title>
    <link href="http://yoursite.com/2020/02/05/The-Difference-between-Process-and-Thread/"/>
    <id>http://yoursite.com/2020/02/05/The-Difference-between-Process-and-Thread/</id>
    <published>2020-02-05T08:41:49.000Z</published>
    <updated>2020-02-17T10:19:15.781Z</updated>
    
    <content type="html"><![CDATA[<p>对于操作系统而言，进程是整个现代操作系统的根本，操作系統是以进程为单位执行任务。随着技术发展，在执行一些细小任务，且本身无需分配单独资源时，进程的实现机制依然会繁琐的将资源分割，这样造成浪费，而且还消耗时间，所以就有了专门的多任务技术被创造出来——线程。 线程的特点就是在不需要独立资源的情况下就可以运行。如此一来会极大节省资源开销，以及处理时间。</p><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><p>我们有如下对比图片：</p><table><thead><tr><th>Tables</th><th style="text-align:center">Process   进程</th><th style="text-align:right">Thread线程</th></tr></thead><tbody><tr><td>引入目的</td><td style="text-align:center">可以并发执行，提高资源的利用率和系统吞吐量</td><td style="text-align:right">调高并发执行的速度，进一步提高资源的利用率和系统吞吐量</td></tr><tr><td>并发性</td><td style="text-align:center">较低</td><td style="text-align:right">较高</td></tr><tr><td>基本属性（调度）</td><td style="text-align:center">资源拥有的基本单位是进程，独立调度/分配的基本单位是进程</td><td style="text-align:right">资源拥有的基本单位是进程，独立调度/分配的基本单位是线程</td></tr><tr><td>基本状态</td><td style="text-align:center">就绪；执行；等待</td><td style="text-align:right">就绪；执行；等待</td></tr><tr><td>系统开销</td><td style="text-align:center">创建/撤销/切换时开销较大</td><td style="text-align:right">创建/撤销/切换时开销较小</td></tr><tr><td>系统操作</td><td style="text-align:center">创建；撤销；切换</td><td style="text-align:right">创建；撤销；切换</td></tr><tr><td>存在状态</td><td style="text-align:center">进程控制块PCB</td><td style="text-align:right">进程控制块PCB，进程控制块TCB</td></tr></tbody></table><h4 id="但是对于-Linux-来说，它只支持轻量级进程，不支持线程，对于-Linux-而言："><a href="#但是对于-Linux-来说，它只支持轻量级进程，不支持线程，对于-Linux-而言：" class="headerlink" title="但是对于 Linux 来说，它只支持轻量级进程，不支持线程，对于 Linux 而言："></a>但是对于 Linux 来说，它只支持轻量级进程，不支持线程，对于 Linux 而言：</h4><ul><li>系统启动后的 第一个进程是 init，它的 PID 是 1。init 是唯一一个由系统内核直接运行的进程。</li><li>除了 init 之外，每个进程都有 父进程（PPID 标识）</li><li>每个进程还有四个 与用户和组相关的识别号<br>1.实际用户识别号 （real user ID，RUID）<br>2.实际组识别号 （real group ID，RGID）<br>3.有效用户识别号 （effect user ID，EUID）<br>4.有效组识别号 （effect group ID，EGID</li></ul><p>######在 Linux 内核 2.4 版以前，线程的实现和管理方式就是完全按照进程方式实现的。在 2.6 版内核以后才有了单独的线程实现,为了弥补不支持线程的缺陷，Linux 引入线程组的概念，即该组中第一个轻量级进程的 PID，它被存入进程描述符的 tgid 字段中。<code>getpid()</code>系统调用返回当前进程的 tgid 值而不是 pid 值，因此，一个多线程应用的所有线程共享相同的 PID。</p><ul><li><code>fork()</code>系统调用是Unix下以自身进程创建子进程的系统调用，一次调用，两次返回，如果返回是0，则是子进程，如果返回值&gt;0，则是父进程（返回值是子进程的pid）,如果fork出错，返回一个负值.</li><li>在<code>fork()</code>的调用处，整个父进程空间会原模原样地复制到子进程中，包括指令，变量值，程序调用栈，环境变量，缓冲区，等等。</li><li><code>fork()</code>函数会把它所在语句以后的语句复制到一个子进程里，单独执行。</li><li><p>如果<code>printf</code>函数最后没有<code>&quot;\n&quot;</code>，则输出缓冲区不会被立即清空，而fork函数会把输出缓冲区里的内容也都复制到子进程里</p></li><li><p>进程的执行过程是线状的，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。</p></li><li>线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。</li><li>计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</li><li>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</li><li>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。</li></ul><p><strong>文章来源:</strong><br><a href="https://zhuanlan.zhihu.com/p/60558136" target="_blank" rel="noopener">进程和线程有哪些区别与联系？力扣（LeetCode）</a></p>]]></content>
    
    <summary type="html">
    
      进程和线程有哪些区别与联系
    
    </summary>
    
    
      <category term="Operation System" scheme="http://yoursite.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>Everything About HashMap</title>
    <link href="http://yoursite.com/2020/02/04/Everything-About-HashMap/"/>
    <id>http://yoursite.com/2020/02/04/Everything-About-HashMap/</id>
    <published>2020-02-04T10:51:33.000Z</published>
    <updated>2020-03-13T17:38:09.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么用HashMap？"><a href="#1-为什么用HashMap？" class="headerlink" title="1.为什么用HashMap？"></a>1.为什么用HashMap？</h2><ul><li>HashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射。</li><li>HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改。数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到. 链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</li><li>用LinkedList代替数组结构可以么?</li></ul><p>当然是可以的，稍微说明一下，此题的意思是，源码中是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry[] table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line"></span><br><span class="line">Entry就是一个链表节点。 那下面这样表示，是否可行?</span><br><span class="line"></span><br><span class="line">List&lt;Entry&gt; table = <span class="keyword">new</span> LinkedList&lt;Entry&gt;();</span><br></pre></td></tr></table></figure><p>答案很明显，是可以的。</p><p>既然是可以的,为什么HashMap不用LinkedList,而选用数组?<br>因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</p><ul><li>那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList?<br>因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。 而ArrayList的扩容机制是1.5倍扩容，那ArrayList为什么是1.5倍扩容这就不在本文说明了。</li><li>HashMap是非synchronized，所以HashMap很快。</li><li>HashMap可以接受null键和值，而Hashtable则不能（原因就是<code>equlas()</code>方法需要对象，因为HashMap是后出的API经过处理才可以）</li><li>当链表转为红黑树后，什么时候退化为链表?<br>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</li></ul><h2 id="2-HashMap的工作原理是什么？"><a href="#2-HashMap的工作原理是什么？" class="headerlink" title="2.HashMap的工作原理是什么？"></a>2.HashMap的工作原理是什么？</h2><p>HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node。　　</p><ul><li>以下是HashMap初始化 ，简单模拟数据结构<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Node[] table=<span class="keyword">new</span> Node[<span class="number">16</span>]  散列桶初始化，table</span><br><span class="line"></span><br><span class="line">　　 <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　hash;<span class="comment">//hash值</span></span><br><span class="line"></span><br><span class="line">     key;<span class="comment">//键</span></span><br><span class="line"></span><br><span class="line">　　　　value;<span class="comment">//值</span></span><br><span class="line"></span><br><span class="line">　　　　node next;<span class="comment">//用于指向链表的下一层（产生冲突，用拉链法）</span></span><br><span class="line"></span><br><span class="line">　　 &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="put过程（JDK1-8版）"><a href="#put过程（JDK1-8版）" class="headerlink" title="put过程（JDK1.8版）"></a><code>put</code>过程（JDK1.8版）</h4><ul><li>对Key用HashCode()求Hash值，然后再计算下标</li><li>如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）</li><li>如果碰撞了，以链表的方式链接到后面</li><li>如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表</li><li>如果节点已经存在就替换旧值</li><li>如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）</li></ul><p><strong>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</strong></p><h4 id="Get过程-考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？"><a href="#Get过程-考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？" class="headerlink" title="Get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)"></a><code>Get过程</code>(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)</h4><p>当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。</p><p>　　</p><h2 id="3-有什么方法可以减少碰撞？"><a href="#3-有什么方法可以减少碰撞？" class="headerlink" title="3.有什么方法可以减少碰撞？"></a>3.有什么方法可以减少碰撞？</h2><ul><li>扰动函数可以减少碰撞，原理是如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这就意味着存链表结构减小，这样取值的话就不会频繁调用equal方法，这样就能提高HashMap的性能。（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。）</li><li>使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。为什么String, Interger这样的wrapper类适合作为键？因为String是final的，而且已经重写了equals()和hashCode()方法了。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。</li></ul><h2 id="4-HashMap中hash函数怎么是是实现的"><a href="#4-HashMap中hash函数怎么是是实现的" class="headerlink" title="4.HashMap中hash函数怎么是是实现的?"></a>4.HashMap中hash函数怎么是是实现的?</h2><p>　　我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式，我们来看看JDK1.8的源码是怎么做的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     h=key.hashCode()；返回散列值也就是hashcode</span><br><span class="line">      <span class="comment">// ^ ：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="comment">//其中n是数组的长度，即Map的数组部分初始化长度</span></span><br><span class="line">     <span class="keyword">return</span>  (n-<span class="number">1</span>)&amp;(h ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>高16位异或低16位以后，进行取模运算</strong><br>1.高16bit不变，低16bit和高16bit做了一个异或(得到的HashCode转化为32位的二进制，前16位和后16位低16bit和高16bit做了一个异或)<br>2.(n·1)&amp;hash=-&gt;得到下标</p><ul><li>为什么扩容是2的次幂?</li></ul><p>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法<br>这个算法实际就是取模，hash%length。 但是，大家都知道这种运算不如位移运算快。<br>因此，源码中做了优化hash&amp;(length-1)。 也就是说hash%length==hash&amp;(length-1)</p><h2 id="5-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"><a href="#5-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？" class="headerlink" title="5.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"></a>5.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</h2><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p><h2 id="6-对红黑树的见解？"><a href="#6-对红黑树的见解？" class="headerlink" title="6.对红黑树的见解？"></a>6.对红黑树的见解？</h2><ul><li>节点是红色或黑色。</li><li>根节点是黑色。</li><li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li><strong>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</strong></li></ul><h2 id="7-解决hash-碰撞还有那些办法？"><a href="#7-解决hash-碰撞还有那些办法？" class="headerlink" title="7.解决hash 碰撞还有那些办法？"></a>7.解决hash 碰撞还有那些办法？</h2><p><strong>比较出名的有四种 (1)开放定址法 (2)链地址法 (3)再哈希法 (4)公共溢出区域法</strong></p><ul><li>开放定址法<br>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li><li>链地址法<br>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li><li>再哈希法<br>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li><li>建立公共溢出区<br>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li></ul><p><strong>下面给一个线性探查法的例子</strong>　</p><p><strong>问题：已知一组关键字为(26，36，41，38，44，15，68，12，06，51)，用除余法构造散列函数，用线性探查法解决冲突构造这组关键字的散列表</strong></p><p> <strong>解答：为了减少冲突，通常令装填因子α由除余法因子是13的散列函数计算出的上述关键字序列的散列地址为(0，10，2，12，5，2，3，12，6，12)。</strong></p><ul><li>前5个关键字插入时，其相应的地址均为开放地址，故将它们直接插入T[0]，T[10)，T[2]，T[12]和T[5]中。</li><li>当插入第6个关键字15时，其散列地址2(即h(15)=15％13=2)已被关键字41(15和41互为同义词)占用。故探查h1=(2+1)％13=3，此地址开放，所以将15放入T[3]中。</li><li>当插入第7个关键字68时，其散列地址3已被非同义词15先占用，故将其插入到T[4]中。</li><li>当插入第8个关键字12时，散列地址12已被同义词38占用，故探查hl=(12+1)％13=0，而T[0]亦被26占用，再探查h2=(12+2)％13=1，此地址开放，可将12插入其中。</li><li>类似地，第9个关键字06直接插入T[6]中；而最后一个关键字51插人时，因探查的地址12，0，1，…，6均非空，故51插入T[7]中。</li></ul><h2 id="8-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#8-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h2><p>　　默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为 <strong>&lt;原下标+原容量&gt;</strong> 的位置　　</p><h2 id="9-重新调整HashMap大小存在什么问题吗？"><a href="#9-重新调整HashMap大小存在什么问题吗？" class="headerlink" title="9.重新调整HashMap大小存在什么问题吗？"></a>9.重新调整HashMap大小存在什么问题吗？</h2><ul><li>当扩容重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。因为直接插入的效率更高。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap）。</li><li>为什么多线程会导致死循环，它是怎么发生的？<br>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。1.扩容：创建一个新的Entry空数组，长度是原数组的2倍。2.ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。</li></ul><blockquote><p> <strong>HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</strong></p></blockquote><blockquote><p>在HashMap1.7之前是头插法，在扩容的过程中，可能会造成一个resize()的方法，然后调用transfer()方法，把里面的Entry进行了Rehash，在过程中，可能会造成链表的循环，在一下次Get()中出现死循环，或者出现没有加锁，所以数据不安全</p></blockquote><h2 id="10-HashTable"><a href="#10-HashTable" class="headerlink" title="10.HashTable"></a>10.HashTable</h2><p>数组 + 链表方式存储<br>默认容量： 11(质数为宜)</p><h4 id="Put"><a href="#Put" class="headerlink" title="Put:"></a><code>Put:</code></h4><ul><li>对key的hashCode()做hash运算，计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树(JDK1.8中的改动)； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。</li><li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li><li>若在链表中找到了，则替换旧值，若未找到则继续</li><li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li><li><strong>将新元素加到链表头部,对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全</strong>。<h4 id="Get"><a href="#Get" class="headerlink" title="Get:"></a><code>Get:</code></h4>对key的hashCode()做hash运算，计算index; 如果在bucket里的第一个节点里直接命中，则直接返回； 如果有冲突，则通过key.equals(k)去查找对应的Entry;<br>• 若为树，则在树中通过key.equals(k)查找，O(logn)；<br>• 若为链表，则在链表中通过key.equals(k)查找，O(n)。</li></ul><h2 id="11-HashMap-，HashTable-区别"><a href="#11-HashMap-，HashTable-区别" class="headerlink" title="11.HashMap ，HashTable 区别"></a>11.HashMap ，HashTable 区别</h2><ul><li>默认容量不同。扩容不同</li><li>线程安全性，HashTable 安全  </li><li>效率不同 HashTable 要慢因为加锁</li></ul><h2 id="12-可以使用CocurrentHashMap来代替Hashtable吗？"><a href="#12-可以使用CocurrentHashMap来代替Hashtable吗？" class="headerlink" title="12.可以使用CocurrentHashMap来代替Hashtable吗？"></a>12.可以使用CocurrentHashMap来代替Hashtable吗？</h2><p>我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p><h2 id="13-CocurrentHashMap（1-8）"><a href="#13-CocurrentHashMap（1-8）" class="headerlink" title="13.CocurrentHashMap（1.8）"></a>13.CocurrentHashMap（1.8）</h2><ul><li>其中抛弃了原有的 Segment 分段锁，而采用了<code>CAS + synchronized</code>来保证并发安全性。</li><li>其中的 val next 都用了 <code>volatile</code>修饰，保证了可见性</li><li>最大特点是引入了 CAS（借助 Unsafe 来实现【native code】）<br>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li><li><p>CAS 会出现的问题：ABA<br>解决：对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。<br>####<code>Put过程</code></p></li><li><p>根据 key 计算出 hashcode 。判断是否需要进行初始化。</p></li><li>通过 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li><p>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</p><h4 id="Get过程"><a href="#Get过程" class="headerlink" title="Get过程"></a><code>Get过程</code></h4></li><li><p>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p></li><li>如果是红黑树那就按照树的方式获取值。</li><li>都不满足那就按照链表的方式遍历获取值。</li></ul><h2 id="14-TreeMap"><a href="#14-TreeMap" class="headerlink" title="14.TreeMap"></a>14.TreeMap</h2><p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和HashMap不同，它的get、put、remove之类操作都是O(logn)的复杂度，具体顺序可以由指定的Comparator来决定，或者根据键的自然顺序来判断</p><h2 id="15-hash算法是干嘛的？还知道哪些hash算法？"><a href="#15-hash算法是干嘛的？还知道哪些hash算法？" class="headerlink" title="15.hash算法是干嘛的？还知道哪些hash算法？"></a>15.hash算法是干嘛的？还知道哪些hash算法？</h2><p>Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。<br>比较出名的算法有SHA,MD4、MD5等</p><p>说说String中hashcode的实现?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>String类中的hashCode计算方法还是比较简单的，就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。</li><li>哈希计算公式可以计为<figure class="highlight plain"><figcaption><span>+ s[1]*31^(n-2) + ... + s[n-1]```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 那为什么以31为质数呢?</span><br><span class="line">主要是因为31是一个奇质数，所以```31*i=32*i-i=(i&lt;&lt;5)-i```，这种位移与减法结合的计算相比一般的运算快很多。</span><br><span class="line"></span><br><span class="line">## 16.健可以为Null值么?</span><br><span class="line"></span><br><span class="line">可以，key为null的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。</span><br><span class="line"></span><br><span class="line">## 17.一般用什么作为HashMap的key?</span><br><span class="line"></span><br><span class="line">一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。</span><br><span class="line">• (1) 因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</span><br><span class="line">• (2) 因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的覆写了hashCode()以及equals()方法。</span><br><span class="line"></span><br><span class="line">## Hashcode</span><br><span class="line">* 一、hashCode简介</span><br><span class="line">public int hashCode()：``hashCode``是根类Obeject中的方法。默认情况下，Object中的``hashCode() ``返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。</span><br><span class="line">* 二、hashCode注意点</span><br><span class="line">关于hashCode方法，一致的约定是：</span><br><span class="line">1、重写了``euqls``方法的对象必须同时重写``hashCode()``方法。</span><br><span class="line">2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</span><br><span class="line">3、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</span><br><span class="line">* 三、hashCode作用</span><br><span class="line">从Object角度看，JVM每new一个Object，它都会将这个Object丢到一个Hash表中去，这样的话，下次做Object的比较或者取这个对象的时候（读取过程），它会根据对象的HashCode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。若HashCode相同再去调用equal。</span><br><span class="line">HashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。</span><br><span class="line">* 四、为什么重写</span><br><span class="line">实际开发的过程中在hashmap或者hashset里如果不重写的hashcode和equals方法的话会导致我们存对象的时候，把对象存进去了，取的时候却取不到想要的对象。</span><br><span class="line">重写了hashcode和equals方法可以迅速的在hashmap中找到键的位置；</span><br><span class="line">#### **重写hashcode是为了保证相同的对象会有相同的hashcode；**</span><br><span class="line">#### **重写equals是为了保证在发生冲突的情况下取得到Entry对象（也可以理解是key或是元素）**；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存在一个table数组，里面每个元素都是一个node链表，当添加一个元素（key-value）时，就首先计算元素key的hash值，通过table的长度和key的hash值进行与运算得到一个index，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就把这个元素添加到同一hash值的node链表的链尾，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度大于等于8时，链表就可能转换为红黑树，这样大大提高了查找的效率。</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191102133424361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM1ODMzMTE=,size_16,color_FFFFFF,t_70&quot; alt=&quot;存储结构&quot; /&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&amp;lt;K,V&amp;gt; next; //可以看得出这是一个链表</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li></ul><li>HashMap内部包含一个Node类型的数组table，Node由Map.Entry继承而来。</li><br><li>Node存储着键值对。它包含四个字段，从next字段我们可以看出node是一个链表。</li><br><li>table数组中的每个位置都可以当做一个桶，一个桶存放一个链表。</li><br><li>HashMap使用拉链法来解决冲突，同一个存放散列值相同的Node。</li><br><h4 id="数据域">数据域</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;  </span><br><span class="line"><span class="comment">// 初始化容量，初始化有16个桶</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &amp;lt;&amp;lt; <span class="number">4</span>; <span class="comment">// aka 16  </span></span><br><span class="line"><span class="comment">// 最大容量  1 073 741 824, 10亿多</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &amp;lt;&amp;lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 当put()一个元素到某个桶，其链表长度达到8时有可能将链表转换为红黑树  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;  </span><br><span class="line"><span class="comment">// 在hashMap扩容时，如果发现链表长度小于等于6，则会由红黑树重新退化为链表。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;  </span><br><span class="line"><span class="comment">// 在转变成红黑树树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换，否者直接扩容。这是为了避免在HashMap建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;  </span><br><span class="line"><span class="comment">// 存储元素的数组  </span></span><br><span class="line"><span class="keyword">transient</span> Node&amp;lt;k,v&amp;gt;[] table;</span><br><span class="line"><span class="comment">// 存放元素的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 被修改的次数fast-fail机制   </span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 临界值 当实际大小(容量*填充比)超过临界值时，会进行扩容   </span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 填充比</span></span><br><span class="line">final float loadFactor;&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;h4 id="构造函数"&gt;构造函数&lt;/h4&gt;</span><br><span class="line">&lt;pre <span class="class"><span class="keyword">class</span></span>=<span class="string">"java"</span>&gt;&lt;code&gt;<span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &amp;lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(&amp;quot;Illegal initial capacity: &amp;quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &amp;gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &amp;lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(&amp;quot;Illegal load factor: &amp;quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// tableSizeFor(initialCapacity)方法计算出接近initialCapacity</span></span><br><span class="line">        <span class="comment">// 参数的2^n来作为初始化容量。</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&amp;lt;? extends K, ? extends V&amp;gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li><p>HashMap构造函数允许用户传入容量不是2的n次方，因为它可以自动地将传入的容量转换为2的n次方。</p><br></li></ul><br>### <code>Put()</code>源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// “扰动函数”。参考 https://www.cnblogs.com/zhengwang/p/8136164.html</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; <span class="number">16</span>);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] tab; HashMap.Node&amp;lt;K,V&amp;gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 未初始化则初始化table</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 通过table的长度和hash与运算得到一个index，</span></span><br><span class="line">        <span class="comment">// 然后判断table数组下标为index处是否已经存在node。</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp;amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果table数组下标为index处为空则新创建一个node放在该处</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 运行到这代表table数组下标为index处已经存在node，即发生了碰撞</span></span><br><span class="line">            HashMap.Node&amp;lt;K,V&amp;gt; e; K k;</span><br><span class="line">            <span class="comment">// 检查这个node的key是否跟插入的key是否相同。</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                    ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 检查这个node是否已经是一个红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果这个node已经是一个红黑树则继续往树种添加节点</span></span><br><span class="line">                e = ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 在这里循环遍历node链表</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断是否到达链表尾</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 到达链表尾，直接把新node插入链表，插入链表尾部，在jdk8之前是头插法</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &amp;gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            <span class="comment">// 如果node链表的长度大于等于8则可能把这个node转换为红黑树</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 检查这个node的key是否跟插入的key是否相同。</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当插入key存在，则更新value值并返回旧value</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改次数++</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 如果当前大小大于门限，门限原本是初始容量*0.75</span></span><br><span class="line">        <span class="keyword">if</span> (++size &amp;gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>下面简单说下put()流程：<br><ol><br><li>判断键值对数组table[]是否为空或为null，否则以默认大小resize()；</li><br><li>根据键key计算hash值与table的长度进行与运算得到插入的数组索引 index，如果tab[index] == null，直接根据key-value新建node添加，否则转入3</li><br><li>判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可),分别处理</li><br></ol></li><p><li>为啥头插法为什么要换成尾插：jdk1.7时候用头插法可能是考虑到了一个所谓的热点数据的点(新插入的数据可能会更早用到)；找到链表尾部的时间复杂度是 O(n)，或者需要使用额外的内存地址来保存链表尾部的位置，头插法可以节省插入耗时。但是在扩容时会改变链表中元素原本的顺序，以至于在<strong>并发场景下导致链表成环</strong>的问题。</li></p><p><li>从putVal()源码可以看出，HashMap并没有对null的键值对做限制（hash值设为0），即HashMap允许插入键尾null的键值对。但在JDK1.8之前HashMap使用第0个node存放键为null的键值对。</li></p><p><li>确定node下标：通过table的长度和key的hash进行与运算得到一个index。</li></p><p><li>在转变成红黑树树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换，否者直接扩容。这是为了避免在HashMap建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</li><br></p></ul><p></p><h2 id="大多数人不知道的：HashMap链表成环的原因和解决方案"><a href="#大多数人不知道的：HashMap链表成环的原因和解决方案" class="headerlink" title="大多数人不知道的：HashMap链表成环的原因和解决方案"></a><a href="https://www.cnblogs.com/wen-he/p/11496050.html" target="_blank" rel="noopener">大多数人不知道的：HashMap链表成环的原因和解决方案</a></h2><h3 id="get-操作源码解析"><a href="#get-操作源码解析" class="headerlink" title="get()操作源码解析"></a>get()操作源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HashMap.Node&amp;lt;K,V&amp;gt; getNode(<span class="keyword">int</span> hash, Object key) &#123;</span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] tab; HashMap.Node&amp;lt;K,V&amp;gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="comment">// table不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;amp;&amp;amp; (n = tab.length) &amp;gt; <span class="number">0</span> &amp;amp;&amp;amp;</span><br><span class="line">                <span class="comment">// 通过table的长度和hash与运算得到一个index，table</span></span><br><span class="line">                <span class="comment">// 下标位index处的元素不为空，即元素为node链表</span></span><br><span class="line">                (first = tab[(n - <span class="number">1</span>) &amp;amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 首先判断node链表中中第一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;amp;&amp;amp; <span class="comment">// always check first node</span></span><br><span class="line">                    <span class="comment">// 分别判断key为null和key不为null的情况</span></span><br><span class="line">                    ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// key相等则返回第一个</span></span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">// 第一个节点key不同且node链表不止包含一个节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断node链表是否转为红黑树。</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">                    <span class="comment">// 则在红黑树中进行查找。</span></span><br><span class="line">                    <span class="keyword">return</span> ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 循环遍历node链表中的节点，判断key是否相等</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key在table中不存在则返回null。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>get(key)方法首先获取key的hash值，</li><li>计算hash &amp; (table.len - 1)得到在链表数组中的位置，</li><li>先判断node链表（桶）中的第一个节点的key是否与参数key相等，</li><li>不等则判断是否已经转为红黑树，若转为红黑树则在红黑树中查找，</li><li>如没有转为红黑树就遍历后面的链表找到相同的key值返回对应的Value值即可。</li></ul><h3 id="resize-操作源码解析"><a href="#resize-操作源码解析" class="headerlink" title="resize()操作源码解析"></a>resize()操作源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化或者扩容之后的元素调整</span></span><br><span class="line">    <span class="keyword">final</span> HashMap.Node&amp;lt;K,V&amp;gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">// 获取旧table</span></span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">// 旧table容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">// 旧table扩容临界值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">// 定义新table容量和临界值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果原table不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果table容量达到最大值，则修改临界值为Integer.MAX_VALUE</span></span><br><span class="line">            <span class="comment">// MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;</span></span><br><span class="line">            <span class="comment">// Integer.MAX_VALUE = 1 &amp;lt;&amp;lt; 31 - 1;</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &amp;gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// Map达到最大容量，这时还要向map中放数据，则直接设置临界值为整数的最大值</span></span><br><span class="line">                <span class="comment">// 在容量没有达到最大值之前不会再resize。</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">// 结束操作</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面就是扩容操作（2倍）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &amp;lt;&amp;lt; <span class="number">1</span>) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;</span><br><span class="line">                    oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">// 临界值也变为两倍</span></span><br><span class="line">                newThr = oldThr &amp;lt;&amp;lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &amp;gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 进入此if证明创建HashMap时用的带参构造：public HashMap(int initialCapacity)</span></span><br><span class="line"><span class="comment">             * 或 public HashMap(int initialCapacity, float loadFactor)</span></span><br><span class="line"><span class="comment">             * 注：带参的构造中initialCapacity（初始容量值）不管是输入几都会通过</span></span><br><span class="line"><span class="comment">             * tableSizeFor(initialCapacity)方法计算出接近initialCapacity</span></span><br><span class="line"><span class="comment">             * 参数的2^n来作为初始化容量。</span></span><br><span class="line"><span class="comment">             * 所以实际创建的容量并不等于设置的初始容量。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">// 进入此if证明创建map时用的无参构造：</span></span><br><span class="line">            <span class="comment">// 然后将参数newCap（新的容量）、newThr(新的扩容阀界值)进行初始化</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 进入这代表有两种可能。</span></span><br><span class="line">            <span class="comment">// 1. 说明old table容量大于0但是小于16.</span></span><br><span class="line">            <span class="comment">// 2. 创建HashMap时用的带参构造，根据loadFactor计算临界值。</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改临界值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;&amp;quot;rawtypes&amp;quot;,&amp;quot;unchecked&amp;quot;&#125;)</span><br><span class="line">        <span class="comment">// 根据新的容量生成新的 table</span></span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] newTab = (HashMap.Node&amp;lt;K,V&amp;gt;[])<span class="keyword">new</span> HashMap.Node[newCap];</span><br><span class="line">        <span class="comment">// 替换成新的table</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">// 如果oldTab不为null说明是扩容，否则直接返回newTab</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 遍历原来的table */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; oldCap; ++j) &#123;</span><br><span class="line">                HashMap.Node&amp;lt;K,V&amp;gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 判断这个桶（链表）中就只有一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// 根据新的容量重新计算在table中的位置index，并把当前元素赋值给他。</span></span><br><span class="line">                        newTab[e.hash &amp;amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">// 判断这个链表是否已经转为红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">                        <span class="comment">// 在split函数中可能由于红黑树的长度小于等于UNTREEIFY_THRESHOLD（6）</span></span><br><span class="line">                        <span class="comment">// 则把红黑树重新转为链表</span></span><br><span class="line">                        ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">// 运行到这里证明桶中有多个节点。</span></span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">// 对桶进行遍历</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp;amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-的工作原理是什么"><a href="#HashMap-的工作原理是什么" class="headerlink" title="HashMap 的工作原理是什么?"></a>HashMap 的工作原理是什么?</h2><p>HashMap基于hashing原理，我们通过put()和get()方法存储和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来存储值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会存储在链表的第一个节点，链接原先的对象节点，HashMap在每个链表节点中存储键值对对象。</p><h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？"></a>快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？</h2><ul><li>1、快速失败（fail-fast）<br>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行修改（增加、删除、修改），则会抛出Concurrent Modification Exception.<br>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。<br>注意：这里异常的抛出条件是检测到modCount!=expectedmodCount这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。<br>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</li><li>2、安全失败（fail-safe）<br>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<br>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。<br>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception,但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的<br>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li></ul><p><img src="https://img1.sycdn.imooc.com/5d56493300011c0e19151612.png" alt="源码导读"></p><p><a href="https://blog.csdn.net/weixin_44460333/article/details/86770169" target="_blank" rel="noopener">HashMap？ConcurrentHashMap？相信看完这篇没人能难住你</a></p>]]></content>
    
    <summary type="html">
    
      Find Everything about HashMap IN There.
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms, Part I | Princeton Online</title>
    <link href="http://yoursite.com/2020/01/16/Algorithms-Part-I-Princeton-Online/"/>
    <id>http://yoursite.com/2020/01/16/Algorithms-Part-I-Princeton-Online/</id>
    <published>2020-01-16T14:19:13.000Z</published>
    <updated>2020-01-16T14:29:42.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Princeton-Online-course"><a href="#Princeton-Online-course" class="headerlink" title="Princeton Online course"></a><a href="https://algs4.cs.princeton.edu/" target="_blank" rel="noopener">Princeton Online course</a></h2><h2 id="You-can-find-all-the-code-and-comments-details-in-this-Repository"><a href="#You-can-find-all-the-code-and-comments-details-in-this-Repository" class="headerlink" title="You can find all the code and comments details in this Repository"></a><a href="https://github.com/Williamren97/Alg4" target="_blank" rel="noopener">You can find all the code and comments details in this Repository</a></h2><h3 id="What-algorithms-and-data-structures-will-be-covered-in-this-course"><a href="#What-algorithms-and-data-structures-will-be-covered-in-this-course" class="headerlink" title="What algorithms and data structures will be covered in this course?"></a>What algorithms and data structures will be covered in this course?</h3><h4 id="The-first-part-will-focus-on-the-basic-data-structure-sorting-and-searching"><a href="#The-first-part-will-focus-on-the-basic-data-structure-sorting-and-searching" class="headerlink" title="The first part will focus on the basic data structure, sorting, and searching."></a>The first part will focus on the basic data structure, sorting, and searching.</h4><ul><li>Topics include: parallel search algorithm, binary search, stack, queue, backpack, insert sort, select sort, hill sort, fast sort, three-way fast sort, merge sort, heap sort, binary heap, binary search tree, red-black tree , Split link and linear probe hash tables, Graham scans, kd trees.</li></ul><h4 id="The-second-part-will-focus-on-graph-and-string-processing-algorithms"><a href="#The-second-part-will-focus-on-graph-and-string-processing-algorithms" class="headerlink" title="The second part will focus on graph and string processing algorithms."></a>The second part will focus on graph and string processing algorithms.</h4><ul><li>Topics include: depth-first search, width-first search, topology sorting, Kosaraju-Sharir algorithm, Kruskal algorithm, Prim algorithm, Dijkistra algorithm, Bellman-Ford algorithm, Ford-Fulkerson algorithm, LSD cardinality ranking algorithm, MSD cardinality ranking algorithm, three-way Cardinality fast sorting algorithm, multi-path trie algorithm, ternary search trie algorithm, Knuth-Morris-Pratt algorithm, Boyer-Moore algorithm, Rabin-Karp algorithm, regular matching, run-length encoding, Huffman encoding, LZW compression, Burrows-Wheeler transform .</li></ul><h4 id="The-Imp-of-Algorithm-in-Princeton-University"><a href="#The-Imp-of-Algorithm-in-Princeton-University" class="headerlink" title="The Imp of Algorithm in Princeton University."></a>The Imp of Algorithm in Princeton University.</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Princeton-Online-course&quot;&gt;&lt;a href=&quot;#Princeton-Online-course&quot; class=&quot;headerlink&quot; title=&quot;Princeton Online course&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
      <category term="Algorithms," scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>EveryThing About MySQL</title>
    <link href="http://yoursite.com/2020/01/14/EveryThing-About-MySQL/"/>
    <id>http://yoursite.com/2020/01/14/EveryThing-About-MySQL/</id>
    <published>2020-01-14T15:37:44.000Z</published>
    <updated>2020-02-23T16:59:23.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><p><a href="https://blog.csdn.net/chai471793/article/details/99563704" target="_blank" rel="noopener">彻底搞懂系列B-树、B+树、B-树、B*树</a></p><p><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">B树和B+树的插入、删除图文详解</a></p><h3 id="关系型数据库和非关系型数据库为什么用B树或B-树"><a href="#关系型数据库和非关系型数据库为什么用B树或B-树" class="headerlink" title="关系型数据库和非关系型数据库为什么用B树或B+树"></a><a href="https://baijiahao.baidu.com/s?id=1658675762218129560&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">关系型数据库和非关系型数据库为什么用B树或B+树</a></h3><blockquote><p>==B+树的数据只出现在叶子节点上==，因此在查询单条数据的时候，查询速度非常稳定。因此，==在做单一数据的查询上，其平均性能并不如B树==。但是，B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，==只需要对叶子节点进行遍历即可，这个特性使得B+树非常适合做范围查询==。</p></blockquote><ul><li>没准是==Mysql中数据遍历操作比较多，所以用B+树作为索引结构==。凡做这种关联查询，你躲不开join操作的！既然涉及到了<code>Join</code>操作，无外乎从一个表中取一个数据，去另一个表中逐行匹配，如果索引结构是B+树，叶子节点上是有指针的，能够极大的提高这种一行一行的匹配速度</li><li>==而Mongodb是做单一查询比较多，数据遍历操作比较少==，所以用B树作为索引结构。</li></ul><p>那么为什么Mysql做数据遍历操作多？而Mongodb做数据遍历操作少呢？因为Mysql是关系型数据库，而Mongodb是非关系型数据。</p><p>平衡二叉树则是子树高读不能超过2，B树非叶子节点也可以存储数据，B+树则是叶子节点才可以存储数据。</p><ul><li>我们说的==平衡二叉树结构，指的是逻辑结构上的平衡二叉树，其物理实现是数组==。然后由于在逻辑结构上相近的节点在物理结构上可能会差很远。因此，每次读取的磁盘页的数据中有许多是用不上的。因此，查找过程中要进行许多次的磁盘读取操作。而适合作为索引的结构应该是尽可能少的执行磁盘IO操作，因为执行磁盘IO操作非常的耗时。因此，平衡二叉树并不适合作为索引结构</li><li>红黑树这种结构==h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性==，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。也就是说，使用红黑树（平衡二叉树）结构的话，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。</li><li>==B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能==。每次读取磁盘页时就会读取一整个节点。==也正因每个节点存储着非常多个关键字，树的深度就会非常的小==。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</li><li>==B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中==。因此，虽然B树查询查询的次数不比平衡二叉树的次数少，但是相比起磁盘IO速度，内存中比较的耗时就可以忽略不计了。因此，B树更适合作为索引。</li></ul><h1 id="一步步分析为什么B-树适合作为索引的结构-以及索引原理-阿里面试，写的很好"><a href="#一步步分析为什么B-树适合作为索引的结构-以及索引原理-阿里面试，写的很好" class="headerlink" title="一步步分析为什么B+树适合作为索引的结构 以及索引原理(阿里面试，写的很好"></a><a href="https://www.cnblogs.com/aspirant/p/9214485.html" target="_blank" rel="noopener">一步步分析为什么B+树适合作为索引的结构 以及索引原理(阿里面试，写的很好</a></h1><p>B+Tree是mysql使用最频繁的一个索引数据结构，是Inodb和Myisam存储引擎模式的索引类型。相对Hash索引，B+Tree在查找单条记录的速度比不上Hash索引(Memory表只存在内存中)，但是因为更适合排序等操作，所以它更受欢迎。毕竟不可能只对数据库进行单条记录的操作。</p><ul><li><p>带顺序访问指针的B+Tree</p><blockquote><p>B+Tree所有索引数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。这样做是为了提高区间效率，例如查询key为从18到49的所有数据记录，当找到18后，只要顺着节点和指针顺序遍历就可以以此向访问到所有数据节点，极大提高了区间查询效率。</p></blockquote></li><li><p>大大减少磁盘I/O读取</p><blockquote><p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点需要一次I/O就可以完全载入</p></blockquote></li></ul><p><strong>全文索引（FULLTEXT）=mysql的myISAM搜索引擎默认的索引类型</strong>==不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法==。</p><p>文本字段上的普通索引只能加快对出现在字段内容最前面的字符串(也就是字段内容开头的字符)进行检索操作。如果字段里存放的是由几个、甚至是多个单词构成的较大段文字，普通索引就没什么作用了。这种检索往往以LIKE%word%的形式出现，这对MySQL来说很复杂，如果需要处理的数据量很大，响应时间就会很长。</p><p>这类场合正是全文索引(full-textindex)可以大显身手的地方。在生成这种类型的索引时，MySQL将把在文本中出现的所有单词创建为一份清单，查询操作将根据这份清单去检索有关的数据记录。全文索引即可以随数据表一同创建，也可以等日后有必要时再使用下面这条命令添加：<br><code>ALTER TABLE table_name ADD FULLTEXT(column1, column2)</code></p><p>有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。下面是这类查询命令的基本语法：<br>　　<br><code>SELECT * FROM table_name WHERE MATCH(column1, column2) AGAINST(&#39;word1&#39;, &#39;word2&#39;, &#39;word3&#39;)</code></p><p>上面这条命令将把column1和column2字段里有word1、word2和word3的数据记录全部查询出来。</p><p><a href="https://blog.csdn.net/qq_33330687/article/details/89004462" target="_blank" rel="noopener">InnoDB如何解决幻读</a></p><blockquote><p>使用MVCC</p></blockquote><p><a href="https://www.jianshu.com/p/bbaeab492a64" target="_blank" rel="noopener">一条SQL语句是如何执行的</a></p><p>由server层和存储引擎组成</p><blockquote><p>server 层包括连接器、分析器、优化器、执行器，涵盖 MySQL的核心服务，以及所有的内置函数（如日期、时间、数学、加密函数等），还有所有跨存储引擎的功能，例如存储过程、触发器、视图等。</p></blockquote><p><a href="https://blog.csdn.net/zxp0727/article/details/84580277" target="_blank" rel="noopener">一条SQL更新语句是如何执行的？</a></p><blockquote><p>里面包含binlog和redolog,两阶段提交</p></blockquote><h4 id="什么叫视图？游标是什么？"><a href="#什么叫视图？游标是什么？" class="headerlink" title="什么叫视图？游标是什么？"></a>什么叫视图？游标是什么？</h4><ul><li>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</li><li>游标是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</li></ul><h3 id="请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</h3><h3 id="在Mysql中ENUM的用法是什么？"><a href="#在Mysql中ENUM的用法是什么？" class="headerlink" title="在Mysql中ENUM的用法是什么？"></a>在Mysql中ENUM的用法是什么？</h3><blockquote><p>同一个属性里面包含多个字段，每个字段都有自己的索引.enum 在数据库底层以整型方式储存，从 1 开始，0 用于指代空或错误的字符串。</p></blockquote><h3 id="CHAR和VARCHAR的区别？"><a href="#CHAR和VARCHAR的区别？" class="headerlink" title="CHAR和VARCHAR的区别？"></a>CHAR和VARCHAR的区别？</h3><p>char 固定长度255，不足的部分补空格，取出时再去掉空格。varchar 不定长度</p><h3 id="drop-delete与truncate的区别"><a href="#drop-delete与truncate的区别" class="headerlink" title="drop,delete与truncate的区别"></a>drop,delete与truncate的区别</h3><p>drop删除表，truncate清空表，delete删除表、drop和truncate不能回滚。</p><h3 id="存储过程与触发器的区别"><a href="#存储过程与触发器的区别" class="headerlink" title="存储过程与触发器的区别"></a>存储过程与触发器的区别</h3><ul><li>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</li><li>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。可以供外部程序调用，比如：java程序。<blockquote><p>存储过程是预编译过的，执行效率高。存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。安全性高，执行存储过程需要有一定权限的用户。存储过程可以重复使用，可减少数据库开发人员的工作量。==缺点：移植性差==。</p></blockquote></li></ul><p>2）可以供外部程序调用，比如：java程序。</p><h3 id="完整性约束包括哪些？"><a href="#完整性约束包括哪些？" class="headerlink" title="完整性约束包括哪些？"></a><a href="https://www.cnblogs.com/hwlong/p/9009311.html" target="_blank" rel="noopener">完整性约束包括哪些</a>？</h3><p>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</p><ul><li>实体完整性：规定表的每一行在表中是惟一的实体。</li><li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li><li>参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</li><li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li></ul><p>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE)</p><p>MySql不支持check</p><h3 id="Mysql-的存储引擎-myisam和innodb的区别。"><a href="#Mysql-的存储引擎-myisam和innodb的区别。" class="headerlink" title="Mysql 的存储引擎,myisam和innodb的区别。"></a>Mysql 的存储引擎,myisam和innodb的区别。</h3><pre><code>NULL | myisam | innodb</code></pre><p>   —|—|—<br>事务支持|不支持| 支持| row 2 col 2<br>存储结构     |三种文件  | 一种文件<br>存储空间     |体积小 | 体积大<br>可移植性     |方便 | 困难<br>锁力度     |表级锁| 表级锁，行级锁<br>全文索引     |支持 | 不支持<br>表主键     |可以没有|必须有，没有就自动生成<br>外键     |不支持 | 支持</p><h2 id="1-锁"><a href="#1-锁" class="headerlink" title="1.锁"></a>1.锁</h2><ul><li>MyISAM 是非事务的存储引擎，适合用于频繁查询的应用。表锁，不会出现死锁，适合小数据，小并发。</li><li>Innodb是支持事务的存储引擎，合于插入和更新操作比较多的应用，设计合理的话是行锁（最大区别就在锁的级别上），适合大数据，大并发<br><img src="https://upload-images.jianshu.io/upload_images/2604566-27832dbe20e803fa.png" alt="image"><h3 id="表锁和行锁的区别"><a href="#表锁和行锁的区别" class="headerlink" title="表锁和行锁的区别"></a>表锁和行锁的区别</h3><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5></li><li>特点：开销小、加锁快、<strong>无死锁</strong>；锁粒度大，发生锁冲突的概率高，<strong>高并发下性能低</strong></li><li>加锁的方式：自动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5></li><li>特点：锁的粒度小，发生锁冲突的概率低、<strong>处理并发的能力强</strong>；开销大、加锁慢、<strong>会出现死锁</strong></li><li><p>加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁。</p></li><li><p>乐观锁：不加锁，只有在更新时验证数据是否被其他线程更新，吞吐量较高，适用于多读场景。它==假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚==。</p><blockquote><p>乐观锁实现方式是：版本号version和CAS(compare and swap)</p></blockquote></li><li>悲观锁：读取时加锁，更新完释放锁，再此过程中会造成其他线程阻塞，导致吞吐量低，适用于多写场景。当事务A对某行数据应用了锁，==并且当这个事务把锁释放后，其他事务才能够执行与该锁冲突的操作==，这里事务A所施加的锁就叫悲观锁。</li></ul><blockquote><p>行锁(共享锁和排他锁),间隙锁(next-keylock）都属于悲观锁。<br>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：==允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁==。</li><li>排他锁（X)：==允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。==<br>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</li></ul></blockquote><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁* ，事务在给一个数据行加排他锁前必须先取得该表的IX锁。<h5 id="间隙锁（Next-Key锁）"><a href="#间隙锁（Next-Key锁）" class="headerlink" title="间隙锁（Next-Key锁）:"></a>间隙锁（Next-Key锁）:</h5></li><li>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；</li><li>对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key)锁。</li></ul><hr><ul><li>1:<strong>表级锁不会死锁,行级锁和页级锁可能死锁</strong></li><li>2:在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</li><li>3:==从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应==用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</li><li>4:意向锁是InnoDB自动加的，不需用户干预。==对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)==；对于普通SELECT语句，InnoDB不会加任何锁；</li><li>5:InnoDB行锁实现方式: ==InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁==</li></ul><h3 id="Mysql中MVCC的使用及原理详解"><a href="#Mysql中MVCC的使用及原理详解" class="headerlink" title="Mysql中MVCC的使用及原理详解"></a><a href="https://blog.csdn.net/w2064004678/article/details/83012387" target="_blank" rel="noopener">Mysql中MVCC的使用及原理详解</a></h3><p>MVCC是一种多版本并发控制机制。MVCC是通过保存数据在某个时间点的快照来实现的。在每个表后添加创建版本号和删除版本号，版本号为修改该项的事务版本号。</p><ul><li>SELECT:InnoDB会根据以下两个条件检查每行记录<blockquote><p>InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的.</p></blockquote></li></ul><blockquote><p>行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除.<br>只有a,b同时满足的记录，才能返回作为查询结果.</p></blockquote><ul><li><p>DELETE:InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识.</p></li><li><p>UPDATE:InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间。</p></li></ul><h2 id="锁策略"><a href="#锁策略" class="headerlink" title="锁策略"></a><a href="https://www.nowcoder.com/discuss/151430" target="_blank" rel="noopener">锁策略</a></h2><h2 id="2-日志"><a href="#2-日志" class="headerlink" title="2.日志"></a>2.日志</h2><h3 id="redolog，binlog，undolog对事务的影响"><a href="#redolog，binlog，undolog对事务的影响" class="headerlink" title="redolog，binlog，undolog对事务的影响"></a>redolog，binlog，undolog对事务的影响</h3><ul><li>binlog</li><li>redolog,保证事务的持久性，缓存区中数据会慢慢更新到数据库的硬盘上。</li><li>undolog，记录了修改几率，可以随便回滚，保证原子性。</li></ul><h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h2><p>MVCC (MultiVersion Concurrency Control) 叫做==多版本并发==控制。==由undolog和记录版本的一个东西组成==。</p><blockquote><p>InnoDB的 MVCC，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，当然存储的并不是实际的时间值，而是系统版本号。</p></blockquote><p>以上片段摘自《高性能Mysql》这本书对MVCC的定义。他的主要实现思想是通过==数据多版本==来做到==读写分离==。从而实现不加锁读进而做到读写并行。</p><p><strong>MVCC在mysql中的实现依赖的是undo log与read view</strong></p><ul><li>undolog :undolog中记录某行数据的多个版本的数据。</li><li>read view :用来判断当前版本数据的可见性<h3 id="ACID特性中的一致性是如何实现的"><a href="#ACID特性中的一致性是如何实现的" class="headerlink" title="ACID特性中的一致性是如何实现的"></a>ACID特性中的一致性是如何实现的</h3></li><li>事务的原子性是通过 undo log 来实现的</li><li>事务的持久性性是通过 redo log 来实现的</li><li>事务的隔离性是通过 (读写锁+MVCC)来实现的</li><li>而事务的终极大boss一致性是通过原子性，持久性，隔离性来实现的！！！<blockquote><p>原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性</p></blockquote></li><li><a href="https://www.sohu.com/a/316482862_663371" target="_blank" rel="noopener">事务是如何通过日志实现的</a></li><li>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Buffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。<blockquote><p>redolog来记录已成功提交事务的修改信息，并且会把redolog持久化到磁盘，系统重启之后在读取redo log恢复最新数据。redolog是用来恢复数据的 用于保障，已提交事务的持久化特性</p></blockquote></li></ul><blockquote><p>undolog 叫做回滚日志，用于记录数据被修改前的信息。<strong>他正好跟前面所说的重做日志所记录的相反，redolog记录数据被修改后的信息。undolog主要记录的是数据的逻辑变化</strong>，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。undolog记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undolog的信息来进行回滚到没被修改前的状态。</p></blockquote><p><code>redo和undo</code>基本流程如下：<br>因为事务在修改页时，要先记 undo，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 Redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。 当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的状态，崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。 如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。</p><h2 id="4-索引"><a href="#4-索引" class="headerlink" title="4.索引"></a>4.索引</h2><h3 id="MySQL索引背后的数据结构及算法原理"><a href="#MySQL索引背后的数据结构及算法原理" class="headerlink" title="MySQL索引背后的数据结构及算法原理"></a><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></h3><h3 id="多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）"><a href="#多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）" class="headerlink" title="多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）"></a>多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）</h3><ul><li><p>唯一索引</p><blockquote><p>唯一索引是<strong>不允许其中任何两行具有相同索引值的索引</strong>。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p></blockquote></li><li><p>主键索引</p><blockquote><p>数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p></blockquote></li><li><p>聚集索引</p><blockquote><p>表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p></blockquote><h3 id="建索引有哪些原则"><a href="#建索引有哪些原则" class="headerlink" title="建索引有哪些原则"></a>建索引有哪些原则</h3><blockquote><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说应该在这些列上创建索引：</p></blockquote></li><li><p>在经常需要搜索的列上，可以加快搜索的速度</p></li><li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li><li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li></ul><h3 id="什么情况下设置了索引但无法使用"><a href="#什么情况下设置了索引但无法使用" class="headerlink" title="什么情况下设置了索引但无法使用"></a>什么情况下设置了索引但无法使用</h3><ul><li>条件中使用了 or，而相关列不全有索引</li><li>条件中使用了and，而相关列不满足最左原则</li><li>索引列的数据类型出现隐形转换，如varchar不加单引号的话可能会自动转换为int型）</li><li>like查询是以%开头</li><li>where 子句里对索引列上有数学运算/函数</li><li>mysql估计使用全表扫描要比使用索引快<h3 id="什么情况下不宜建立索引？"><a href="#什么情况下不宜建立索引？" class="headerlink" title="什么情况下不宜建立索引？"></a>什么情况下不宜建立索引？</h3></li><li>对于那些在查询中==很少使用或者参考的列不应该创建索引==。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>对于那些==只有很少数据值的列==也不应该增加索引。举例比如性别只有男和女</li><li>对于==那些定义为text,image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少==。</li><li>经==常频繁更新的列==不要建立索引，因为肯定会影响插入或更新的效率</li><li>尽量避==免在 where 子句中使用 ！= 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫==描。</li><li>当==修改性能远远大于检索性能时，不应该创建索引==。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li><li>尽量避免NULL：在MySQL中，==含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂==。可以采用0、一个特殊的值或者一个空串代替空值<blockquote><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p></blockquote><h3 id="为什么用B-树"><a href="#为什么用B-树" class="headerlink" title="为什么用B-树"></a>为什么用B-树</h3>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了==磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入== 为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</li></ul><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>为什么不用红黑树</p><blockquote><p>红黑树这种结构，h(层数)明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p></blockquote><h3 id="MySQL索引失效的情形很多。"><a href="#MySQL索引失效的情形很多。" class="headerlink" title="MySQL索引失效的情形很多。"></a>MySQL索引失效的情形很多。</h3><p>例如： 在WHERE条件的LIKE关键字匹配的字符串以”%“开头，这种情况下，索引是不会起到作用的；WHERE条件中使用OR关键字来连接多个查询条件，如果有一个条件没有使用索引，那么其他的索引也不会起作用；多列索引的第一个字段没有使用，那么这个多列索引也不会起作用。 使用in查询时，in查询条件超过数据库表的一半的时候也会失效。</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><ul><li>索引字段要尽量的小</li><li>索引的最左匹配特性（即从左往右匹配）：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</li></ul><h3 id="MySQL索引优化深入分析执行计划"><a href="#MySQL索引优化深入分析执行计划" class="headerlink" title="MySQL索引优化深入分析执行计划"></a><a href="https://mp.weixin.qq.com/s/TSbfdC6G-r8pvgpQ3qyjMA" target="_blank" rel="noopener">MySQL索引优化深入分析执行计划</a></h3><h3 id="如果有2级索引怎么存"><a href="#如果有2级索引怎么存" class="headerlink" title="如果有2级索引怎么存"></a>如果有2级索引怎么存</h3><h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，==磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。==这样做的理论依据是计算机科学中著名的==<br>局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中==。</p><p><strong>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效</strong>率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，<strong>会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行</strong></p><h2 id="5-SQL语句"><a href="#5-SQL语句" class="headerlink" title="5.SQL语句"></a>5.SQL语句</h2><p> <a href="https://www.runoob.com/sql/sql-groupby.html" target="_blank" rel="noopener">SQL语句菜鸟教程</a></p><h4 id="SQL教程"><a href="#SQL教程" class="headerlink" title="SQL教程"></a>SQL教程</h4><ul><li><code>AND</code>运算符，如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</li><li><p><code>OR运算符</code>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Websites</span><br><span class="line">WHERE alexa &gt; 15</span><br><span class="line">AND (country=&apos;CN&apos; OR country=&apos;USA&apos;);</span><br></pre></td></tr></table></figure></li><li><p><code>ORDER BY</code> 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p></li><li><code>IN</code>操作符IN操作符允许在WHERE子句中规定多个值。</li><li><p><code>BETWEEN</code>操作符用于选取介于两个值之间的数据范围内的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Websites</span><br><span class="line">WHERE (alexa BETWEEN 1 AND 20)</span><br><span class="line">AND country NOT IN (&apos;USA&apos;, &apos;IND&apos;);</span><br></pre></td></tr></table></figure></li><li><p>INNER JOIN：如果表中有至少一个匹配，则返回行</p></li><li>LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN：只要其中一个表中存在匹配，则返回行</li></ul><h4 id="SQL高级教程"><a href="#SQL高级教程" class="headerlink" title="SQL高级教程"></a>SQL高级教程</h4><ul><li>模糊查询(like)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Websites</span><br><span class="line">以&quot;G&quot;开始的所有客户WHERE name LIKE &apos;G%&apos;;</span><br><span class="line">以&quot;k&quot;结尾的所有客户WHERE name LIKE &apos;%k&apos;;</span><br><span class="line">还可以写NOT LIKE做反向查询</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://blog.csdn.net/lu0422/article/details/78892497" target="_blank" rel="noopener">解释MySQL外连接、内连接(outer join和inner join)与自连接的区别外连接</a><br><img src="https://www.runoob.com/wp-content/uploads/2019/01/sql-join.png" alt="SQL JOINS"></p><ul><li>左连接：连接两张表，左表数据完全显示，右表匹配，匹配不上的补null；在这里，t_employee就是左表，也就是基准表，==用基准表的数据去匹配右表的数据，所以左表的记录是全部会查询出来的，如果右表没有记录对应的话就显示null==。<blockquote><p>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</p></blockquote></li><li>右连接：同上，换个方向；<br>全外连接：两表字段都匹配，匹配不上的补null；</li><li>内连接：所有查询出的结果都是能够在连接的表中有对应记录的。这就是内连接的特点，==只查询在连接的表中能够有对应的记录==，<blockquote><p>INNER JOIN关键字在表中存在至少一个匹配时返回行。</p></blockquote></li><li>全外连接：==mysql是没有全外连接的==(mysql中没有<code>full outer join</code>关键字)，==想要达到全外连接的效果，可以使用<code>union</code>关键字连接左外连接和右外连接==。<strong>如果在Oracle中，直接就使用<code>full outer join</code>关键字连接两表就行了。</strong></li><li><p>UNION</p><blockquote><p>SQL UNION 操作符合并两个或多个 SELECT 语句的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT country FROM Websites</span><br><span class="line">UNION</span><br><span class="line">SELECT country FROM apps</span><br><span class="line">ORDER BY country;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>SELECT INTO</p><blockquote><p>通过 SQL，您可以从一个表复制信息到另一个表。SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 新表</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM 旧表</span><br></pre></td></tr></table></figure><ul><li><p>INSERT INTO SELECT</p><blockquote><p>通过 SQL，您可以从一个表复制信息到另一个表。INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table2</span><br><span class="line">SELECT * FROM table1;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>自连接：找到两表的公共字段，然后和内连接一样。</p></li><li>交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</li></ul><p><code>SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</code></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a><a href="https://www.cnblogs.com/wz123/p/9722942.html" target="_blank" rel="noopener">子查询</a></h3><p>一个SELECT语句嵌套在另一个SELECT语句中，子查询也叫做内部查询，而包含子查询的语句又称为外部查询或主查询，子查询自身可以包含一个或多个子查询，一个查询语句中可以嵌套任意数量的子查询。</p><h4 id="SQL查询重复记录"><a href="#SQL查询重复记录" class="headerlink" title="SQL查询重复记录"></a><a href="https://www.cnblogs.com/njccqx/p/9672504.html" target="_blank" rel="noopener">SQL查询重复记录</a></h4><hr><p><a href="https://blog.csdn.net/a755199443/article/details/88723685" target="_blank" rel="noopener">MySQL两道经典SQL面试题(行转列/列转行/求最值)</a></p><h3 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h3><ul><li>GROUP BY<blockquote><p>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">统计 access_log 各个 site_id 的访问量：</span><br><span class="line">SELECT site_id, SUM(access_log.count) AS nums</span><br><span class="line">FROM access_log GROUP BY site_id;</span><br></pre></td></tr></table></figure></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Websites.name,COUNT(access_log.aid) AS nums FROM access_log</span><br><span class="line">LEFT JOIN Websites</span><br><span class="line">ON access_log.site_id=Websites.id</span><br><span class="line">GROUP BY Websites.name;</span><br></pre></td></tr></table></figure><ul><li>HAVING<blockquote><p>在 SQL 中增加 HAVING 子句原因是，==WHERE 关键字无法与聚合函数一起使用==。HAVING 子句可以让我们筛选分组后的各组数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查找总访问量大于 200 的网站。</span><br><span class="line">SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_log INNER JOIN Websites</span><br><span class="line">ON access_log.site_id=Websites.id)</span><br><span class="line">GROUP BY Websites.name</span><br><span class="line">HAVING SUM(access_log.count) &gt; 200;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="6-SQL优化"><a href="#6-SQL优化" class="headerlink" title="6.SQL优化"></a>6.SQL优化</h2><h6 id="慢查询解决的基本步骤"><a href="#慢查询解决的基本步骤" class="headerlink" title="慢查询解决的基本步骤"></a>慢查询解决的基本步骤</h6><h6 id="500万数量级查询优化"><a href="#500万数量级查询优化" class="headerlink" title="500万数量级查询优化"></a><a href="https://mp.weixin.qq.com/s/-ZSBoPVYUY5UN_lrwqQKVw" target="_blank" rel="noopener">500万数量级查询优化</a></h6><h6 id="我们是如何对实际项目进行查询优化的"><a href="#我们是如何对实际项目进行查询优化的" class="headerlink" title="我们是如何对实际项目进行查询优化的"></a><a href="https://mp.weixin.qq.com/s/zhvN31uYtm-507k3GKJeKg" target="_blank" rel="noopener">我们是如何对实际项目进行查询优化的</a></h6><h6 id="巧用这19条MySQL优化，效率至少提高3倍"><a href="#巧用这19条MySQL优化，效率至少提高3倍" class="headerlink" title="巧用这19条MySQL优化，效率至少提高3倍"></a><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485120&amp;idx=2&amp;sn=c80bd2698209858d86975d551b2144f3&amp;source=41#wechat_redirect" target="_blank" rel="noopener">巧用这19条MySQL优化，效率至少提高3倍</a></h6><h6 id="为什么要分区，分表和分库？"><a href="#为什么要分区，分表和分库？" class="headerlink" title="为什么要分区，分表和分库？"></a><a href="https://www.cnblogs.com/tuhooo/p/9582223.html" target="_blank" rel="noopener">为什么要分区，分表和分库？</a></h6><h6 id="一次SQL查询优化原理分析（900W-数据，从17s到300ms"><a href="#一次SQL查询优化原理分析（900W-数据，从17s到300ms" class="headerlink" title="一次SQL查询优化原理分析（900W+数据，从17s到300ms"></a><a href="https://www.jianshu.com/p/0768ebc4e28d" target="_blank" rel="noopener">一次SQL查询优化原理分析（900W+数据，从17s到300ms</a></h6><h6 id="面试官：给我讲一下分库分表方案"><a href="#面试官：给我讲一下分库分表方案" class="headerlink" title="面试官：给我讲一下分库分表方案"></a><a href="https://www.jianshu.com/p/bf27be3fd448" target="_blank" rel="noopener">面试官：给我讲一下分库分表方案</a></h6><h6 id="数据库如何保证数据不丢失"><a href="#数据库如何保证数据不丢失" class="headerlink" title="数据库如何保证数据不丢失"></a><a href="https://www.cnblogs.com/a-phper/p/10313948.html" target="_blank" rel="noopener">数据库如何保证数据不丢失</a></h6><h6 id="MYSQL的主从同步延迟的原因及解决方案"><a href="#MYSQL的主从同步延迟的原因及解决方案" class="headerlink" title="MYSQL的主从同步延迟的原因及解决方案"></a><a href="https://blog.csdn.net/hao_yunfeng/article/details/82392261" target="_blank" rel="noopener">MYSQL的主从同步延迟的原因及解决方案</a></h6><ul><li>mysql主从复制用途<blockquote><p>从库生成两个线程，一个I/O线程，一个SQL线程；i/o线程去请求主库的binlog，并将得到的binlog日志写到relaylog（中继日志）文件中；主库会生成一个 log dump 线程，用来给从库i/o线程传binlog；<br>SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；</p></blockquote></li></ul><p>实时灾备，用于故障切换,==读写分离(主写从读比例为10：1)==，提供查询服务<br>备份，避免影响业务</p><ul><li>主从部署必要条件：<br>主库开启binlog日志（设置log-bin参数）,主从server-id不同,从库服务器能连通主库<h6 id="数据库如何保证高可用"><a href="#数据库如何保证高可用" class="headerlink" title="数据库如何保证高可用"></a><a href="https://blog.csdn.net/dhfzhishi/article/details/82561939" target="_blank" rel="noopener">数据库如何保证高可用</a></h6><h6 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a><a href="https://blog.csdn.net/qq_42234452/article/details/90906692?fps=1&amp;locationNum=2" target="_blank" rel="noopener">灰度发布</a></h6>在灰度发布开始后，先启动一个新版本应用，但是并不直接将流量切过来，而是测试人员对新版本进行线上测试，启动的这个新版本应用，就是我们的金丝雀。如果没有问题，那么可以将少量的用户流量导入到新版本上，然后再对新版本做运行状态观察，收集各种运行时数据，如果此时对新旧版本做各种数据对比，就是所谓的A/B测试。</li></ul><p>当确认新版本运行良好后，再逐步将更多的流量导入到新版本上，在此期间，还可以不断地调整新旧两个版本的运行的服务器副本数量，以使得新版本能够承受越来越大的流量压力。直到将100%的流量都切换到新版本上，最后关闭剩下的老版本服务，完成灰度发布。</p><p>如果在灰度发布过程中（灰度期）发现了新版本有问题，就应该立即将流量切回老版本上，这样，就会将负面影响控制在最小范围内。</p><h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h2><h6 id="创建表时候的优化"><a href="#创建表时候的优化" class="headerlink" title="创建表时候的优化"></a>创建表时候的优化</h6><ul><li>整数TinyInt,SmallInt,MediumInt,Int,BigInt 使用的存储 8,16,24,32,64 位存储空间。使用 Unsigned 表示不允许负数，可以使正数的上线提高一倍。</li><li>实数Float,Double , 支持近似的浮点运算。<br>Decimal，用于存储精确的小数。</li><li>字符串VarChar，存储变长的字符串。需要 1 或 2 个额外的字节记录字符串的长度。Char，定长，适合存储固定长度的字符串，如 MD5 值。</li><li>Blob，Text为了存储很大的数据而设计的。分别采用二进制和字符的方式。</li><li>时间类型DateTime，保存大范围的值，占 8 个字节。TimeStamp，推荐，与 UNIX 时间戳相同，占 4 个字节。<h6 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h6></li><li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<code>select id from t where num is null</code>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<code>select id from t where num=0</code></li><li>用EXISTS替代IN、用NOT EXISTS替代NOT IN</li><li>用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤。</li><li>尽量避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</li><li>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。</li><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引<h6 id="索引优化-选择索引的数据类型"><a href="#索引优化-选择索引的数据类型" class="headerlink" title="索引优化(选择索引的数据类型)"></a>索引优化(选择索引的数据类型)</h6>MySQL支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。</li><li>越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和cpu缓存中都需要更少的空间，处理起来更快。</li><li>简单的数据类型更好：整形数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应用内置的日期和时间数据类型，而不是字符串来存储时间；以及用整形数据存储IP地址。</li><li>尽量避免NULL：应该制定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为他们使得索引、索引的统计信息以及比较运算更加复杂。</li><li>为了更多的提高mysql效率可建立组合索引，遵循“最左前缀”原则。创建复合索引应该将最常用（频率）做限制条件的列放在最左边，一次递减。组合索引最左字段用in是可以用到索引的。相当于建立了col1,col1col2,col1col2col3三个索引。<h6 id="分库分表优化"><a href="#分库分表优化" class="headerlink" title="分库分表优化"></a>分库分表优化</h6></li><li><p>垂直拆分：解决问题：表与表之间的io竞争 不解决问题：单表中数据量增长出现的压力</p><blockquote><p>方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上。</p></blockquote></li><li><p>水平拆分： 解决问题：单表中数据量增长出现的压力 不解决问题：表与表之间的io争夺</p><blockquote><p>用户表通过性别拆分为男用户表和女用户表 订单表通过已完成和完成中拆分为已完成订单和未完成订单 产品表 未完成订单放一个server上 已完成订单表盒男用户表放一个server上 女用户表放一个server上(女的爱购物 哈哈)，<br><strong>==可以把学校范围内的用户单独独立出来一张表==。</strong></p></blockquote></li></ul><p>MySQL不需要执行后面的复杂操作，就可以直接返回结果，效率很高，==但是查询缓存失效非常频繁，只要有对一个表的更新，这个表的所有查询缓存都会被清空，因此可能你费力地把结果缓存起来，还没使用，就被一个更新全部清空了。除非你的业务是一张静态表，很长时间才会更新一次，这种情况下可以使用查询缓存==。(==把管理员信息放进去==)</p><h2 id="7-三范式"><a href="#7-三范式" class="headerlink" title="7.三范式"></a>7.三范式</h2><h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>==如果一个关系模式的所有属性的域都是原子的是指数据库表的每一列都是不可分割的基本数据项==，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。（2NF）==要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性==，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p><h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><ul><li>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。（我的理解是消除冗余）</li><li>优点:可以尽量得减少数据冗余，使得更新快，体积小</li><li>缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化</li></ul>]]></content>
    
    <summary type="html">
    
      U can find everything  be need in here.
    
    </summary>
    
    
      <category term="MySQL, DataBase" scheme="http://yoursite.com/tags/MySQL-DataBase/"/>
    
  </entry>
  
</feed>
