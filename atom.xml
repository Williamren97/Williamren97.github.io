<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>REN WEI&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-04T02:36:07.572Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>William Ren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Binary Search.</title>
    <link href="http://yoursite.com/2020/06/04/Binary-Search/"/>
    <id>http://yoursite.com/2020/06/04/Binary-Search/</id>
    <published>2020-06-04T02:28:54.000Z</published>
    <updated>2020-06-04T02:36:07.572Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/Users/WilliamRen/Nutstore Files/博客图床/排除法找二分.png" alt="排除法找二分"></p><p><img src="/Users/WilliamRen/Nutstore Files/博客图床/边界收缩问题.png" alt="边界收缩问题"></p><p><img src="/Users/WilliamRen/Nutstore Files/博客图床/限制条件.png" alt="限制条件"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> des)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> low = <span class="number">0</span>, high = array.length - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">         <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;<span class="comment">//int mid = (left + right) &gt;&gt; 1;</span></span><br><span class="line">         <span class="keyword">if</span> (des == array[mid]) &#123;</span><br><span class="line">             <span class="keyword">return</span> mid;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (des &lt; array[mid]) &#123;</span><br><span class="line">             high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：针对特殊测试用例，例如 2147395599</span></span><br><span class="line">        <span class="comment">// 要把搜索的范围设置成长整型</span></span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> right = x / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环</span></span><br><span class="line">            <span class="comment">// long mid = left + (right - left + 1) / 2;</span></span><br><span class="line">            <span class="keyword">long</span> mid = (left + right + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> square = mid * mid;</span><br><span class="line">            <span class="keyword">if</span> (square &gt; x) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为一定存在，因此无需后处理</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/fIDeC5yQUJUO4KCwfjziow" target="_blank" rel="noopener">二分查找</a></p><p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">Binary Search Solution  in Leetcode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/Users/WilliamRen/Nutstore Files/博客图床/排除法找二分.png&quot; alt=&quot;排除法找二分&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Users/WilliamRen/Nutstore Files/博客图床/边界收缩问题.p
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Everything About TreeMap</title>
    <link href="http://yoursite.com/2020/03/21/Everything-About-TreeMap/"/>
    <id>http://yoursite.com/2020/03/21/Everything-About-TreeMap/</id>
    <published>2020-03-21T06:07:11.000Z</published>
    <updated>2020-03-21T06:11:03.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>文章的内容基于JDK1.7进行分析，之所以选用这个版本，是因为1.8的有些类做了改动，增加了阅读的难度，虽然是1.7，但是对于1.8做了重大改动的内容，文章也会进行说明。</p><p>TreeMap实现了SotredMap接口，它是有序的集合。而且是一个红黑树结构，每个key-value都作为一个红黑树的节点。如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。这点会在接下来的代码中做说明，如果指定了比较器则按照比较器来进行排序。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serializable, Cloneable, Map&lt;K,V&gt;, NavigableMap&lt;K,V&gt;, SortedMap&lt;K,V&gt;</span><br></pre></td></tr></table></figure><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;  <span class="comment">//比较器，是自然排序，还是定制排序 ，使用final修饰，表明一旦赋值便不允许改变</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="keyword">null</span>;  <span class="comment">//红黑树的根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;     <span class="comment">//TreeMap中存放的键值对的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;   <span class="comment">//修改的次数</span></span><br></pre></td></tr></table></figure><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>由于TreeMap中源码较长，接下来将分段解析部分源码。既然是红黑树存储，肯定要有数据结构（Node）节点的。看一下TreeMap中关于节点的定义部分。</p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;    <span class="comment">//键</span></span><br><span class="line">    V value;    <span class="comment">//值</span></span><br><span class="line">    Entry&lt;K,V&gt; left = <span class="keyword">null</span>;     <span class="comment">//左孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; right = <span class="keyword">null</span>;    <span class="comment">//右孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;          <span class="comment">//父节点</span></span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;      <span class="comment">//节点的颜色，在红黑树种，只有两种颜色，红色和黑色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，用指定的key,value ,parent初始化，color默认为黑色</span></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回该节点对应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换节点的值，并返回旧值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写equals()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="comment">//两个节点的key相等，value相等，这两个节点才相等</span></span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写hashCode()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> keyHash = (key==<span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> valueHash = (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="comment">//key和vale hash值得异或运算，相同则为零，不同则为1 </span></span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写toString()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法，comparator用键的顺序做比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法，提供比较器，用指定比较器排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    his.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将m中的元素转化daoTreeMap中，按照键的顺序做比较排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法，指定的参数为SortedMap</span></span><br><span class="line"><span class="comment">//采用m的比较器排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeMap提供了四个构造方法，实现了方法的重载。无参构造方法中比较器的值为null,采用自然排序的方法，如果指定了比较器则称之为定制排序.</p><ul><li>自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象</li><li>定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。</li></ul><p>对于Map来说，使用的最多的就是put()/get()/remove()等方法，下面依次进行分析</p><h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;     <span class="comment">//红黑树的根节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;        <span class="comment">//红黑树是否为空</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        <span class="comment">//构造根节点，因为根节点没有父节点，传入null值。 </span></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);  </span><br><span class="line">        size = <span class="number">1</span>;     <span class="comment">//size值加1</span></span><br><span class="line">        modCount++;    <span class="comment">//改变修改的次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">//返回null </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;    <span class="comment">//定义节点</span></span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;     <span class="comment">//获取比较器</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;      <span class="comment">//如果定义了比较器，采用自定义比较器进行比较</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;      <span class="comment">//将红黑树根节点赋值给parent</span></span><br><span class="line">            cmp = cpr.compare(key, t.key);     <span class="comment">//比较key, 与根节点的大小</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)      <span class="comment">//如果key &lt; t.key , 指向左子树</span></span><br><span class="line">                t = t.left;   <span class="comment">//t = t.left  , t == 它的做孩子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;  <span class="comment">//如果key &gt; t.key , 指向它的右孩子节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);      <span class="comment">//如果它们相等，替换key的值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);        <span class="comment">//循环遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//自然排序方式，没有指定比较器</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  <span class="comment">//抛出异常</span></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;    <span class="comment">//类型转换</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)     <span class="comment">// key &lt; t.key </span></span><br><span class="line">                t = t.left;   <span class="comment">//左孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)   <span class="comment">// key &gt; t.key </span></span><br><span class="line">                t = t.right;    <span class="comment">//右孩子</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);   <span class="comment">//t == t.key , 替换value值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);   <span class="comment">//创建新节点，并制定父节点</span></span><br><span class="line">    <span class="comment">//根据比较结果，决定新节点为父节点的左孩子或者右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);   <span class="comment">//新插入节点后重新调整红黑树 </span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较方法，如果comparator==null ,采用comparable.compartTo进行比较，否则采用指定比较器比较大小</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入的节点默认的颜色为红色</span></span><br><span class="line">    x.color = RED;    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//情形1： 新节点x 是树的根节点，没有父节点不需要任何操作</span></span><br><span class="line">    <span class="comment">//情形2： 新节点x 的父节点颜色是黑色的，也不需要任何操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">    <span class="comment">//情形3：新节点x的父节点颜色是红色的</span></span><br><span class="line">    <span class="comment">//判断x的节点的父节点位置，是否属于左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">          <span class="comment">//获取x节点的父节点的兄弟节点，上面语句已经判断出x节点的父节点为左孩子，所以直接取右孩子</span></span><br><span class="line">         Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">         <span class="comment">//判断是否x节点的父节点的兄弟节点为红色。</span></span><br><span class="line">         <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">              setColor(parentOf(x), BLACK); <span class="comment">// x节点的父节点设置为黑色</span></span><br><span class="line">              setColor(y, BLACK);           <span class="comment">// y节点的颜色设置为黑色</span></span><br><span class="line">              setColor(parentOf(parentOf(x)), RED); <span class="comment">// x.parent.parent设置为红色</span></span><br><span class="line">              x = parentOf(parentOf(x)); <span class="comment">// x == x.parent.parent ,进行遍历。</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//x的父节点的兄弟节点是黑色或者缺少的</span></span><br><span class="line">               <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;   <span class="comment">//判断x节点是否为父节点的右孩子</span></span><br><span class="line">                    x = parentOf(x);     <span class="comment">//x == 父节点</span></span><br><span class="line">                    rotateLeft(x);    <span class="comment">//左旋转操作</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//x节点是其父的左孩子</span></span><br><span class="line">               setColor(parentOf(x), BLACK);</span><br><span class="line">               setColor(parentOf(parentOf(x)), RED);  <span class="comment">//上面两句将x.parent 和x.parent.parent的颜色做调换</span></span><br><span class="line">               rotateRight(parentOf(parentOf(x)));   <span class="comment">//进行右旋转</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));  <span class="comment">//y 是x 节点的祖父节点的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;    <span class="comment">//判断颜色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);    <span class="comment">//父节点设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);         <span class="comment">//父节点的兄弟节点设置为黑色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);   <span class="comment">//祖父节点设置为红色</span></span><br><span class="line">                x = parentOf(parentOf(x));   <span class="comment">//将祖父节点作为新插入的节点，遍历调整</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;     <span class="comment">//x 是其父亲的左孩子</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);    <span class="comment">//以父节点为旋转点，进行右旋操作</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);    <span class="comment">//父节点为设置为黑色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);  <span class="comment">//祖父节点设置为红色</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));  <span class="comment">//以父节点为旋转点，进行左旋操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK; <span class="comment">//通过节点位置的调整，最终将红色的节点条调换到了根节点的位置，根节点重新设置为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>红黑树是一个更高效的检索二叉树，有如下特点：</p><ol><li>每个节点只能是红色或者黑色</li><li>根节点永远是黑色的</li><li>所有的叶子的子节点都是空节点，并且都是黑色的</li><li>每个红色节点的两个子节点都是黑色的（不会有两个连续的红色节点）</li><li>从任一个节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点（叶子节点到根节点的黑色节点数量每条路径都相同）</li></ol><p>上面的代码，详细的标注了每条语句的作用，但是我相信，如果你没有一定的功力，即使注释已经很详细了，你也会是一脸懵逼 ，二脸懵逼，全脑懵逼中，下面配合图片来梳理一下代码所表示的含义：<br>当一个默认为红色的节点插入树中，其实对应的是7中可能发生的情况，分别进行叙述：</p><ul><li>情形1：新插入的节点时红黑树的根节点，没有父节点，无需任何的操作，直接将颜色设置为黑色就可以了</li><li>情形2：新节点的父节点颜色是黑色的，新插入的节点是红色的。也无需任何的操作。因为新节点的插入并没有影响到红黑书的特点</li><li>情形3：新节点的父节点（左孩子节点）颜色是红色的，而父节点的兄弟节点颜色也是红色的。那么情况就出现了，此时插入的节点就违反了红黑树的特点4 ，需要对红黑树进行调整。 操作看下图：<img src="https://static.oschina.net/uploads/space/2018/0228/120104_Rfsm_2927759.png" alt="img"><br>调整操作如上图，将父节点和父节点的兄弟节点，都修改为红色，然后将祖父节点修改为红色，因为修改了祖父节点的颜色，祖父节点可能会发生颜色的冲突，所以将新插入的节点修改为祖父节点，在进行调整。</li><li>情形4：父节点（左孩子节点）的颜色为红色，父节点的兄弟节点的颜色为黑色或者为null，新插入的节点为父节点的右孩子节点。如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/120219_SNXd_2927759.png" alt="img"><br>此时以父节点为旋转点，就新插入的节点进行左旋操作。便变成了情形5对应的情况，将执行情形5的操作</li><li>情形5：父节点（左孩子节点）的颜色为红色，父节点的兄弟节点颜色为黑色或者null,新插入节点为父亲的左孩子节点。如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/120301_ZnNC_2927759.png" alt="img"></li><li>情形6 和情形7的操作与情形4和情形5的操作相同，它们之前的区别是父节点为有孩子节点，再次不再赘述。</li></ul><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);  <span class="comment">//根据key查找节点，并返回该节点</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    V oldValue = p.value;    <span class="comment">//获取key对应的值</span></span><br><span class="line">    deleteEntry(p);     <span class="comment">//删除节点</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;   <span class="comment">//返回key对应的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据键寻找节点，有非为两种方式，如果定制了比较器，采用定制排序方式，否则使用自然排序</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key); <span class="comment">//循环遍历树，寻找和key相等的节点</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;  <span class="comment">//循环遍历树，寻找和key相等的节点</span></span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;  <span class="comment">//记录修改的次数</span></span><br><span class="line">    size--;   <span class="comment">//数量减1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的两个孩子都不为空</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//寻找继承者，继承者为当前节点的右孩子节点或者右孩子节点的最小左孩子</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;     <span class="comment">//key - value  的替换 ，并没有替换颜色</span></span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;  <span class="comment">//指向继承者</span></span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line">    <span class="comment">//开始修复树结构，继承者的左孩子不为空，返回左孩子，否则返回右孩子</span></span><br><span class="line">    <span class="comment">//不可能存在左右两个孩子都存在的情况，successor寻找的就是最小节点，它的左孩子节点为null</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Link replacement to parent</span></span><br><span class="line">        <span class="comment">//已经被选为继承者，当前拥有的一切放弃，所以将孩子交给爷爷抚养</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="comment">//p节点没有父节点，则指向根节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">           root = replacement;</span><br><span class="line">        <span class="comment">//如果p为左孩子，如果p为左孩子，则将p.parent.left = p.left</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除p节点到左右分支，和父节点的引用</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fix replacement</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            <span class="comment">//恢复颜色分配</span></span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">        <span class="comment">//红黑书中父节点为空的只能是根节点。</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不是根节点，颜色为黑色，调整结构</span></span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断x是否为左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            <span class="comment">//x的兄弟节点</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            <span class="comment">//若兄弟节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);   <span class="comment">//设置兄弟节点变为黑色</span></span><br><span class="line">                setColor(parentOf(x), RED);  <span class="comment">//父节点设置为红色</span></span><br><span class="line">                rotateLeft(parentOf(x));   <span class="comment">//左旋父节点</span></span><br><span class="line">                sib = rightOf(parentOf(x)); <span class="comment">//重新设置x的兄弟节点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED); <span class="comment">//兄弟节点的两个孩子都是黑色的重新设置兄弟节点的颜色，修改为红色</span></span><br><span class="line">                x = parentOf(x);   <span class="comment">//将x定位到父节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;   <span class="comment">//兄弟节点的右孩子是黑色的，左孩子是红色的</span></span><br><span class="line">                    setColor(leftOf(sib), BLACK);  <span class="comment">//设置左孩子节点为黑色</span></span><br><span class="line">                    setColor(sib, RED); <span class="comment">//兄弟节点为红色</span></span><br><span class="line">                    rotateRight(sib);   <span class="comment">//右旋</span></span><br><span class="line">                    sib = rightOf(parentOf(x));  <span class="comment">//右旋后重新设置兄弟节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));  <span class="comment">//兄弟节点颜色设置和父节点的颜色相同</span></span><br><span class="line">                setColor(parentOf(x), BLACK);   <span class="comment">//父节点设置为黑色</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);  <span class="comment">//将兄弟节点的有孩子设置为黑色</span></span><br><span class="line">                rotateLeft(parentOf(x));   <span class="comment">//左旋</span></span><br><span class="line">                x = root;  <span class="comment">//设置x为根节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            <span class="comment">//x为父节点的右节点，参考上面的操作</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除红黑树的操作比插入操作要稍微麻烦一点，分为两步：</p><ul><li>以排序二叉树的方法删除指定节点。删除的节点存在三种情况：<ul><li>被删除节点，没有左右孩子节点，直接删除即可</li><li>被删除节点，有一个孩子节点，那么让它的孩子节点指向它的父节点即可</li><li>本删除的节点，有两个非空的孩子节点，那么需要找到该节点的前驱或者后继节点，更换元素值，在将前驱或者后继节点删除（任意一个节点的前驱或者后继都必定至多有一个非空的子节点，可以按照前面的两种情形进行操作）</li></ul></li><li>进行颜色的调换和树的旋转，满足红黑树的特征</li></ul><p>下面来分情形讨论一下可能发生的情况：</p><ul><li>情形1：被删除的节点为根节点或者颜色为空色，此时删除该节点不影响红黑树的特点。无需操作</li><li>情形2：被删除节点为黑色，兄弟节点为红色，如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/120648_lZYh_2927759.png" alt="img"><br>若删除上图中的x节点，将缺少一个黑节点，与红黑树的性质冲突，所以修改sib颜色为黑色，设置p节点为红色，并进行左旋操作。在进行后续的处理。</li><li>情形3：被删除节点为黑色，x节点的兄弟节点的子节点都是黑色，如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/120742_LGd3_2927759.png" alt="img"><br>x节点是黑色的，兄弟节点（黑色的）的子节点也是黑色的，p节点的颜色无法确定，有可能是红色的，也有可能是黑色的。如果是红色的直接设置为黑色即可，如果为黑色的，则需要将x定位的p节点，在进行处理。</li><li>情形4：被删除节点为黑色，x的兄弟节点的右自子节点为黑色。如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/120844_0oQ7_2927759.png" alt="img"><br>情形4的调整为了转变成情形5的情况，来进行处理。</li><li>情形5：被删除节点为黑色，x的兄弟节点右子节点为红色。如下图：<br><img src="https://static.oschina.net/uploads/space/2018/0228/124855_O7NA_2927759.png" alt="img"><br>sib的左子节点的颜色不确定，可能是红色也可能是黑色，但是对它并没有什么影响，因为变换前后它的上层分支的黑色节点数并没有改变。</li></ul><p>上面的情形只是针对删除的节点是左孩子的情况，进行的分析，被删除的节点也可能是右分支。情况完全相同只不过左右顺序发生了颠倒，不再进行复述。</p><p>至此TreeMap中实现的最重要已经说完了。</p><p>下面简单说一下一些方法的作用</p><ul><li>firstEntry() 返回Map中最小的key</li><li>higherEntry(Object key ) 返回该Map中位于key后一位的key-value</li><li>lowerEntry(Object key ) 返回该Map中唯一key前一位的key-value</li><li>tailMap(Object key , boolean inclusive) 返回该Map的子Map</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><ul><li>关于红黑树的节点插入操作，首先是改变新节点，新节点的父节点，祖父节点，和新节点的颜色，能在当前分支通过节点的旋转改变的，则通过此种操作，来满足红黑书的特点。</li><li>如果当前相关节点的旋转解决不了红黑树的冲突，则通过将红色的节点移动到根节点解决，最后在将根节点设置为黑色</li></ul>]]></content>
    
    <summary type="html">
    
      Find Everything about TreeMap IN There.
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>Everything About ConcurrentHashMap</title>
    <link href="http://yoursite.com/2020/03/21/Everything-About-ConcurrentHashMap/"/>
    <id>http://yoursite.com/2020/03/21/Everything-About-ConcurrentHashMap/</id>
    <published>2020-03-21T06:06:48.000Z</published>
    <updated>2020-03-21T06:09:34.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ConcurrentHashMap常用于并发编程，这里就从源码上来分析一下ConcurrentHashMap数据结构和底层原理。</p><p>在开始之前先介绍一个算法， 这个算法和Concurrent的实现是分不开的。<br>CAS算法：</p><ul><li>CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</li><li>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</li><li>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B</li></ul><p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><p><strong>ConcurrentHashMap是一个线程安全的Map集合，可以应对高并发的场景，保证线程安全。</strong>相比较HashTable，它的锁粒度更加的细化，因为HashTable的方法都是用Synchronized修饰的，效率灰常的底下。</p><p>1.8之前ConcurrentHashMap使用锁分段技术，将数据分成一段段的存储，每一个数据段配置一把锁，相互之间不影响，而1.8之后摒弃了Segment（锁段）的概念，启用了全新的实现，也就是利用<strong>CAS+Synchronized</strong>来保证并发更新的安全，底层采用的依然是数组+链表+红黑树。</p><p>本篇文章是基于JDK1.8 。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 继承了AbstractMap ,并且实现了ConcurrentMap接口。</p><h2 id="与HashMap比对："><a href="#与HashMap比对：" class="headerlink" title="与HashMap比对："></a>与HashMap比对：</h2><ul><li>相同点：都集成了AbstractMap接口</li><li>不同点：HashMap实现了Map接口，ConcurrentHashMap实现了ConcurrentMap接口，而ConcurrentMap继承了Map接口，使用default关键字定义了一些方法 。</li></ul><p>从继承关系上看ConcurrentHashMap与HashMap并没有太大的区别。</p><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//最大容量2的30次方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>; <span class="comment">//默认容量  1&lt;&lt;4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;  <span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;  <span class="comment">//链表转为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;  <span class="comment">//树转列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// forwarding nodes 的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// roots of trees 的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// transient reservations 的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors(); <span class="comment">//可用处理器数量</span></span><br></pre></td></tr></table></figure><p>重点说一下 <strong>sizeCtrl</strong> 属性，这个属性在 ConcurrentHashMap 中扮演者重要的角色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表初始化或者扩容的一个控制标识位</span></span><br><span class="line"><span class="comment">//负数代表正在进行初始化或者扩容的操作</span></span><br><span class="line"><span class="comment">// -1 代表初始化</span></span><br><span class="line"><span class="comment">// -N 代表有n-1个线程在进行扩容操作</span></span><br><span class="line"><span class="comment">//正数或者0表示没有进行初始化操作，这个数值表示初始化或者下一次要扩容的大小。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//transient 修饰的属性不会被序列化，volatile保证可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造方法，没有进行任何操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//指定初始化大小构造方法，判断参数的合法性，并创建了计算初始化的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//将指定的集合转化为ConcurrentHashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//指定初始化大小和负载因子的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//指定初始化大小，负载因子和concurrentLevel并发更新线程的数量，也可以理解为segment的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ConcurrentHashMap的构造方法并没做太多的工作，主要是进行了参数的合法性校验，和初始值大小的转换。这个方法 tableSizeFor()说明一下， 主要的功能就是将指定的初始化参数转换为2的幂次方形式， 如果初始化参数为9 ，转换后初始大小为16 。</p></blockquote><h2 id="内部数据结构"><a href="#内部数据结构" class="headerlink" title="内部数据结构"></a>内部数据结构</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a><strong>Node</strong></h3><p>首当其冲，因为它是ConcurrentHashMap的核心，它包装了key-value的键值对，所有插入的数据都包装在这里面，与HashMap很相似，但是有一些差别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">     <span class="keyword">final</span> K key;</span><br><span class="line">     <span class="keyword">volatile</span> V val;</span><br><span class="line">     <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">     Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.hash = hash;</span><br><span class="line">         <span class="keyword">this</span>.key = key;</span><br><span class="line">         <span class="keyword">this</span>.val = val;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 和 next使用了volatile修饰，保证了线程之间的可见性。也不允许调用setValue()方法直接改变Node的值。并增加了find()方法辅助map.get()方法。</p><h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a><strong>TreeNode</strong></h3><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap集成自Node类，而并非HashMap中的集成自LinkedHashMap.Entry类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。</p><h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a><strong>TreeBin</strong></h3><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。</p><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a><strong>ForwardingNode</strong></h3><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找</p><h1 id="ConcurrentHashMap常用方法"><a href="#ConcurrentHashMap常用方法" class="headerlink" title="ConcurrentHashMap常用方法"></a><strong>ConcurrentHashMap常用方法</strong></h1><h2 id="initTable-初始化方法"><a href="#initTable-初始化方法" class="headerlink" title="initTable 初始化方法"></a><strong>initTable 初始化方法</strong></h2><p>初始化方法是很重要的一个方法，因为在ConcurrentHashMap的构造方法中只是简单的进行了一些参数校验和参数转换的操作。整个Map的初始化是在插入元素的时候触发的。这一点在下面的put方法中会进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行初始化操作，单线程操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//sizeCtl &lt; 0 表示有线程正在进行初始化操作，从运行状态变为就绪状态。</span></span><br><span class="line">                Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment">//设置SIZECTL的值为-1，阻塞其他线程的操作</span></span><br><span class="line">            <span class="comment">//该方法有四个参数</span></span><br><span class="line">            <span class="comment">//第一个参数：需要改变的对象</span></span><br><span class="line">            <span class="comment">//第二个参数：偏移量</span></span><br><span class="line">            <span class="comment">//第三个参数：期待的值</span></span><br><span class="line">            <span class="comment">//第四个参数：更新后的值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//再次检查是否有线程进行了初始化操作</span></span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        <span class="comment">//初始化Node对象数组</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        <span class="comment">//sc的值设置为n的0.75倍</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);  <span class="comment">//相当于n*0.75</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;  <span class="comment">//更改sizeCtl的值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//中断循坏返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> tab; <span class="comment">//返回初始化的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a><strong>扩容方法</strong></h2><p>当ConcurrentHashMap 容量不足的时候，需要对table进行扩容，这个方法是支持多个线程并发扩容的，我们所说的扩容，从本质上来说，无非是从一个数组到另外一个数组的拷贝。</p><p>扩容方法分为两个部分：</p><ul><li>创建扩容后的新数组，容量变为原来的两倍 ，新数组的创建时单线程完成</li><li>将原来的数组元素复制到新的数组中，这个是多线程操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//帮助扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">      <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;(nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;(sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tab = table ,nextTab 一个Node&lt;Key,Value&gt;[]类型的变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n 是tab的长度 ， stride 初始值为0 </span></span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="comment">//判断cpu处理多线程的能力，如果小于16就直接赋值为16</span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="comment">//构造一个容量是原来两倍的Node&lt;K ,V&gt; 类型数组</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;  <span class="comment">//赋值</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;  <span class="comment">//赋值</span></span><br><span class="line">            transferIndex = n;    <span class="comment">//将数组长度赋值给transferIndex</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;  <span class="comment">//获取新数组的长度</span></span><br><span class="line">        </span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);  <span class="comment">//创建fwd节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">//使用for循环来处理每个槽位中的链表元素，CAS设置transferIndex属性值，并初始化i和bound值</span></span><br><span class="line">         <span class="comment">// i 指当前的槽位序号，bound值需要处理的边界，先处理槽位为15的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//创建两个变量，一个为Node&lt;K,V&gt; 类型，一个为int类型</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//将transferIndex的值赋值给 nextIndex ,并判断nextIndex的值是否小于等于0</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;   </span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//更新nextIndex的值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="comment">//如果table已经复制结束</span></span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="keyword">null</span>;   <span class="comment">//清空nextTable</span></span><br><span class="line">                    table = nextTab;    <span class="comment">//把nextTab 赋值给 table </span></span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);  <span class="comment">//阈值设置为容量的1.5倍</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CAS算法获取某个数组节点，为空就设置为fwd</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果某个节点的hash为-1，跳过</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//对头节点加锁，禁止其他线程进入</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//构造两个链表 ，将该节点的列表拆分为两个部分，一个是原链表的排列顺序，一个是反序</span></span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;  </span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;   <span class="comment">// fh 当前节点的hash值   若 &gt;= 0 </span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;    <span class="comment">//将当前节点赋值给 lastRun  节点  </span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//差分列表操作</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//在nextTab 的i 位置上放置ln节点</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            <span class="comment">//在nextTab 的 i+n 位置上放置 hn节点</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">//在tab节点i位置上插入插入forwardNode节点，表示该节点已经处理</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//对TreeBin对象进行处理，过程与上面有些类似 </span></span><br><span class="line">                        <span class="comment">//也把节点分类，分别插入到lo和hi为头节点的链表中</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//如果扩容后 不在需要tree结构，反向转换成链表结构</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a><strong>put方法</strong></h2><p>put操作是最长用的方法，接下来看一下put()方法的具体实现：</p><ul><li>put()要求键值都不能为空</li><li>需要经过两次散列， 是数据均匀分散，减少碰撞的次数</li><li>判断tab是否进行了初始化，没有则调用initTable进行初始化操作（单线程）</li><li>数组i的位置没有元素存在，直接放入</li><li>如果i的位置在进行MOVE操作，也就是在进行扩容操作，则多线程帮助扩容</li><li>如果i的位置有元素存在，则在该节点加锁Synchronized，判断是链表还是红黑树，按照相应的插入规则插入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key|value == null  抛出异常</span></span><br><span class="line">    <span class="comment">//ConcurrentHashMap不允许键或者值为null的这种情况发生</span></span><br><span class="line">    <span class="comment">//这一点和HashMap有区别</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//散列在散列， 让数据均匀分布，减少碰撞次数</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());     --&gt;<span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;<span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;&#125;   </span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//死循环   相当于while(true) ,将table赋值给 tab </span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个Node类型的变量f , int 类型的变量 n i fh </span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断tab是否为null  ,是否进行了初始化操作，如果没有执行初始化，执行初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">            <span class="comment">//tabAt 获取值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//添加到table中</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">//退出循环               // no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//node的hash值为 -1 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//key 相等，使用新值替换旧值</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;((ek = e.key) == key ||(ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//放在链表的尾部</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;   </span><br><span class="line">                    <span class="comment">//红黑树替换</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a><strong>Get方法</strong></h2><p>Get方法也是最长用的方法，元素放入了，总要取出来</p><ul><li>根据传入的key,获取相应的hash值</li><li>然后判断当前的table数组是否为空</li><li>计算指定的key在table中存储的位置</li><li>链表或者红黑树转换相依的方法处理</li><li>不存在则返回null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//eh&lt; 0 表示红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//链表遍历</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK6，7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，把HashMap分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。</p><p>jdk7中ConcurrentHashmap中，当长度过长，碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能，所以jdk8 中完全重写了concurrentHashmap,代码量从原来的1000多行变成了 6000多 行，实现上也和原来的分段式存储有很大的区别。</p><p>主要设计上的变化有以下几点:</p><ol><li>不采用segment而采用node，锁住node来实现减小锁粒度。</li><li>设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。</li><li>使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。</li><li>sizeCtl的不同值来代表不同含义，起到了控制的作用。</li></ol><p>参考：</p><p><a href="https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Fu010723709%2Farticle%2Fdetails%2F48007881" target="_blank" rel="noopener">http://blog.csdn.net/u010723709/article/details/48007881</a></p>]]></content>
    
    <summary type="html">
    
      Find Everything about ConcurrentHashMap IN There.
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>Everything About HashSet</title>
    <link href="http://yoursite.com/2020/03/21/Everything-About-HashSet/"/>
    <id>http://yoursite.com/2020/03/21/Everything-About-HashSet/</id>
    <published>2020-03-21T05:39:21.000Z</published>
    <updated>2020-03-21T05:44:54.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>文章的内容基于JDK1.7进行分析，之所以选用这个版本，是因为1.8的有些类做了改动，增加了阅读的难度，虽然是1.7，但是对于1.8做了重大改动的内容，文章也会进行说明。</p><p>HashSet是Set接口的典型实现，HashSet按照Hash算法来存储集合中的元素。存在以下特点：</p><ul><li>不能保证元素的顺序，元素是无序的</li><li>HashSet不是同步的，需要外部保持线程之间的同步问题</li><li>集合元素值允许为null</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">    java.util.AbstractCollection&lt;E&gt; </span><br><span class="line">        java.util.AbstractSet&lt;E&gt; </span><br><span class="line">            java.util.HashSet&lt;E&gt;</span><br></pre></td></tr></table></figure><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serializable, Cloneable, Iterable&lt;E&gt;, Collection&lt;E&gt;, Set&lt;E&gt;</span><br></pre></td></tr></table></figure><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  <span class="comment">//map集合，HashSet存放元素的容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object(); <span class="comment">//map，中键对应的value值</span></span><br></pre></td></tr></table></figure><h1 id="重要方法深度解析"><a href="#重要方法深度解析" class="headerlink" title="重要方法深度解析"></a>重要方法深度解析</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造方法，完成map的创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定集合转化为HashSet, 完成map的创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">   map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始化大小，和负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始化大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始化大小和负载因子，dummy 无实际意义</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造函数，不难发现，HashSet的底层是采用HashMap实现的。</p><h2 id="Add-方法"><a href="#Add-方法" class="headerlink" title="Add()方法"></a>Add()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PRESENT为HashSet类中定义的一个使用static final 修饰的常量，并无实际的意义，HashSet的add方法调用HashMap的put()方法实现，如果键已经存在，map.put()放回的是旧值，添加失败，如果添加成功map.put()方法返回的是null ,HashSet.add()方法返回true,要添加的元素可作为map中的key 。</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除方法，调用map.remove()方法实现，map.remove()能找到指定的key,则返回key对应的value,对于Hashset而言，它所有的key对应的值都是PRESENT。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>; <span class="comment">//序列化版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  <span class="comment">//HashMap变量，用于存放HashSet的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object(); <span class="comment">//map中的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，将指定的集合转化为HashSet</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，指定初始化的大小和负载因子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指定初始化大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，采用default修饰，只能是同一个包下的成员访问。包不相同无法访问</span></span><br><span class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HashSet的遍历操作</span></span><br><span class="line">    <span class="comment">//通过这个方法可以发现，HashSet调用了HashMap存放，因为HashSet并不是键值对存储，所以它只是把它的值做了Map中的键，在遍历HashSet的集合元素时，实际上是遍历的Map中Key的集合。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回集合中元素的容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否包含指定的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素，添加的元素作为了Map中的key,value使用了一个常量表示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//克隆方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">            <span class="keyword">return</span> newSet;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入输出流操作。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out HashMap capacity and load factor</span></span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size</span></span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从输入流中读取对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in HashMap capacity and load factor and create backing HashMap</span></span><br><span class="line">        <span class="keyword">int</span> capacity = s.readInt();</span><br><span class="line">        <span class="keyword">float</span> loadFactor = s.readFloat();</span><br><span class="line">        map = (((HashSet)<span class="keyword">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">               <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               <span class="keyword">new</span> HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size</span></span><br><span class="line">        <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            E e = (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>HashSet的底层通过HashMap实现的。而HashMap在1.7之前使用的是数组+链表实现，在1.8+使用的数组+链表+红黑树实现。其实也可以这样理解，HashSet的底层实现和HashMap使用的是相同的方式，因为Map是无序的，因此HashSet也无法保证顺序。</li><li>HashSet的方法，也是借助HashMap的方法来实现的。</li></ul>]]></content>
    
    <summary type="html">
    
      Find Everything about HashSet IN There.
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>2019-2In TaiwanTech</title>
    <link href="http://yoursite.com/2020/02/17/2019-2In-TaiwanTech/"/>
    <id>http://yoursite.com/2020/02/17/2019-2In-TaiwanTech/</id>
    <published>2020-02-17T10:10:48.000Z</published>
    <updated>2020-03-30T04:19:58.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大四上學期的成績單"><a href="#大四上學期的成績單" class="headerlink" title="大四上學期的成績單"></a>大四上學期的成績單</h2><p><img src="https://i.loli.net/2020/02/17/M5U9XmiwQfFJ3bZ.png" alt="1082.png"></p><p>後面再補內容，已經錯過實習和秋招了。現在抓緊搞搞春招。</p><blockquote><p>學校的課實在太多，30學分忙8過來</p></blockquote><p>回家以后发现钙hub也打不开了…..除了科学上网的解决方法，另外一种就是<a href="https://blog.csdn.net/ustccw/article/details/84543284" target="_blank" rel="noopener">设置静态IP地址</a></p><p>图床也加载不出来了，这里推荐<a href="https://sm.ms/" target="_blank" rel="noopener">SM SM的图床服务</a></p><h2 id="新年新FLAG"><a href="#新年新FLAG" class="headerlink" title="新年新FLAG"></a>新年新FLAG</h2><h3 id="专业技术"><a href="#专业技术" class="headerlink" title="专业技术"></a>专业技术</h3><ul><li>按照zuochengyun大哥的建议读JDK重要包的源代码,<br><code>java.lang</code>,<code>java.util</code>.<code>java.io</code></li><li><p>Spring源码,</p></li><li><p>学习分布式缓存技术.</p></li><li><p>PASS THE FRM Certification RANK1</p></li></ul><h3 id="语言水平"><a href="#语言水平" class="headerlink" title="语言水平"></a>语言水平</h3><ul><li>日语达到N3水平</li></ul><p><a href="https://www.zhihu.com/question/59051017/answer/161476178" target="_blank" rel="noopener">如何自学备考日语N3？</a></p><ul><li>TOEFL破百</li></ul><h3 id="📚书单"><a href="#📚书单" class="headerlink" title="📚书单"></a>📚书单</h3><ul><li><p>Thinking In Java</p><p>Bruce Eckel 的《Java 编程思想》（Thinking in Java），非常有名的经典书籍。这本书的特点是，不仅仅介绍 Java 编程的基础知识点，也会思考编程中的各种选择与判断，包括穿插设计模式的使用，作者从理论到实践意义从不同的角度进行探讨，构建稳固的 Java 编程知识体系。</p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1849198902,3579180612&amp;fm=26&amp;gp=0.jpg" alt="img" style="zoom:33%;"></p></li><li><p>Effective Java</p><p>这本书的英文第三版已经在国内上市，涵盖了 Java 7 到 Java 9 的各种新特性。严格来说，这本书不算是一本基础书籍，但当你有一定基础后，还是非常建议通读一下的。关于这本书的阅读，我的建议是边学习边回顾，在吸收书中的经验时，多去想想自己在实际应用中是如何处理的。虽然《Effective Java》的具体章节可能是从某个点出发，但可以说都是对 Java、JVM、面向对象等各种知识的综合运用，对于设计和实现高质量的代码很有帮助。</p><p><img src="https://static001.geekbang.org/resource/image/bf/06/bf6e3f87d162595ddaa5d0786c0ed806.jpg" alt="img"></p></li><li><p>Java 并发编程实战</p><p>作者全是响当当的人物，比如 Brian Goetz，我多次在专栏里引用他的观点，众多强力作者也保证了书的质量。抛开作者光环，这本书的内容全部建立在理论之上，先讲清道理再谈实践，可以真正让你知其然也知其所以然。这本书更加侧重并发编程中有哪些问题，如何来深刻地理解和定义问题，如何利用可靠的手段指导工程实践，并没有过分纠结于并发类库的源码层面。</p><p><img src="https://static001.geekbang.org/resource/image/04/3f/0432ac1e431256fb894144aa2e66b03f.jpg" alt="img"></p></li><li><p>深入理解 Java 虚拟机</p><p><img src="https://static001.geekbang.org/resource/image/98/5f/98d02b66e1d3fdf8cc1f7f7c6f974b5f.jpg" alt="img"></p></li><li><p>性能优化</p><p>性能优化，我推荐 Charlie Hunt 和 Binu John 所著的《Java 性能优化权威指南》（Java Performance），也是我上次在直播时向大家推荐的。Java 之父 James Gosling。</p><p><img src="https://static001.geekbang.org/resource/image/c9/10/c9fae97c8a4954cb91b59dc7e59ab710.jpg" alt="img"></p></li><li><p>Spring实战</p><p>可以说 Spring 等相关框架已经成为业务开发的事实标准，系统性地掌握 Spring 框架的设计和实践，是必需的技能之一。</p><p><img src="https://static001.geekbang.org/resource/image/75/61/7559562971dc2eadd8fd03f02980a461.jpg" alt="img"></p></li><li><p>Netty实战</p><p>Netty 在性能、可扩展性等方面的突出表现，已经得到充分验证，作为基础的通信框架，已经广泛应用在各种互联网架构、游戏等领域，甚至可以说，如果没有仔细分析过 Netty，对 NIO 等方面的理解很可能还在很肤浅的阶段。</p><p><img src="https://static001.geekbang.org/resource/image/f8/d9/f8b11bdcb1559e472b77e23fcf184dd9.jpg" alt="img"></p></li><li><p>Cloud Native Java</p><p>Java 应用程序架构处于飞快的演进之中，微服务等新的架构应用越来越广泛，即使未必是使用 Spring Boot、Spring Cloud 等框架，但是系统的学习其设计思想和实践技术，绝对是有必要的。当然如果你在实践中使用 Dubbo 等框架，也可以选择相关书籍。前沿领域的变化非常快，很多风靡一时的开源软件，在实践中逐渐被证明存在各种弊端，或者厂商停止维护。所以这部分的学习，我建议不要盲目追新，最好是关注于分布式设计中的问题和解决的思路，做到触类旁通，并且注重书籍之外的学习渠道。下面两本并不算是 Java 书籍，但 Java 程序员进阶少不了对互联网主流架构的学习，了解分布式架构、缓存、消息中间件等令人眼花缭乱的技术，对于有志于成为架构师的 Java 工程师来说非常有帮助。</p><p><img src="https://static001.geekbang.org/resource/image/d2/12/d286554382cbba791f85e667ea124e12.jpg" alt="img"></p></li><li><p>大型分布式网站架构设计与实践</p><p>这本书总结了作者在构建安全、可稳定性、高扩展性、高并发的分布式网站方面的心得。</p><p><img src="https://static001.geekbang.org/resource/image/4a/4f/4ab17456a34278a8ca18de54fea76f4f.jpg" alt="img"></p></li><li><p>深入分布式缓存：从原理到实战</p><p>这本书融合了原理、架构和一线互联网公司的案例实践，值得参考。</p><p><img src="https://static001.geekbang.org/resource/image/3d/b8/3d70890354f556d1b3acbc2f2fdd99b8.jpg" alt="img"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大四上學期的成績單&quot;&gt;&lt;a href=&quot;#大四上學期的成績單&quot; class=&quot;headerlink&quot; title=&quot;大四上學期的成績單&quot;&gt;&lt;/a&gt;大四上學期的成績單&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/17/M5
      
    
    </summary>
    
    
      <category term="TaiwanTech" scheme="http://yoursite.com/tags/TaiwanTech/"/>
    
  </entry>
  
  <entry>
    <title>Garbage Collection In JVM</title>
    <link href="http://yoursite.com/2020/02/15/Garbage-Collection-In-JVM/"/>
    <id>http://yoursite.com/2020/02/15/Garbage-Collection-In-JVM/</id>
    <published>2020-02-14T17:52:18.000Z</published>
    <updated>2020-02-28T18:02:57.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么我们要了解JVM"><a href="#为什么我们要了解JVM" class="headerlink" title="为什么我们要了解JVM"></a>为什么我们要了解JVM</h1><p><img src="https://i.loli.net/2020/02/29/HvzDCcBqPuLmiOR.jpg" alt="FULLGC.jpg"></p><p><img src="https://i.loli.net/2020/02/26/rY2Q6bXhUDLNSkR.png" alt="JVM.png"></p><h4 id="私有线程区域："><a href="#私有线程区域：" class="headerlink" title="私有线程区域："></a>私有线程区域：</h4><ul><li>栈：函数当前运行过程中的一些函数变量。存对象的引用类型和地址</li><li>本地方法栈：存放C++运行时的native栈。</li><li>程序计数器：指向当前程序运行的位置。<h4 id="线程共享区域："><a href="#线程共享区域：" class="headerlink" title="线程共享区域："></a>线程共享区域：</h4></li><li>堆：存对象(最终)，老年代。</li><li>方法区：存储元数据信息，在JDK1.7前作永久代，1.8以后改为元数据空间，存储静态变量和常量、类加载器。</li></ul><p>Java的基础数据和指针都是值类型，所以直接存到内存里面去，不是去存地址寻址。</p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><ul><li>GC Root本地方法栈,方法区,栈不能被删除<blockquote><p>删除方法</p><ul><li><strong>标记清理</strong>，==会产生内存碎片==。</li><li><strong>标记整理</strong>(删了后面的顶上来，减少内存碎片)，==前移空间移动代价太大==。</li><li><strong>复制算法</strong>(分为两个区)，不直接删除，不被删除的复制到新区，==需要2倍的内存==。</li></ul></blockquote></li></ul><h3 id="实际："><a href="#实际：" class="headerlink" title="实际："></a>实际：</h3><h5 id="Minor-GC当在-Eden-区分配内存不足时，则会发生-minorGC-，由于-Java-对象多数是朝生夕灭的特性，所以-minorGC通常会比较频繁，效率也比较高。"><a href="#Minor-GC当在-Eden-区分配内存不足时，则会发生-minorGC-，由于-Java-对象多数是朝生夕灭的特性，所以-minorGC通常会比较频繁，效率也比较高。" class="headerlink" title="Minor GC当在 Eden 区分配内存不足时，则会发生 minorGC ，由于 Java 对象多数是朝生夕灭的特性，所以 minorGC通常会比较频繁，效率也比较高。"></a>Minor GC当在 Eden 区分配内存不足时，则会发生 minorGC ，由于 Java 对象多数是朝生夕灭的特性，所以 minorGC通常会比较频繁，效率也比较高。</h5><ul><li>年轻代：<strong>E区</strong>(伊甸园，满了触发YoungGC,用复制算法)，，<strong>两个Survive区</strong>(S0.S1) 8：1：1，两个S区交替工作（E+S1到S0,E+S0到S1）。每次Young GC完年龄会加一，满15岁就直接都去老年代区了。ParNew垃圾收集器(复制)。<h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5></li><li>老年代：只有一块，存满15岁到去老年代区的对象。和大对象，Old满了就和年轻的一起Full GC,发生STOPPED WORLD,整个Java程序直接暂停，就用标记清理或者标记整理。CMS垃圾收集器(标记清理)。</li></ul><p><strong>和GC Root无关的才能被删除</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么我们要了解JVM&quot;&gt;&lt;a href=&quot;#为什么我们要了解JVM&quot; class=&quot;headerlink&quot; title=&quot;为什么我们要了解JVM&quot;&gt;&lt;/a&gt;为什么我们要了解JVM&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Principle of JVM</title>
    <link href="http://yoursite.com/2020/02/08/Principle-of-JVM/"/>
    <id>http://yoursite.com/2020/02/08/Principle-of-JVM/</id>
    <published>2020-02-07T18:08:41.000Z</published>
    <updated>2020-02-17T10:19:31.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM原理速记复习Java虚拟机总结思维导图面试必备"><a href="#JVM原理速记复习Java虚拟机总结思维导图面试必备" class="headerlink" title="JVM原理速记复习Java虚拟机总结思维导图面试必备"></a>JVM原理速记复习Java虚拟机总结思维导图面试必备</h1><p><div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"></div></p><p><img src="https://images.cnblogs.com/cnblogs_com/neverth/1592425/o_191116143745Java%E8%99%9A%E6%8B%9F%E6%9C%BA-min.png" alt="JVM"><br><br></p><h1 id="java虚拟机">Java虚拟机</h1><br><h2 id="一运行时数据区域">一、运行时数据区域</h2><br><h3 id="线程私有">线程私有</h3><br><ul><br><li><p>程序计数器</p><br><ul><br><li>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是Native方法则为空），是唯一一个没有规定OOM（OutOfMemoryError）的区域。</li><br></ul></li><br><li><p>Java虚拟机栈</p><br><ul><br><li>每个Java方法在执行的同时会创建一个栈桢用于存储局部变量表、操作数栈、动态链接、方法出口等信息。从方法调用直到执行完成的过程，对应着一个栈桢在Java虚拟机栈中入栈和出栈的过程。（局部变量包含基本数据类型、对象引用reference和returnAddress类型）</li><br></ul></li><br><li><p>本地方法栈</p><br><ul><br><li>本地方法栈与Java虚拟机栈类似，它们之间的区别只不过是本地方法栈为Native方法服务。</li><br></ul></li><br></ul><br><h3 id="线程公有">线程公有</h3><br><ul><br><li><p>Java堆（GC区）（Java Head）</p><br><ul><br><li>几乎所有的对象实例都在这里分配内存，是垃圾收集器管理的主要区域。分为新生代和老年代。对于新生代又分为Eden空间、From Survivor空间、To Survivor空间。</li><br></ul></li><br><li><p>JDK1.7 方法区（永久代）</p><br><ul><br><li>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br><br>对这块区域进行垃圾回收的主要目的是对常量池的回收和对类的卸载，但是一般难以实现。<br><br>HotSpot虚拟机把它当做永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素的影响，并且每次Full GC之后永久代的大小都会改变，所以经常抛出OOM异常。<br><br>从JDK1.8开始，移除永久代，并把方法区移至元空间。</li><br><li><p>运行时常量池</p><br><ul><br><li>是方法区的一部分<br><br>Class文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。<br><br>允许动态生成，例如String类的intern()</li><br></ul></li><br></ul></li><br><li><p>JDK1.8 元空间</p><br><ul><br><li>原本存在方法区（永久代）的数据，一部分移到了Java堆里面，一部分移到了本地内存里面（即元空间）。元空间存储类的元信息，静态变量和常量池等放入堆中。</li><br></ul></li><br><li><p>直接内存</p><br><ul><br><li>在NIO中，会使用Native函数库直接分配堆外内存。</li><br></ul></li><br></ul><br><h2 id="二hotspot虚拟机">二、HotSpot虚拟机</h2><br><h3 id="对象的创建">对象的创建</h3><br><ul><br><li>当虚拟机遇到一条new指令时</li><br></ul><br><ol><br><li>检查参数能否在常量池中找到符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始过，没有的话先执行相应的类加载过程。</li><br><li>在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。</li><br><li>内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</li><br><li>对对象头进行必要的设置。</li><br><li>执行构造方法按照程序员的意愿进行初始化。</li><br></ol><br><h3 id="对象的内存布局">对象的内存布局</h3><br><ul><br><li><ol><br><li>对象头</li><br></ol><br><ul><br><li><ol><br><li>第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向实现戳等。</li><br></ol></li><br><li><ol><br><li>第二部分是类型指针，即对象指向它的类元数据的指针（如果使用直接对象指针访问），虚拟机通过这个指针来确定这个对象是哪个类的实例。</li><br></ol></li><br><li><ol><br><li>如果对象是一个Java数组的话，还需要第三部分记录数据长度的数据。</li><br></ol></li><br></ul></li><br><li><ol><br><li>实例数据</li><br></ol><br><ul><br><li>是对象真正存储的有效信息，也就是在代码中定义的各种类型的字段内容。</li><br></ul></li><br><li><ol><br><li>对齐填充</li><br></ol><br><ul><br><li>不是必然存在的，仅仅起着占位符的作用。<br><br>HotSpot需要对象的大小必须是8字节的整数倍。</li><br></ul></li><br></ul><br><h3 id="对象的访问定位">对象的访问定位</h3><br><ul><br><li><p>句柄访问</p><br><ul><br><li>在Java堆中划分出一块内存作为句柄池。<br><br>Java栈上的对象引用reference中存储的就是对象的句柄地址，而句柄中包含了到对象实例数据的指针和到对象类型数据的指针。<br><br>对象实例数据在Java堆中，对象类型数据在方法区（永久代）中。<br><br>优点：在对象被移动时只会改变句柄中的实例数据指针，而对象引用本身不需要修改。</li><br></ul></li><br><li><p>直接指针访问（HotSpot使用）</p><br><ul><br><li>Java栈上的对象引用reference中存储的就是对象的直接地址。<br><br>在堆中的对象实例数据就需要包含到对象类型数据的指针。<br><br>优点：节省了一次指针定位的时间开销，速度更快。</li><br></ul></li><br></ul><br><h2 id="三垃圾收集">三、垃圾收集</h2><br><h3 id="概述">概述</h3><br><ul><br><li>垃圾收集主要是针对Java堆和方法区。<br><br>程序计数器、Java虚拟机栈个本地方法栈三个区域属于线程私有，线程或方法结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</li><br></ul><br><h3 id="判断对象是否可以被回收">判断对象是否可以被回收</h3><br><ul><br><li><p>第一次标记（缓刑）</p><br><ul><br><li><p>引用计数算法</p><br><ul><br><li>给对象添加一个引用计数器，当对象增加一个引用时引用计数值++，引用失效时引用计数值–，引用计数值为0时对象可以被回收。</li><br></ul></li><br></ul></li><br></ul><br><p>但是它难以解决对象之间的相互循环引用的情况，此时这个两个对象引用计数值为1，但是永远无法用到这两个对象。</p><ul><li><p>可达性分析算法（Java使用）</p><ul><li>以一系列GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连是，则证明此对象不可用，可以被回收。<p>GC Roots对象包括</p><br><ol><br><li>虚拟机栈（栈桢中的本地变量表）中引用的对象。</li><br><li>方法区中共类静态属性引用的对象。</li><br><li>方法区中常量引用的对象。</li><br><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li><br></ol><br><ul><br><li><p>第二次标记</p><br><ul><br><li>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过。<br><br>如果对象在finalize方法中重新与引用链上的任何一个对象建立关联则将不会被回收。</li><br><li><p>finalize()</p><br><ul><br><li>任何一个对象的finalize()方法都只会被系统调用一次。<br><br>它的出现是一个妥协，运行代价高昂，不确定性大，无法保证各个对象的调用顺序。<br><br>finalize()能做的所有工作使用try-finally或者其他方式都可以做的更好，完全可以忘记在这个函数的存在。</li><br></ul></li><br></ul></li><br></ul><br><h3 id="方法区的回收">方法区的回收</h3><br><ul><br><li>在方法区进行垃圾回收的性价比一般比较低。<br><br>主要回收两部分，废弃常量和无用的类。</li><br></ul><br><p>满足无用的类三个判断条件才仅仅代表可以进行回收，不是必然关系，可以使用-Xnoclassgc参数控制。</p><br><ol><br><li>该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><br><li>加载该类的ClassLoader已经被回收。</li><br><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问到该类的方法。</li><br></ol><br><h3 id="引用类型">引用类型</h3><br><ul><br><li><ol><br><li>强引用</li><br></ol><br><ul><br><li>使用new一个新对象的方式来创建强引用。<br><br>只要强引用还存在，被引用的对象则永远不会被回收。</li><br></ul></li><br><li><ol><br><li>软引用</li><br></ol><br><ul><br><li>使用SoftReference类来实现软引用。<br><br>用来描述一些还有用但是并非必须的对象，被引用的对象在将要发生内存溢出异常之前会被回收。</li><br></ul></li><br><li><ol><br><li>弱引用</li><br></ol><br><ul><br><li>使用WeakReference类来实现弱引用。<br><br>强度比软引用更弱一些，被引用的对象在下一次垃圾收集时会被回收。</li><br></ul></li><br><li><ol><br><li>虚引用</li><br></ol><br><ul><br><li>使用PhantomReference类来实现虚引用。<br><br>最弱的引用关系，不会对被引用的对象生存时间构成影响，也无法通过虚引用来取得一个对象实例。<br><br>唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li><br></ul></li><br></ul><br><h3 id="垃圾收集算法">垃圾收集算法</h3><br><ul><br><li><ol><br><li>标记 - 清除</li><br></ol><br><ul><br><li>首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象并取消标记。</li><br></ul></li><br></ul><br><p>不足：</p><br><ol><br><li>效率问题，标记和清除两个过程的效率都不高。</li><br><li>空间问题，标记清除之后会产生大量不连续的内存碎片，没有连续内存容纳较大对象而不得不提前触发另一次垃圾收集。</li><br></ol><br><ul><br><li><ol><br><li>标记 - 整理</li><br></ol><br><ul><br><li>和标记 - 清除算法一样，但标记之后让所有存活对象都向一段移动，然后直接清理掉端边界以外的内存。<br><br>解决了标记 - 清除算法的空间问题，但需要移动大量对象，还是存在效率问题。</li><br></ul></li><br><li><ol><br><li>复制</li><br></ol><br><ul><br><li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用多的内存空间一次清理掉。<br><br>代价是将内存缩小为原来的一般，太高了。</li><br></ul></li><br></ul><br><p>现在商业虚拟机都采用这种算法用于新生代。<br><br>因为新生代中的对象98%都是朝生暮死，所以将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间。<br><br>当回收时，如果另外一块Survivor空间没有足够的空间存放存活下来的对象时，这些对象将直接通过分配担保机制进入老年代。</p><br><ul><br><li><ol><br><li>分代收集</li><br></ol><br><ul><br><li>一般把Java堆分为新生代和老年代。<br><br>在新生代中使用复制算法，在老年代中使用标记 -清除 或者 标记 - 整理 算法来进行回收。</li><br></ul></li><br></ul><br><h3 id="hotspot的算法实现">HotSpot的算法实现</h3><br><ul><br><li><p>枚举根节点（GC Roots）</p><br><ul><br><li>目前主流Java虚拟机使用的都是准确式GC。<br><br>GC停顿的时候，虚拟机可以通过OopMap数据结构（映射表）知道，在对象内的什么偏移量上是什么类型的数据，而且特定的位置记录着栈和寄存器中哪些位置是引用。因此可以快速且准确的完成GC Roots枚举。</li><br></ul></li><br><li><p>安全点</p><br><ul><br><li>为了节省GC的空间成本，并不会为每条指令都生成OopMap，只是在“特定的位置”记录OopMap，这些位置称为安全点。</li><br></ul></li><br></ul><br><p>程序执行只有到达安全点时才能暂停，到达安全点有两种方案。</p><br><ol><br><li>抢断式中断（几乎不使用）。GC时，先把所有线程中断，如果有线程不在安全点，就恢复该线程，让他跑到安全点。</li><br><li>主动式中断（主要使用）。GC时，设置一个标志，各个线程执行到安全点时轮询这个标志，发现标志为直则挂起线程。</li><br></ol><br><p>但是当线程sleep或blocked时无法响应JVM的中断请求走到安全点中断挂起，所以引出安全区域。</p><br><ul><br><li><p>安全区域</p><br><ul><br><li>安全区域是指在一段代码片段之中，引用关系不会发生变化，是扩展的安全点。</li><br></ul></li><br></ul><br><p>线程进入安全区域时表示自己进入了安全区域，这个发生GC时，JVM就不需要管这个线程。<br><br>线程离开安全区域时，检查系统是否完成GC过程，没有就等待可以离开安全区域的信号为止，否者继续执行。</p><br><h3 id="垃圾收集器">垃圾收集器</h3><br><ul><br><li><p>新生代</p><br><ul><br><li><ol><br><li>serial收集器</li><br></ol><br><ul><br><li>它是单线程收集器，只会使用一个线程进行垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程。</li><br></ul></li><br></ul></li><br></ul><br><p>优点：对比其他单线程收集器简单高效，对于单个CPU环境来说，没有线程交互的开销，因此拥有最高的单线程收集效率。</p><br><p>它是Client场景下默认新生代收集器，因为在该场景下内存一般来说不会很大。</p></li><li><ol start="2"><li>parnew收集器</li></ol></li><li><p>它是Serial收集器的多线程版本，公用了相当多的代码。</p><p>在单CPU环境中绝对不会有比Serial收集器更好的效果，甚至在2个CPU环境中也不能百分之百超越。</p><br><p>它是Server场景下默认的新生代收集器，主要因为除了Serial收集器，只用它能与CMS收集器配合使用。</p></li><li><ol start="3"><li>parallel scavenge收集器</li></ol></li><li><p>“吞吐优先”收集器，与ParNew收集器差不多。</p><p>但是其他收集器的目标是尽可能缩短垃圾收集时用户线程停顿的时间，而它的目标是达到一个可控制的吞吐量。这里的吞吐量指CPU用于运行用户程序的时间占总时间的比值。</p><br><ul><br><li><p>老年代</p><br><ul><br><li><ol><br><li>serial old收集器</li><br></ol><br><ul><br><li>是Serial收集器老年代版本。</li><br></ul></li><br></ul></li><br></ul><br><p>也是给Client场景下的虚拟机使用的。</p></li><li><ol start="5"><li>parallel old收集器</li></ol></li><li><p>是Parallel Scavenge收集器的老年代版本。</p><p>在注重吞吐量已经CPU资源敏感的场合，都可以优先考虑Parallel Scavenge和Parallel Old收集器。</p></li><li><ol start="6"><li>cms收集器</li></ol></li><li><p>Concurrent Mark Sweep收集器是一种以获取最短回收停顿时间为目标的收集器。</p></li><li><p>运作过程</p><ul><li><ol><li>初始标记（最短）。仍需要暂停用户线程。只是标记一下GC Roots能直接关联到的对象，速度很快<br><ol><br><li>并发标记（耗时最长）。进行GC Roots Tracing（根搜索算法）的过程。</li><br><li>重新标记。修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比初始标记长但远小于并发标记时间。</li><br><li>并发清除</li><br></ol><p>1 和4 两个步骤并没有带上并发两个字，即这两个步骤仍要暂停用户线程。</p></li></ol></li></ul></li><li><p>优缺点</p><ul><li>并发收集、低停顿。<br><ol><br><li>CMS收集器对CPU资源非常敏感。虽然不会导致用户线程停顿，但是占用CPU资源会使应用程序变慢。</li><br><li>无法处理浮动垃圾。在并发清除阶段新垃圾还会不断的产生，所以GC时要控制“-XX:CMSinitiatingOccupancyFraction参数”预留足够的内存空间给这些垃圾，当预留内存无法满足程序需要时就会出现”Concurrent Mode Failure“失败，临时启动Serial Old收集。</li><br><li>由于使用标记 - 清除算法，收集之后会产生大量空间碎片。</li><br></ol><br><ul><br><li><ol><br><li>g1收集器</li><br></ol><br><ul><br><li>Garbage First是一款面向服务端应用的垃圾收集器</li><br><li><p>运作过程</p><br><ul><br><li><ol><br><li>初始标记</li><br></ol></li><br></ul></li><br></ul></li><br></ul><br><ol><br><li>并发标记</li><br><li>最终标记</li><br><li>删选标记</li><br></ol><br><h2 id="五类加载机制">五、类加载机制</h2><br><h3 id="概述-1">概述</h3><br><ul><br><li>虚拟机把描述类的数据从Class问价加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。<br><br>Java应用程序的高度灵活性就是依赖运行期动态加载和动态连接实现的。</li><br></ul><br><h3 id="类的生命周期">类的生命周期</h3><br><ul><br><li>加载 -&gt; 连接（验证 -&gt; 准备 -&gt; 解析） -&gt; 初始化 -&gt; 使用 - &gt;卸载</li><br></ul><br><h3 id="类初始化时机">类初始化时机</h3><br><ul><br><li><p>主动引用</p><br><ul><br><li>虚拟机规范中没有强制约束何时进行加载，但是规定了有且只有五种情况必须对类进行初始化（加载、验证、准备都会随之发生）</li><br></ul></li><br></ul><br><ol><br><li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时没有初始化。</li><br><li>反射调用时没有初始化。</li><br><li>发现其父类没有初始化则先触发其父类的初始化。</li><br><li>包含psvm（mian（）方法）的那个类。</li><br><li>动态语言支持时，REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄。</li><br></ol><br><ul><br><li><p>被动引用</p><br><ul><br><li>除上面五种情况之外，所有引用类的方式都不会触发初始化，称为被动引用。</li><br></ul></li><br></ul><br><ol><br><li>通过子类引用父类的静态字段，不会导致子类的初始化。</li><br><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承Object的子类，其中包含数组的属性和方法，用户只能使用public的length和clone()。</li><br><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li><br></ol><br><h3 id="类加载过程">类加载过程</h3><br><ul><br><li><ol><br><li>加载</li><br></ol><br><ul><br><li><ol><br><li>通过类的全限定名来获取定义此类的二进制字节流。</li><br></ol></li><br></ul></li><br></ul><br><ol><br><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><br><li>在内存中生成一个代表这个类的java.lang.Class对象（HotSpot将其存放在方法区中），作为方法区这个类的各种数据的访问入口。</li><br></ol><br><ul><br><li><ol><br><li>验证</li><br></ol><br><ul><br><li>为了确保Class文件的字节类中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。可以通过-Xverify:none关闭大部分类验证。</li><br></ul></li><br></ul><br><ol><br><li>文件格式验证。确保输入字节流能正确的解析并存储于方法区，后面的3个验证全部基于方法区的存储结构进行，不会再操作字节流。</li><br><li>元数据验证。对字节码描述信息进行语义分析，确保其符合Java语法规范。（Java语法验证）</li><br><li>字节码验证。最复杂，通过数据流和控制流分析，确定程序语义时合法的、符合逻辑的。可以通过参数关闭。（验证指令跳转范围，类型转换有效等）</li><br><li>符号引用验证。将符号引用转化为直接引用，发生在第三个阶段——解析阶段中发生。</li><br></ol><br><ul><br><li><ol><br><li>准备</li><br></ol><br><ul><br><li>类变量是被static修饰的变量，准备阶段为类变量分配内存并设置零值（final直接设置初始值），使用的是方法区的内存。</li><br></ul></li><br><li><ol><br><li>解析</li><br></ol><br><ul><br><li>将常量池内的符号引用替换为直接引用的过程。<br><br>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的动态绑定。<br><br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、和调用点限定符。</li><br></ul></li><br><li><ol><br><li>初始化</li><br></ol><br><ul><br><li><p>初始化阶段才真正执行类中定义的Java程序代码，是执行类构造器<clinit>()方法的过程。<br><br>在准备阶段，类变量已经给过零值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。</clinit></p><br><ul><br><li><p><clinit>()</clinit></p><br><ul><br><li>类构造器方法。是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的的语句合并产生的。</li><br></ul></li><br></ul></li><br></ul></li><br></ul><br><ol><br><li>不需要显式调用父类构造器，JVM会保证在子类clinit执行之前，父类的clinit已经执行完成。</li><br><li>接口中不能使用静态语句块但仍可以有类变量的赋值操作。当没有使用父接口中定义的变量时子接口的c</li></ol></li></ul></li></ul></li></ul><p><li>接口中不能使用静态语句块但仍可以有类变量的赋值操作。当没有使用父接口中定义的变量时子接口的clinit不需要先执行父接口的clinit方法。接口的实现类也不会执行接口的clinit方法。</li></p><p><li><p>虚拟机会保证clinit在多线程环境中被正确的加锁、同步。其他线性唤醒之后不会再进入clinit方法，同一个类加载器下，一个类型只会初始化一次。</p></li></p><ul><li><p>&lt;init&gt;()</p><ul><li>对象构造器方法。Java对象被创建时才会进行实例化操作，对非静态变量解析初始化。</li><br><li><p>会显式的调用父类的init方法，对象实例化过程中对实例域的初始化操作全部在init方法中进行。</p></li><br><br><h3 id="类加载-器">类（加载） 器</h3><ul><br><li><p>类与类加载器</p><br><ul><br><li>类加载器实现类的加载动作。<br><br>类加载器和这个类本身一同确立这个类的唯一性，每个类加载器都有独立的类命名空间。在同一个类加载器加载的情况下才会有两个类相等。<br><br>相等包括类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()、instanceof关键字。</li><br></ul></li><br><li><p>类加载器分类</p><br><ul><br><li><p>启动类加载器</p><br><ul><br><li>由C++语言实现，是虚拟机的一部分。负责将JAVA_HOME/lib目录中，或者被-Xbootclasspath参数指定的路径，但是文件名要能被虚拟机识别，名字不符合无法被启动类加载器加载。启动类加载器无法被Java程序直接引用。</li><br></ul></li><br><li><p>扩展类加载器</p><br><ul><br><li>由Java语言实现，负责加载JAVA_HOME/lib/ext目录，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li><br></ul></li><br><li><p>应用程序类加载器</p><br><ul><br><li>由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称他为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，一般情况下这个就是程序中默认的类加载器。</li><br></ul></li><br><li><p>自定义类加载器</p><br><ul><br><li>由用户自己实现。</li><br></ul></li><br></ul></li><br></ul><br><ol><br><li>如果不想打破双亲委派模型，那么只需要重写findClass方法即可。</li><br><li>否则就重写整个loadClass方法。</li><br></ol><br><ul><br><li><p>双亲委派模型</p><br><ul><br><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。父子不会以继承的关系类实现，而是都是使用组合关系来服用父加载器的代码。<br><br>在java.lang.ClassLoader的loadClass()方法中实现。</li><br><li><p>工作过程</p><br><ul><br><li>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成（它的搜索范围中没有找到所需要的类）时才尝试自己加载</li><br></ul></li><br><li><p>好处</p><br><ul><br><li>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，从而使得基础类库得到同意。</li><br></ul></li><br></ul></li><br></ul><br><h2 id="四内存分配与回收策略">四、内存分配与回收策略</h2><br><h3 id="minor-gc-和-full-gc">Minor GC 和 Full GC</h3><br><ul><br><li><p>Minor GC</p><br><ul><br><li>发生在新生代的垃圾收集动作，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行速度快。</li><br><li><p>时机</p><br><ul><br><li>Eden不足</li><br></ul></li><br></ul></li><br><li><p>Full GC</p><br><ul><br><li>发生在老年区的GC，出现Full GC时往往伴随着Minor GC，比Minor GC慢10倍以上。</li><br><li><p>时机</p><br><ul><br><li><ol><br><li>调用System.gc()</li><br></ol><br><ul><br><li>只是建议虚拟机执行Full GC，但是虚拟机不一定真正去执行。<br><br>不建议使用这种方式，而是让虚拟机管理内存。</li><br></ul></li><br><li><ol><br><li>老年代空间不足</li><br></ol><br><ul><br><li>常见场景就是大对象和长期存活对象进入老年代。<br><br>尽量避免创建过大的对象以及数组，调大新生代大小，让对象尽量咋新生代中被回收，不进入老年代。</li><br></ul></li><br><li><ol><br><li>JDK1.7 之前方法区空间不足</li><br></ol><br><ul><br><li>当系统中要加载的类、反射的类和常量较多时，永久代可能会被占满，在未配置CMS GC的情况下也会执行Full GC，如果空间仍然不够则会抛出OOM异常。<br><br>可采用增大方法区空间或转为使用CMS GC。</li><br></ul></li><br><li><ol><br><li>空间分配担保失败</li><br></ol><br><ul><br><li>发生Minor GC时分配担保的两个判断失败</li><br></ul></li><br><li><ol><br><li>Concurrent Mode Failure</li><br></ol><br><ul><br><li>CMS GC 并发清理阶段用户线程还在执行，不断有新的浮动垃圾产生，当预留空间不足时报Concurrent Mode Failure错误并触发Full GC。</li><br></ul></li><br></ul></li><br></ul></li><br></ul><br><h3 id="内存分配策略">内存分配策略</h3><br><ul><br><li><ol><br><li>对象优先在Eden分配</li><br></ol><br><ul><br><li>大多数情况下，对象在新生代Eden上分配，当Eden空间不够时，发起Minor GC，当另外一个Survivor空间不足时则将存活对象通过分配担保机制提前转移到老年代。</li><br></ul></li><br><li><ol><br><li>大对象直接进入老年代</li><br></ol><br><ul><br><li>配置参数-XX:PretenureSizeThreshold，大于此值得对象直接在老年代分配，避免在Eden和Survivor之间的大量内存复制。</li><br></ul></li><br><li><ol><br><li>长期存活对象进入老年代</li><br></ol><br><ul><br><li>虚拟机为每个对象定义了一个Age计数器，对象在Eden出生并经过Minor GC存活转移到另一个Survivor空间中时Age++，增加到默认16则转移到老年代。</li><br></ul></li><br><li><ol><br><li>动态对象年龄绑定</li><br></ol><br><ul><br><li>虚拟机并不是永远要求对象的年龄必须到达MaxTenuringThreshold才能晋升老年代，如果在Survivor中相同年龄所有对象大小总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。</li><br></ul></li><br><li><ol><br><li>空间分配担保</li><br></ol><br><ul><br><li>在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代的所有对象，如果条件成立，那么Minor GC可以认为是安全的。<br><br>可以通过HandlePromotionFailure参数设置允许冒险，此时虚拟机将与历代晋升到老年区对象的平均大小比较，仍小于则要进行一次Full GC。<br><br>在JDK1.6.24之后HandlePromotionFailure已无作用，即虚拟机默认为true。</li><br></ul></li><br></ul></ul></li></ul>]]></content>
    
    <summary type="html">
    
      JVM原理速记复习Java虚拟机总结思维导图面试必备
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Everything about ArrayList</title>
    <link href="http://yoursite.com/2020/02/08/Everything-about-ArrayList/"/>
    <id>http://yoursite.com/2020/02/08/Everything-about-ArrayList/</id>
    <published>2020-02-07T16:53:26.000Z</published>
    <updated>2020-03-21T06:09:41.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-ArrayList底层实现原理源码详细分析Jdk8"><a href="#Java-ArrayList底层实现原理源码详细分析Jdk8" class="headerlink" title="Java ArrayList底层实现原理源码详细分析Jdk8"></a>Java ArrayList底层实现原理源码详细分析Jdk8</h1><p><li>ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。</li></p><p><li><strong>ArrayList不是线程安全的</strong>，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。</li></p><p><li>ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。</li><br></p><h4 id="存储结构">存储结构</h4><br><pre class="java"><code>// 当前数据对象存放地方，当前对象不参与序列化<br>// 这个关键字最主要的作用就是当序列化时，被transient修饰的内容将不会被序列化<br>transient Object[] elementData;</code></pre><br><ul><br><li><p>Object类型数组。</p><br><h4 id="数据域">数据域</h4></li><br></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化ID</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">  <span class="comment">// 默认初始容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 一个空数组，方便使用，主要用于带参构造函数初始化和读取序列化对象等。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 和官方文档写的一样，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和EMPTY_ELEMENTDATA 的区别</span></span><br><span class="line"><span class="comment">   * 仅仅是为了区别用户带参为0的构造和默认构造的惰性初始模式对象。</span></span><br><span class="line"><span class="comment">   * 当用户带参为0的构造，第一次add时，数组容量grow到1。</span></span><br><span class="line"><span class="comment">   * 当用户使用默认构造时，第一次add时，容量直接grow到DEFAULT_CAPACITY（10）。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前数据对象存放地方，当前对象不参与序列化</span></span><br><span class="line">  <span class="comment">// 这个关键字最主要的作用就是当序列化时，被transient修饰的内容将不会被序列化</span></span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">  <span class="comment">// 当前数组中元素的个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// 数组最大可分配容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">  <span class="comment">// 集合数组修改次数的标识（由AbstractList继承下来）（fail-fast机制）</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>ArrayList的无参构造函数。<strong>初始化的时候并没有真正的创建10个空间，这是惰性初始模式对象。</strong></li><br><li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和EMPTY_ELEMENTDATA 的区别仅仅是为了区别用户带参为0的构造和默认构造的惰性初始模式对象。</li><br><li>modCount用来记录ArrayList结构发生变化的次数。用于<a href="#q1">Fail-Fast机制</a></li><br></ul><br><br><h4 id="构造函数">构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 只有这个地方会引用DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">     <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 使用 EMPTY_ELEMENTDATA，在其他的多个地方可能会引用EMPTY_ELEMENTDATA</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(&amp;quot;Illegal Capacity: &amp;quot;+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&amp;lt;? extends E&amp;gt; c)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 把传入集合传化成[]数组并浅拷贝给elementData</span></span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="comment">// 转化后的数组长度赋给当前ArrayList的size,并判断是否为0</span></span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//c.toArray可能不会返回 Object[]，可以查看 java 官方编号为 6260652 的 bug</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             <span class="comment">// 若 c.toArray() 返回的数组类型不是 Object[]，则利用 Arrays.copyOf(); 来构造一个大小为 size 的 Object[] 数组</span></span><br><span class="line">             <span class="comment">// 此时elementData是指向传入集合的内存，还需要创建新的内存区域深拷贝给elementData</span></span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 传入数组size为零替换空数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><br><li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和EMPTY_ELEMENTDATA 的区别仅仅是为了区别用户带参为0的构造和默认构造的惰性初始模式对象。</li><br><li>注意<strong>深拷贝和浅拷贝</strong>。</li><br><li><p>带参为0的构造会惰性初始化，不为0的构造则不会惰性初始化。</p><br><h4 id="add源码解析">add()源码解析</h4></li><br></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确保数组已使用长度（size）加1之后足够存下 下一个数据</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">// 数组的下一个index存放传入元素。</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="comment">// 始终返回true。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里就是DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和</span></span><br><span class="line">        <span class="comment">// EMPTY_ELEMENTDATA 最主要的区别。</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">// 默认构造第一次add返回10。</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 带参为0构造第一次add返回 1 （0 + 1）。</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自增修改计数</span></span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">// 当前数组容量小于需要的最小容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &amp;gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 准备扩容数组</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">// 获得当前数组容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">// 新数组容量为1.5倍的旧数组容量</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &amp;lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 若 newCapacity 依旧小于 minCapacity</span></span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">            <span class="comment">// 判断是需要的容量是否超过最大的数组容量。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &amp;gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        <span class="comment">// 在Arrays.copyOf()中会将原数组整个赋值到扩容的数组中。</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>扩容操作需要调用Arrays.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建ArrayList对象时就指定大概的容量大小，减少扩容操作的次数。</li><br></ul><br><h4 id="addint-index-e-element源码分析">add(int index, E element)源码分析</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个本地方法，由C语言实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  // 源数组</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span>  srcPos, // 源数组要复制的起始位置</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, // 目标数组（将原数组复制到目标数组）</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> destPos, // 目标数组起始位置（从目标数组的哪个下标开始复制操作）</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length   // 复制源数组的长度</span></span></span><br><span class="line"><span class="function"><span class="params">                                    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断索引是否越界</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">// 确保数组已使用长度（size）加1之后足够存下 下一个数据</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">// 运行到这里代表数组容量满足。</span></span><br><span class="line">        <span class="comment">// 数组从传入形参index处开始复制，复制size-index个元素（即包括index在内后面的元素全部复制），</span></span><br><span class="line">        <span class="comment">// 从数组的index + 1处开始粘贴。</span></span><br><span class="line">        <span class="comment">// 这时，index 和 index + 1处元素数值相同。</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        <span class="comment">// 把index处的元素替换成新的元素。</span></span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">// 数组内元素长度加一。</span></span><br><span class="line">        size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>需要调用System.arraycopy()将包括index在内后面的元素都复制到index + 1位置上，该操作的时间复杂度为O(N)，可以看出ArrayList数组头增加元素的代价是非常高的。</li><br></ul><br><h4 id="removeint-index源码分析">remove(int index)源码分析</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查index</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &amp;gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 和 add(int index, E element)原理想通。</span></span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        <span class="comment">// 引用计数为0，会自动进行垃圾回收。</span></span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="comment">// 返回旧元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>需要调用System.arraycopy()将包括index + 1在内后面的元素都复制到index位置上，该操作的时间复杂度为O(N)，可以看出ArrayList数组头增加元素的代价是非常高的。</li><br></ul><br><h4 id="q1">Fail-Fast机制</h4><br><p>fail-fast 机制，即快速失败机制，是java集合(Collection)中的一种错误检测机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出ConcurrentModificationException异常。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。</p><br><ul><br><li>结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组大小，仅仅只是设置元素的值不算结构发生变化。</li><br><li>在进行序列化或者迭代操作时，需要比较操作前后modCount是否改变，如果改变了需要跑出ConcurrentModificationException</li><br></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&amp;<span class="title">lt</span></span>;E&amp;gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;</span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 期待的修改值等于当前修改次数（modCount）</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 检查 expectedModCount是否等于modCount，不相同则抛出ConcurrentModificationException</span></span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">/** 省略此处代码 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lastRet &amp;lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">/** 省略此处代码 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount == <span class="keyword">this</span>.expectedModCount)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><p>一个单线程环境下的fail-fast的例子</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&amp;lt;String&amp;gt; list = <span class="keyword">new</span> ArrayList&amp;lt;&amp;gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &amp;lt; <span class="number">10</span> ; i++ ) &#123;</span><br><span class="line">            list.add(i + &amp;quot;&amp;quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       Iterator&amp;lt;String&amp;gt; iterator = list.iterator();</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                 list.remove(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            i ++;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><br><h4 id="序列化">序列化</h4><br><p>ArrayList 实现了 java.io.Serializable 接口，但是自己定义了序列化和反序列化。因为ArrayList基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没有<strong>必要全部进行序列化</strong>。因此 elementData 数组使用 transient 修饰，可以防止被自动序列化。</p><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">        <span class="comment">// 将当前类的非静态(non-static)和非瞬态(non-transient)字段写入流</span></span><br><span class="line">        <span class="comment">// 在这里也会将size字段写入。</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">        <span class="comment">// 序列化数组包含元素数量，为了向后兼容</span></span><br><span class="line">        <span class="comment">// 两次将size写入流</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="comment">// 按照顺序写入，只写入到数组包含元素的结尾，并不会把数组的所有容量区域全部写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;size; i++) &#123;</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否触发Fast-Fail</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置数组引用空数组。</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        <span class="comment">// 将流中的的非静态(non-static)和非瞬态(non-transient)字段读取到当前类</span></span><br><span class="line">        <span class="comment">// 包含 size</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        <span class="comment">// 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            <span class="comment">// 根据size计算容量。</span></span><br><span class="line">            <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">            <span class="comment">// SharedSecrets 一个“共享机密”存储库，它是一种机制，</span></span><br><span class="line">            <span class="comment">// 用于调用另一个包中的实现专用方法，而不使用反射。TODO</span></span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">            <span class="comment">// 检查是否需要扩容</span></span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="comment">// 依次读取元素到数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><p>ArrayList中为什么size要序列化两次？</p><br><blockquote><br><p>在代码中s.defaultWriteObject();中size应该也被序列化了，为什么下边还要再单独序列化一次呢？<br><br>这样写是出于兼容性考虑。<br><br>旧版本的JDK中，ArrayList的实现有所不同，会对length字段进行序列化。<br><br>而新版的JDK中，对优化了ArrayList的实现，不再序列化length字段。<br><br>这个时候，如果去掉s.writeInt(size)，那么新版本JDK序列化的对象，在旧版本中就无法正确读取，<br><br>因为缺少了length字段。<br><br>因此这种写法看起来多此一举，实际上却保证了兼容性。</p><br></blockquote><br><br>### 小结<br><ul><br><li>ArrayList基于数组方式实现，无容量的限制（会扩容）</li><br><li>添加元素时可能要扩容（所以最好预判一下），删除元素时不会减少容量（若希望减少容量可以使用trimToSize()），删除元素时，将删除掉的位置元素置为null，下次gc就会回收这些元素所占的内存空间。</li><br><li>线程不安全</li><br><li>add(int index, E element)：添加元素到数组中指定位置的时候，需要将该位置及其后边所有的元素都整块向后复制一位</li><br><li>get(int index)：获取指定位置上的元素时，可以通过索引直接获取（O(1)）</li><br><li>remove(Object o)需要遍历数组</li><br><li>remove(int index)不需要遍历数组，只需判断index是否符合条件即可，效率比remove(Object o)高</li><br><li>contains(E)需要遍历数组</li><br></ul><p><a href="https://www.cnblogs.com/renjiaqi/p/10403725.html" target="_blank" rel="noopener">面试必会之ArrayList源码分析&amp;手写ArrayList</a></p>]]></content>
    
    <summary type="html">
    
      Java ArrayList底层实现原理源码详细分析Jdk8
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>The data structure and algorithm behind the MySQL index</title>
    <link href="http://yoursite.com/2020/02/05/The-data-structure-and-algorithm-behind-the-MySQL-index/"/>
    <id>http://yoursite.com/2020/02/05/The-data-structure-and-algorithm-behind-the-MySQL-index/</id>
    <published>2020-02-05T15:14:29.000Z</published>
    <updated>2020-02-27T09:15:26.658Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>文章主要内容分为三个部分。</p><p></p><p></p><p>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。</p><p></p><p></p><p>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</p><p></p><p></p><p>第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。<br><a id="more"></a><br></p><p></p><p></p><h1><a name="nav-2"></a>数据结构及算法基础</h1><p></p><p></p><h2><a name="nav-2-1"></a>索引的本质</h2><p></p><p></p><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p></p><p></p><p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是<a href="http://en.wikipedia.org/wiki/Linear_search" target="_blank">顺序查找</a>（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm" target="_blank">二分查找</a>（binary search）、<a href="http://en.wikipedia.org/wiki/Binary_search_tree" target="_blank">二叉树查找</a>（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于<a href="http://en.wikipedia.org/wiki/Binary_search_tree" target="_blank">二叉查找树</a>上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p></p><p></p><p>看一个例子：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/1.png"></p><p></p><p></p><p align="center">图1</p><p></p><p></p><p>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在(O(log_2n))的复杂度内获取到相应数据。</p><p></p><p></p><p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种<a href="http://en.wikipedia.org/wiki/Red-black_tree" target="_blank">红黑树</a>（red-black tree）实现的，原因会在下文介绍。</p><p></p><p></p><h2><a name="nav-2-2"></a>B-Tree和B+Tree</h2><p></p><p></p><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p><p></p><p></p><h3>B-Tree</h3><p></p><p></p><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p><p></p><p></p><p>d为大于1的一个正整数，称为B-Tree的度。</p><p></p><p></p><p>h为一个正整数，称为B-Tree的高度。</p><p></p><p></p><p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p><p></p><p></p><p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p><p></p><p></p><p>所有叶节点具有相同的深度，等于树高h。</p><p></p><p></p><p>key和指针互相间隔，节点两端是指针。</p><p></p><p></p><p>一个节点中的key从左到右非递减排列。</p><p></p><p></p><p>所有节点组成树结构。</p><p></p><p></p><p>每个指针要么为null，要么指向另外一个节点。</p><p></p><p></p><p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于(v(key_1))，其中(v(key_1))为node的第一个key的值。</p><p></p><p></p><p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于(v(key_m))，其中(v(key_m))为node的最后一个key的值。</p><p></p><p></p><p>如果某个指针在节点node的左右相邻key分别是(key_i)和(key_{i+1})且不为null，则其指向节点的所有key小于(v(key_{i+1}))且大于(v(key_i))。</p><p></p><p></p><p>图2是一个d=2的B-Tree示意图。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/2.png"></p><p></p><p></p><p align="center">图2</p><p></p><p></p><p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre <span class="class"><span class="keyword">class</span></span>=<span class="string">"prettyprint linenums"</span>&gt;BTree_Search(node, key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    foreach(node.key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.key[i] == key) <span class="keyword">return</span> node.data[i];</span><br><span class="line">            <span class="keyword">if</span>(node.key[i] &amp;gt; key) <span class="keyword">return</span> BTree_Search(point[i]-&amp;gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BTree_Search(point[i+<span class="number">1</span>]-&amp;gt;node);</span><br><span class="line">&#125;</span><br><span class="line">data = BTree_Search(root, my_key);&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p></p><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为(log_d((N+1)/2))，检索一个key，其查找节点个数的渐进复杂度为(O(log_dN))。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><p></p><p></p><p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p><p></p><p></p><h3>B+Tree</h3><p></p><p></p><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p><p></p><p></p><p>与B-Tree相比，B+Tree有以下不同点：</p><p></p><p></p><p>每个节点的指针上限为2d而不是2d+1。</p><p></p><p></p><p>内节点不存储data，只存储key；叶子节点不存储指针。</p><p></p><p></p><p>图3是一个简单的B+Tree示意。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/3.png"></p><p></p><p></p><p align="center">图3</p><p></p><p></p><p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p><p></p><p></p><p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p><p></p><p></p><h3>带有顺序访问指针的B+Tree</h3><p></p><p></p><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/4.png"></p><p></p><p></p><p align="center">图4</p><p></p><p></p><p>如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><p></p><p></p><p>这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p><p></p><p></p><h2><a name="nav-2-3"></a>为什么使用B-Tree（B+Tree）</h2><p></p><p></p><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p><p></p><p></p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><p></p><p></p><h3>主存存取原理</h3><p></p><p></p><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/5.png"></p><p></p><p></p><p align="center">图5</p><p></p><p></p><p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p><p></p><p></p><p>主存的存取过程如下：</p><p></p><p></p><p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p><p></p><p></p><p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p><p></p><p></p><p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><p></p><p></p><h3>磁盘存取原理</h3><p></p><p></p><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p></p><p></p><p>图6是磁盘的整体结构示意图。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/6.png"></p><p></p><p></p><p align="center">图6</p><p></p><p></p><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p></p><p></p><p>图7是磁盘结构的示意图。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/7.png"></p><p></p><p></p><p align="center">图7</p><p></p><p></p><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p></p><p></p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><p></p><p></p><h3>局部性原理与磁盘预读</h3><p></p><p></p><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><p></p><p></p><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p><p></p><p></p><p>程序运行期间所需要的数据通常比较集中。</p><p></p><p></p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p></p><p></p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p></p><p></p><h3>B-/+Tree索引的性能分析</h3><p></p><p></p><p>到这里终于可以分析B-/+Tree索引的性能了。</p><p></p><p></p><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p></p><p></p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p></p><p></p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为(O(h)=O(log_dN))。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p></p><p></p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p></p><p></p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p><p></p><p></p><p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p><p></p><p></p><p>(d_{max}=floor(pagesize / (keysize + datasize + pointsize)))</p><p></p><p></p><p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p><p></p><p></p><p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p><p></p><p></p><h1><a name="nav-3"></a>MySQL索引实现</h1><p></p><p></p><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><p></p><p></p><h2><a name="nav-3-1"></a>MyISAM索引实现</h2><p></p><p></p><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/8.png"></p><p></p><p></p><p align="center">图8</p><p></p><p></p><p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/9.png"></p><p></p><p></p><p align="center">图9</p><p></p><p></p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><p></p><p></p><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><p></p><p></p><h2><a name="nav-3-2"></a>InnoDB索引实现</h2><p></p><p></p><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p></p><p></p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/10.png"></p><p></p><p></p><p align="center">图10</p><p></p><p></p><p>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p></p><p></p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/11.png"></p><p></p><p></p><p align="center">图11</p><p></p><p></p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p></p><p></p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><p></p><p></p><p>下一章将具体讨论这些与索引有关的优化策略。</p><p></p><p></p><h1><a name="nav-4"></a>索引使用策略及优化</h1><p></p><p></p><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。</p><p></p><p></p><h2><a name="nav-4-1"></a>示例数据库</h2><p></p><p></p><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/12.png"></p><p></p><p></p><p align="center">图12</p><p></p><p></p><p>MySQL官方文档中关于此数据库的页面为<a title="http://dev.mysql.com/doc/employee/en/employee.html" href="http://dev.mysql.com/doc/employee/en/employee.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/employee/en/employee.html</a>。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。</p><p></p><p></p><h2><a name="nav-4-2"></a>最左前缀原理与相关优化</h2><p></p><p></p><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p><p></p><p></p><p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</p><p></p><p></p><p>以employees.titles表为例，下面先查看其上都有哪些索引：</p><p></p><p><pre class="prettyprint linenums">SHOW INDEX FROM employees.titles;<br>+——–+————+———-+————–+————-+———–+————-+——+————+<br>| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |<br>+——–+————+———-+————–+————-+———–+————-+——+————+<br>| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      |<br>| titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      |<br>| titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      |<br>| titles |          1 | emp_no   |            1 | emp_no      | A         |      443308 |      | BTREE      |<br>+——–+————+———-+————–+————-+———–+————-+——+————+</pre></p><p></p><p>从结果中可以到titles表的主索引为&lt;emp_no, title, from_date&gt;，还有一个辅助索引&lt;emp_no&gt;。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：</p><p></p><p><pre class="prettyprint linenums">ALTER TABLE employees.titles DROP INDEX emp_no;</pre></p><p></p><p>这样就可以专心分析索引PRIMARY的行为了。</p><p></p><p></p><h3>情况一：全列匹配。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND title=’Senior Engineer’ AND from_date=’1986-06-26’;<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+</pre></p><p></p><p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE from_date=’1986-06-26’ AND emp_no=’10001’ AND title=’Senior Engineer’;<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+<br>|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |<br>+—-+————-+——–+——-+—————+———+———+——————-+——+——-+</pre></p><p></p><p>效果是一样的。</p><p></p><p></p><h3>情况二：最左前缀匹配。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’;<br>+—-+————-+——–+——+—————+———+———+——-+——+——-+<br>| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |<br>+—-+————-+——–+——+—————+———+———+——-+——+——-+<br>|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |<br>+—-+————-+——–+——+—————+———+———+——-+——+——-+</pre></p><p></p><p>当查询条件精确匹配索引的左边连续一个或几个列时，如&lt;emp_no&gt;或&lt;emp_no, title&gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</p><p></p><p></p><h3>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND from_date=’1986-06-26’;<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+</pre></p><p></p><p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p><p></p><p></p><p>首先我们看下title一共有几种不同的值：</p><p></p><p><pre class="prettyprint linenums">SELECT DISTINCT(title) FROM employees.titles;<br>+——————–+<br>| title              |<br>+——————–+<br>| Senior Engineer    |<br>| Staff              |<br>| Engineer           |<br>| Senior Staff       |<br>| Assistant Engineer |<br>| Technique Leader   |<br>| Manager            |<br>+——————–+</pre></p><p></p><p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no=’10001’<br>AND title IN (‘Senior Engineer’, ‘Staff’, ‘Engineer’, ‘Senior Staff’, ‘Assistant Engineer’, ‘Technique Leader’, ‘Manager’)<br>AND from_date=’1986-06-26’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |    7 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：</p><p></p><p><pre class="prettyprint linenums">SHOW PROFILES;<br>+———-+————+——————————————————————————-+<br>| Query_ID | Duration   | Query                                                                         |<br>+———-+————+——————————————————————————-+<br>|       10 | 0.00058000 | SELECT <em> FROM employees.titles WHERE emp_no=’10001’ AND from_date=’1986-06-26’|<br>|       11 | 0.00052500 | SELECT </em> FROM employees.titles WHERE emp_no=’10001’ AND title IN …          |<br>+———-+————+——————————————————————————-+</pre></p><p></p><p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p><p></p><p></p><h3>情况四：查询条件没有指定索引第一列。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE from_date=’1986-06-26’;<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+</pre></p><p></p><p>由于不是最左前缀，索引这样的查询显然用不到索引。</p><p></p><p></p><h3>情况五：匹配某列的前缀字符串。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND title LIKE ‘Senior%’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 56      | NULL |    1 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>此时可以用到索引，<strike>但是如果通配符不是只出现在末尾，则无法使用索引。</strike>（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）</p><p></p><p></p><h3>情况六：范围查询。</h3><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; ‘10010’ and title=’Senior Engineer’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no &lt; ‘10010’<br>AND title=’Senior Engineer’<br>AND from_date BETWEEN ‘1986-01-01’ AND ‘1986-12-31’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no BETWEEN ‘10001’ AND ‘10010’<br>AND title=’Senior Engineer’<br>AND from_date BETWEEN ‘1986-01-01’ AND ‘1986-12-31’;<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+<br>|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |<br>+—-+————-+——–+——-+—————+———+———+——+——+————-+</pre></p><p></p><p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p><p></p><p></p><h3>情况七：查询条件中含有函数或表达式。</h3><p></p><p></p><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND left(title, 6)=’Senior’;<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+<br>|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |<br>+—-+————-+——–+——+—————+———+———+——-+——+————-+</pre></p><p></p><p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1=’10000’;<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+<br>|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |<br>+—-+————-+——–+——+—————+——+———+——+——–+————-+</pre></p><p></p><p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p><p></p><p></p><h2><a name="nav-4-3"></a>索引选择性与前缀索引</h2><p></p><p></p><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p><p></p><p></p><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p><p></p><p></p><p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p><p></p><p></p><p>Index Selectivity = Cardinality / #T</p><p></p><p></p><p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.0000 |<br>+————-+</pre></p><p></p><p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p><p></p><p></p><p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p><p></p><p></p><p>从图12可以看到employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p><p></p><p><pre class="prettyprint linenums">EXPLAIN SELECT * FROM employees.employees WHERE first_name=’Eric’ AND last_name=’Anido’;<br>+—-+————-+———–+——+—————+——+———+——+——–+————-+<br>| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |<br>+—-+————-+———–+——+—————+——+———+——+——–+————-+<br>|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |<br>+—-+————-+———–+——+—————+——+———+——+——–+————-+</pre></p><p></p><p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建&lt;first_name&gt;或&lt;first_name, last_name&gt;，看下两个索引的选择性：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(first_name))/count(<em>) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.0042 |<br>+————-+<br>SELECT count(DISTINCT(concat(first_name, last_name)))/count(</em>) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.9313 |<br>+————-+</pre></p><p></p><p>&lt;first_name&gt;显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.7879 |<br>+————-+</pre></p><p></p><p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p><p></p><p><pre class="prettyprint linenums">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees;<br>+————-+<br>| Selectivity |<br>+————-+<br>|      0.9007 |<br>+————-+</pre></p><p></p><p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上：</p><p></p><p><pre class="prettyprint linenums">ALTER TABLE employees.employees<br>ADD INDEX <code>first_name_last_name4</code> (first_name, last_name(4));</pre></p><p></p><p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p><p></p><p><pre class="prettyprint linenums">SHOW PROFILES;<br>+———-+————+———————————————————————————+<br>| Query_ID | Duration   | Query                                                                           |<br>+———-+————+———————————————————————————+<br>|       87 | 0.11941700 | SELECT <em> FROM employees.employees WHERE first_name=’Eric’ AND last_name=’Anido’ |<br>|       90 | 0.00092400 | SELECT </em> FROM employees.employees WHERE first_name=’Eric’ AND last_name=’Anido’ |<br>+———-+————+———————————————————————————+</pre></p><p></p><p>性能的提升是显著的，查询速度提高了120多倍。</p><p></p><p></p><p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p><p></p><p></p><h2><a name="nav-4-4"></a>InnoDB的主键选择与插入优化</h2><p></p><p></p><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p><p></p><p></p><p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p><p></p><p></p><p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p></p><p></p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/13.png"></p><p></p><p></p><p align="center">图13</p><p></p><p></p><p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p></p><p></p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p><p></p><p></p><p class="picture"><img alt src="/uploads/pictures/theory-of-mysql-index/14.png"></p><p></p><p></p><p align="center">图14</p><p></p><p></p><p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><p></p><p></p><p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p><p></p><p></p><h1><a name="nav-5"></a>后记</h1><p></p><p></p><p>这篇文章断断续续写了半个月，主要内容就是上面这些了。不可否认，这篇文章在一定程度上有纸上谈兵之嫌，因为我本人对MySQL的使用属于菜鸟级别，更没有太多数据库调优的经验，在这里大谈数据库索引调优有点大言不惭。就当是我个人的一篇学习笔记了。</p><p></p><p></p><p>其实数据库索引调优是一项技术活，不能仅仅靠理论，因为实际情况千变万化，而且MySQL本身存在很复杂的机制，如查询优化策略和各种引擎的实现差异等都会使情况变得更加复杂。但同时这些理论是索引调优的基础，只有在明白理论的基础上，才能对调优策略进行合理推断并了解其背后的机制，然后结合实践中不断的实验和摸索，从而真正达到高效使用MySQL索引的目的。</p><p></p><p></p><p>另外，MySQL索引及其优化涵盖范围非常广，本文只是涉及到其中一部分。如与排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）的话题本文并未涉及，同时除B-Tree索引外MySQL还根据不同引擎支持的哈希索引、全文索引等等本文也并未涉及。如果有机会，希望再对本文未涉及的部分进行补充吧。</p><br><p></p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理 作者 张洋 | 发布于 2011-10-18</a></p>]]></content>
    
    <summary type="html">
    
      本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论
    
    </summary>
    
    
      <category term="MySQL, Index, Database" scheme="http://yoursite.com/tags/MySQL-Index-Database/"/>
    
  </entry>
  
  <entry>
    <title>The Difference between Process and Thread</title>
    <link href="http://yoursite.com/2020/02/05/The-Difference-between-Process-and-Thread/"/>
    <id>http://yoursite.com/2020/02/05/The-Difference-between-Process-and-Thread/</id>
    <published>2020-02-05T08:41:49.000Z</published>
    <updated>2020-02-17T10:19:15.781Z</updated>
    
    <content type="html"><![CDATA[<p>对于操作系统而言，进程是整个现代操作系统的根本，操作系統是以进程为单位执行任务。随着技术发展，在执行一些细小任务，且本身无需分配单独资源时，进程的实现机制依然会繁琐的将资源分割，这样造成浪费，而且还消耗时间，所以就有了专门的多任务技术被创造出来——线程。 线程的特点就是在不需要独立资源的情况下就可以运行。如此一来会极大节省资源开销，以及处理时间。</p><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><p>我们有如下对比图片：</p><table><thead><tr><th>Tables</th><th style="text-align:center">Process   进程</th><th style="text-align:right">Thread线程</th></tr></thead><tbody><tr><td>引入目的</td><td style="text-align:center">可以并发执行，提高资源的利用率和系统吞吐量</td><td style="text-align:right">调高并发执行的速度，进一步提高资源的利用率和系统吞吐量</td></tr><tr><td>并发性</td><td style="text-align:center">较低</td><td style="text-align:right">较高</td></tr><tr><td>基本属性（调度）</td><td style="text-align:center">资源拥有的基本单位是进程，独立调度/分配的基本单位是进程</td><td style="text-align:right">资源拥有的基本单位是进程，独立调度/分配的基本单位是线程</td></tr><tr><td>基本状态</td><td style="text-align:center">就绪；执行；等待</td><td style="text-align:right">就绪；执行；等待</td></tr><tr><td>系统开销</td><td style="text-align:center">创建/撤销/切换时开销较大</td><td style="text-align:right">创建/撤销/切换时开销较小</td></tr><tr><td>系统操作</td><td style="text-align:center">创建；撤销；切换</td><td style="text-align:right">创建；撤销；切换</td></tr><tr><td>存在状态</td><td style="text-align:center">进程控制块PCB</td><td style="text-align:right">进程控制块PCB，进程控制块TCB</td></tr></tbody></table><h4 id="但是对于-Linux-来说，它只支持轻量级进程，不支持线程，对于-Linux-而言："><a href="#但是对于-Linux-来说，它只支持轻量级进程，不支持线程，对于-Linux-而言：" class="headerlink" title="但是对于 Linux 来说，它只支持轻量级进程，不支持线程，对于 Linux 而言："></a>但是对于 Linux 来说，它只支持轻量级进程，不支持线程，对于 Linux 而言：</h4><ul><li>系统启动后的 第一个进程是 init，它的 PID 是 1。init 是唯一一个由系统内核直接运行的进程。</li><li>除了 init 之外，每个进程都有 父进程（PPID 标识）</li><li>每个进程还有四个 与用户和组相关的识别号<br>1.实际用户识别号 （real user ID，RUID）<br>2.实际组识别号 （real group ID，RGID）<br>3.有效用户识别号 （effect user ID，EUID）<br>4.有效组识别号 （effect group ID，EGID</li></ul><p>######在 Linux 内核 2.4 版以前，线程的实现和管理方式就是完全按照进程方式实现的。在 2.6 版内核以后才有了单独的线程实现,为了弥补不支持线程的缺陷，Linux 引入线程组的概念，即该组中第一个轻量级进程的 PID，它被存入进程描述符的 tgid 字段中。<code>getpid()</code>系统调用返回当前进程的 tgid 值而不是 pid 值，因此，一个多线程应用的所有线程共享相同的 PID。</p><ul><li><code>fork()</code>系统调用是Unix下以自身进程创建子进程的系统调用，一次调用，两次返回，如果返回是0，则是子进程，如果返回值&gt;0，则是父进程（返回值是子进程的pid）,如果fork出错，返回一个负值.</li><li>在<code>fork()</code>的调用处，整个父进程空间会原模原样地复制到子进程中，包括指令，变量值，程序调用栈，环境变量，缓冲区，等等。</li><li><code>fork()</code>函数会把它所在语句以后的语句复制到一个子进程里，单独执行。</li><li><p>如果<code>printf</code>函数最后没有<code>&quot;\n&quot;</code>，则输出缓冲区不会被立即清空，而fork函数会把输出缓冲区里的内容也都复制到子进程里</p></li><li><p>进程的执行过程是线状的，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。</p></li><li>线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。</li><li>计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</li><li>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</li><li>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。</li></ul><p><strong>文章来源:</strong><br><a href="https://zhuanlan.zhihu.com/p/60558136" target="_blank" rel="noopener">进程和线程有哪些区别与联系？力扣（LeetCode）</a></p>]]></content>
    
    <summary type="html">
    
      进程和线程有哪些区别与联系
    
    </summary>
    
    
      <category term="Operation System" scheme="http://yoursite.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>Everything About HashMap</title>
    <link href="http://yoursite.com/2020/02/04/Everything-About-HashMap/"/>
    <id>http://yoursite.com/2020/02/04/Everything-About-HashMap/</id>
    <published>2020-02-04T10:51:33.000Z</published>
    <updated>2020-03-13T17:38:09.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么用HashMap？"><a href="#1-为什么用HashMap？" class="headerlink" title="1.为什么用HashMap？"></a>1.为什么用HashMap？</h2><ul><li>HashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射。</li><li>HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改。数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到. 链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</li><li>用LinkedList代替数组结构可以么?</li></ul><p>当然是可以的，稍微说明一下，此题的意思是，源码中是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry[] table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line"></span><br><span class="line">Entry就是一个链表节点。 那下面这样表示，是否可行?</span><br><span class="line"></span><br><span class="line">List&lt;Entry&gt; table = <span class="keyword">new</span> LinkedList&lt;Entry&gt;();</span><br></pre></td></tr></table></figure><p>答案很明显，是可以的。</p><p>既然是可以的,为什么HashMap不用LinkedList,而选用数组?<br>因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</p><ul><li>那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList?<br>因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。 而ArrayList的扩容机制是1.5倍扩容，那ArrayList为什么是1.5倍扩容这就不在本文说明了。</li><li>HashMap是非synchronized，所以HashMap很快。</li><li>HashMap可以接受null键和值，而Hashtable则不能（原因就是<code>equlas()</code>方法需要对象，因为HashMap是后出的API经过处理才可以）</li><li>当链表转为红黑树后，什么时候退化为链表?<br>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</li></ul><h2 id="2-HashMap的工作原理是什么？"><a href="#2-HashMap的工作原理是什么？" class="headerlink" title="2.HashMap的工作原理是什么？"></a>2.HashMap的工作原理是什么？</h2><p>HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node。　　</p><ul><li>以下是HashMap初始化 ，简单模拟数据结构<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Node[] table=<span class="keyword">new</span> Node[<span class="number">16</span>]  散列桶初始化，table</span><br><span class="line"></span><br><span class="line">　　 <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　hash;<span class="comment">//hash值</span></span><br><span class="line"></span><br><span class="line">     key;<span class="comment">//键</span></span><br><span class="line"></span><br><span class="line">　　　　value;<span class="comment">//值</span></span><br><span class="line"></span><br><span class="line">　　　　node next;<span class="comment">//用于指向链表的下一层（产生冲突，用拉链法）</span></span><br><span class="line"></span><br><span class="line">　　 &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="put过程（JDK1-8版）"><a href="#put过程（JDK1-8版）" class="headerlink" title="put过程（JDK1.8版）"></a><code>put</code>过程（JDK1.8版）</h4><ul><li>对Key用HashCode()求Hash值，然后再计算下标</li><li>如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）</li><li>如果碰撞了，以链表的方式链接到后面</li><li>如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表</li><li>如果节点已经存在就替换旧值</li><li>如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）</li></ul><p><strong>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</strong></p><h4 id="Get过程-考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？"><a href="#Get过程-考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？" class="headerlink" title="Get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)"></a><code>Get过程</code>(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)</h4><p>当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。</p><p>　　</p><h2 id="3-有什么方法可以减少碰撞？"><a href="#3-有什么方法可以减少碰撞？" class="headerlink" title="3.有什么方法可以减少碰撞？"></a>3.有什么方法可以减少碰撞？</h2><ul><li>扰动函数可以减少碰撞，原理是如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这就意味着存链表结构减小，这样取值的话就不会频繁调用equal方法，这样就能提高HashMap的性能。（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。）</li><li>使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。为什么String, Interger这样的wrapper类适合作为键？因为String是final的，而且已经重写了equals()和hashCode()方法了。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。</li></ul><h2 id="4-HashMap中hash函数怎么是是实现的"><a href="#4-HashMap中hash函数怎么是是实现的" class="headerlink" title="4.HashMap中hash函数怎么是是实现的?"></a>4.HashMap中hash函数怎么是是实现的?</h2><p>　　我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式，我们来看看JDK1.8的源码是怎么做的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     h=key.hashCode()；返回散列值也就是hashcode</span><br><span class="line">      <span class="comment">// ^ ：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="comment">//其中n是数组的长度，即Map的数组部分初始化长度</span></span><br><span class="line">     <span class="keyword">return</span>  (n-<span class="number">1</span>)&amp;(h ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>高16位异或低16位以后，进行取模运算</strong><br>1.高16bit不变，低16bit和高16bit做了一个异或(得到的HashCode转化为32位的二进制，前16位和后16位低16bit和高16bit做了一个异或)<br>2.(n·1)&amp;hash=-&gt;得到下标</p><ul><li>为什么扩容是2的次幂?</li></ul><p>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法<br>这个算法实际就是取模，hash%length。 但是，大家都知道这种运算不如位移运算快。<br>因此，源码中做了优化hash&amp;(length-1)。 也就是说hash%length==hash&amp;(length-1)</p><h2 id="5-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"><a href="#5-拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？" class="headerlink" title="5.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"></a>5.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</h2><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p><h2 id="6-对红黑树的见解？"><a href="#6-对红黑树的见解？" class="headerlink" title="6.对红黑树的见解？"></a>6.对红黑树的见解？</h2><ul><li>节点是红色或黑色。</li><li>根节点是黑色。</li><li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li><strong>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</strong></li></ul><h2 id="7-解决hash-碰撞还有那些办法？"><a href="#7-解决hash-碰撞还有那些办法？" class="headerlink" title="7.解决hash 碰撞还有那些办法？"></a>7.解决hash 碰撞还有那些办法？</h2><p><strong>比较出名的有四种 (1)开放定址法 (2)链地址法 (3)再哈希法 (4)公共溢出区域法</strong></p><ul><li>开放定址法<br>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li><li>链地址法<br>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li><li>再哈希法<br>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li><li>建立公共溢出区<br>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li></ul><p><strong>下面给一个线性探查法的例子</strong>　</p><p><strong>问题：已知一组关键字为(26，36，41，38，44，15，68，12，06，51)，用除余法构造散列函数，用线性探查法解决冲突构造这组关键字的散列表</strong></p><p> <strong>解答：为了减少冲突，通常令装填因子α由除余法因子是13的散列函数计算出的上述关键字序列的散列地址为(0，10，2，12，5，2，3，12，6，12)。</strong></p><ul><li>前5个关键字插入时，其相应的地址均为开放地址，故将它们直接插入T[0]，T[10)，T[2]，T[12]和T[5]中。</li><li>当插入第6个关键字15时，其散列地址2(即h(15)=15％13=2)已被关键字41(15和41互为同义词)占用。故探查h1=(2+1)％13=3，此地址开放，所以将15放入T[3]中。</li><li>当插入第7个关键字68时，其散列地址3已被非同义词15先占用，故将其插入到T[4]中。</li><li>当插入第8个关键字12时，散列地址12已被同义词38占用，故探查hl=(12+1)％13=0，而T[0]亦被26占用，再探查h2=(12+2)％13=1，此地址开放，可将12插入其中。</li><li>类似地，第9个关键字06直接插入T[6]中；而最后一个关键字51插人时，因探查的地址12，0，1，…，6均非空，故51插入T[7]中。</li></ul><h2 id="8-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#8-如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h2><p>　　默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为 <strong>&lt;原下标+原容量&gt;</strong> 的位置　　</p><h2 id="9-重新调整HashMap大小存在什么问题吗？"><a href="#9-重新调整HashMap大小存在什么问题吗？" class="headerlink" title="9.重新调整HashMap大小存在什么问题吗？"></a>9.重新调整HashMap大小存在什么问题吗？</h2><ul><li>当扩容重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。因为直接插入的效率更高。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap）。</li><li>为什么多线程会导致死循环，它是怎么发生的？<br>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。1.扩容：创建一个新的Entry空数组，长度是原数组的2倍。2.ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。</li></ul><blockquote><p> <strong>HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</strong></p></blockquote><blockquote><p>在HashMap1.7之前是头插法，在扩容的过程中，可能会造成一个resize()的方法，然后调用transfer()方法，把里面的Entry进行了Rehash，在过程中，可能会造成链表的循环，在一下次Get()中出现死循环，或者出现没有加锁，所以数据不安全</p></blockquote><h2 id="10-HashTable"><a href="#10-HashTable" class="headerlink" title="10.HashTable"></a>10.HashTable</h2><p>数组 + 链表方式存储<br>默认容量： 11(质数为宜)</p><h4 id="Put"><a href="#Put" class="headerlink" title="Put:"></a><code>Put:</code></h4><ul><li>对key的hashCode()做hash运算，计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树(JDK1.8中的改动)； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。</li><li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li><li>若在链表中找到了，则替换旧值，若未找到则继续</li><li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li><li><strong>将新元素加到链表头部,对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全</strong>。<h4 id="Get"><a href="#Get" class="headerlink" title="Get:"></a><code>Get:</code></h4>对key的hashCode()做hash运算，计算index; 如果在bucket里的第一个节点里直接命中，则直接返回； 如果有冲突，则通过key.equals(k)去查找对应的Entry;<br>• 若为树，则在树中通过key.equals(k)查找，O(logn)；<br>• 若为链表，则在链表中通过key.equals(k)查找，O(n)。</li></ul><h2 id="11-HashMap-，HashTable-区别"><a href="#11-HashMap-，HashTable-区别" class="headerlink" title="11.HashMap ，HashTable 区别"></a>11.HashMap ，HashTable 区别</h2><ul><li>默认容量不同。扩容不同</li><li>线程安全性，HashTable 安全  </li><li>效率不同 HashTable 要慢因为加锁</li></ul><h2 id="12-可以使用CocurrentHashMap来代替Hashtable吗？"><a href="#12-可以使用CocurrentHashMap来代替Hashtable吗？" class="headerlink" title="12.可以使用CocurrentHashMap来代替Hashtable吗？"></a>12.可以使用CocurrentHashMap来代替Hashtable吗？</h2><p>我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p><h2 id="13-CocurrentHashMap（1-8）"><a href="#13-CocurrentHashMap（1-8）" class="headerlink" title="13.CocurrentHashMap（1.8）"></a>13.CocurrentHashMap（1.8）</h2><ul><li>其中抛弃了原有的 Segment 分段锁，而采用了<code>CAS + synchronized</code>来保证并发安全性。</li><li>其中的 val next 都用了 <code>volatile</code>修饰，保证了可见性</li><li>最大特点是引入了 CAS（借助 Unsafe 来实现【native code】）<br>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li><li><p>CAS 会出现的问题：ABA<br>解决：对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。<br>####<code>Put过程</code></p></li><li><p>根据 key 计算出 hashcode 。判断是否需要进行初始化。</p></li><li>通过 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li><p>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</p><h4 id="Get过程"><a href="#Get过程" class="headerlink" title="Get过程"></a><code>Get过程</code></h4></li><li><p>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p></li><li>如果是红黑树那就按照树的方式获取值。</li><li>都不满足那就按照链表的方式遍历获取值。</li></ul><h2 id="14-TreeMap"><a href="#14-TreeMap" class="headerlink" title="14.TreeMap"></a>14.TreeMap</h2><p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和HashMap不同，它的get、put、remove之类操作都是O(logn)的复杂度，具体顺序可以由指定的Comparator来决定，或者根据键的自然顺序来判断</p><h2 id="15-hash算法是干嘛的？还知道哪些hash算法？"><a href="#15-hash算法是干嘛的？还知道哪些hash算法？" class="headerlink" title="15.hash算法是干嘛的？还知道哪些hash算法？"></a>15.hash算法是干嘛的？还知道哪些hash算法？</h2><p>Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。<br>比较出名的算法有SHA,MD4、MD5等</p><p>说说String中hashcode的实现?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>String类中的hashCode计算方法还是比较简单的，就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。</li><li>哈希计算公式可以计为<figure class="highlight plain"><figcaption><span>+ s[1]*31^(n-2) + ... + s[n-1]```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 那为什么以31为质数呢?</span><br><span class="line">主要是因为31是一个奇质数，所以```31*i=32*i-i=(i&lt;&lt;5)-i```，这种位移与减法结合的计算相比一般的运算快很多。</span><br><span class="line"></span><br><span class="line">## 16.健可以为Null值么?</span><br><span class="line"></span><br><span class="line">可以，key为null的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。</span><br><span class="line"></span><br><span class="line">## 17.一般用什么作为HashMap的key?</span><br><span class="line"></span><br><span class="line">一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。</span><br><span class="line">• (1) 因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</span><br><span class="line">• (2) 因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的覆写了hashCode()以及equals()方法。</span><br><span class="line"></span><br><span class="line">## Hashcode</span><br><span class="line">* 一、hashCode简介</span><br><span class="line">public int hashCode()：``hashCode``是根类Obeject中的方法。默认情况下，Object中的``hashCode() ``返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。</span><br><span class="line">* 二、hashCode注意点</span><br><span class="line">关于hashCode方法，一致的约定是：</span><br><span class="line">1、重写了``euqls``方法的对象必须同时重写``hashCode()``方法。</span><br><span class="line">2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</span><br><span class="line">3、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</span><br><span class="line">* 三、hashCode作用</span><br><span class="line">从Object角度看，JVM每new一个Object，它都会将这个Object丢到一个Hash表中去，这样的话，下次做Object的比较或者取这个对象的时候（读取过程），它会根据对象的HashCode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。若HashCode相同再去调用equal。</span><br><span class="line">HashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。</span><br><span class="line">* 四、为什么重写</span><br><span class="line">实际开发的过程中在hashmap或者hashset里如果不重写的hashcode和equals方法的话会导致我们存对象的时候，把对象存进去了，取的时候却取不到想要的对象。</span><br><span class="line">重写了hashcode和equals方法可以迅速的在hashmap中找到键的位置；</span><br><span class="line">#### **重写hashcode是为了保证相同的对象会有相同的hashcode；**</span><br><span class="line">#### **重写equals是为了保证在发生冲突的情况下取得到Entry对象（也可以理解是key或是元素）**；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存在一个table数组，里面每个元素都是一个node链表，当添加一个元素（key-value）时，就首先计算元素key的hash值，通过table的长度和key的hash值进行与运算得到一个index，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就把这个元素添加到同一hash值的node链表的链尾，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度大于等于8时，链表就可能转换为红黑树，这样大大提高了查找的效率。</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191102133424361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM1ODMzMTE=,size_16,color_FFFFFF,t_70&quot; alt=&quot;存储结构&quot; /&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&amp;lt;K,V&amp;gt; next; //可以看得出这是一个链表</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">        *</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li></ul><li>HashMap内部包含一个Node类型的数组table，Node由Map.Entry继承而来。</li><br><li>Node存储着键值对。它包含四个字段，从next字段我们可以看出node是一个链表。</li><br><li>table数组中的每个位置都可以当做一个桶，一个桶存放一个链表。</li><br><li>HashMap使用拉链法来解决冲突，同一个存放散列值相同的Node。</li><br><h4 id="数据域">数据域</h4><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;  </span><br><span class="line"><span class="comment">// 初始化容量，初始化有16个桶</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &amp;lt;&amp;lt; <span class="number">4</span>; <span class="comment">// aka 16  </span></span><br><span class="line"><span class="comment">// 最大容量  1 073 741 824, 10亿多</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &amp;lt;&amp;lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 当put()一个元素到某个桶，其链表长度达到8时有可能将链表转换为红黑树  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;  </span><br><span class="line"><span class="comment">// 在hashMap扩容时，如果发现链表长度小于等于6，则会由红黑树重新退化为链表。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;  </span><br><span class="line"><span class="comment">// 在转变成红黑树树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换，否者直接扩容。这是为了避免在HashMap建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;  </span><br><span class="line"><span class="comment">// 存储元素的数组  </span></span><br><span class="line"><span class="keyword">transient</span> Node&amp;lt;k,v&amp;gt;[] table;</span><br><span class="line"><span class="comment">// 存放元素的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 被修改的次数fast-fail机制   </span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 临界值 当实际大小(容量*填充比)超过临界值时，会进行扩容   </span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 填充比</span></span><br><span class="line">final float loadFactor;&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;h4 id="构造函数"&gt;构造函数&lt;/h4&gt;</span><br><span class="line">&lt;pre <span class="class"><span class="keyword">class</span></span>=<span class="string">"java"</span>&gt;&lt;code&gt;<span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &amp;lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(&amp;quot;Illegal initial capacity: &amp;quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &amp;gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &amp;lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(&amp;quot;Illegal load factor: &amp;quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// tableSizeFor(initialCapacity)方法计算出接近initialCapacity</span></span><br><span class="line">        <span class="comment">// 参数的2^n来作为初始化容量。</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&amp;lt;? extends K, ? extends V&amp;gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li><p>HashMap构造函数允许用户传入容量不是2的n次方，因为它可以自动地将传入的容量转换为2的n次方。</p><br></li></ul><br>### <code>Put()</code>源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// “扰动函数”。参考 https://www.cnblogs.com/zhengwang/p/8136164.html</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; <span class="number">16</span>);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] tab; HashMap.Node&amp;lt;K,V&amp;gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 未初始化则初始化table</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 通过table的长度和hash与运算得到一个index，</span></span><br><span class="line">        <span class="comment">// 然后判断table数组下标为index处是否已经存在node。</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp;amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果table数组下标为index处为空则新创建一个node放在该处</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 运行到这代表table数组下标为index处已经存在node，即发生了碰撞</span></span><br><span class="line">            HashMap.Node&amp;lt;K,V&amp;gt; e; K k;</span><br><span class="line">            <span class="comment">// 检查这个node的key是否跟插入的key是否相同。</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                    ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 检查这个node是否已经是一个红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果这个node已经是一个红黑树则继续往树种添加节点</span></span><br><span class="line">                e = ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 在这里循环遍历node链表</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断是否到达链表尾</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 到达链表尾，直接把新node插入链表，插入链表尾部，在jdk8之前是头插法</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &amp;gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            <span class="comment">// 如果node链表的长度大于等于8则可能把这个node转换为红黑树</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 检查这个node的key是否跟插入的key是否相同。</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当插入key存在，则更新value值并返回旧value</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改次数++</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 如果当前大小大于门限，门限原本是初始容量*0.75</span></span><br><span class="line">        <span class="keyword">if</span> (++size &amp;gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br><ul><br><li>下面简单说下put()流程：<br><ol><br><li>判断键值对数组table[]是否为空或为null，否则以默认大小resize()；</li><br><li>根据键key计算hash值与table的长度进行与运算得到插入的数组索引 index，如果tab[index] == null，直接根据key-value新建node添加，否则转入3</li><br><li>判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可),分别处理</li><br></ol></li><p><li>为啥头插法为什么要换成尾插：jdk1.7时候用头插法可能是考虑到了一个所谓的热点数据的点(新插入的数据可能会更早用到)；找到链表尾部的时间复杂度是 O(n)，或者需要使用额外的内存地址来保存链表尾部的位置，头插法可以节省插入耗时。但是在扩容时会改变链表中元素原本的顺序，以至于在<strong>并发场景下导致链表成环</strong>的问题。</li></p><p><li>从putVal()源码可以看出，HashMap并没有对null的键值对做限制（hash值设为0），即HashMap允许插入键尾null的键值对。但在JDK1.8之前HashMap使用第0个node存放键为null的键值对。</li></p><p><li>确定node下标：通过table的长度和key的hash进行与运算得到一个index。</li></p><p><li>在转变成红黑树树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换，否者直接扩容。这是为了避免在HashMap建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</li><br></p></ul><p></p><h2 id="大多数人不知道的：HashMap链表成环的原因和解决方案"><a href="#大多数人不知道的：HashMap链表成环的原因和解决方案" class="headerlink" title="大多数人不知道的：HashMap链表成环的原因和解决方案"></a><a href="https://www.cnblogs.com/wen-he/p/11496050.html" target="_blank" rel="noopener">大多数人不知道的：HashMap链表成环的原因和解决方案</a></h2><h3 id="get-操作源码解析"><a href="#get-操作源码解析" class="headerlink" title="get()操作源码解析"></a>get()操作源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HashMap.Node&amp;lt;K,V&amp;gt; getNode(<span class="keyword">int</span> hash, Object key) &#123;</span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] tab; HashMap.Node&amp;lt;K,V&amp;gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="comment">// table不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;amp;&amp;amp; (n = tab.length) &amp;gt; <span class="number">0</span> &amp;amp;&amp;amp;</span><br><span class="line">                <span class="comment">// 通过table的长度和hash与运算得到一个index，table</span></span><br><span class="line">                <span class="comment">// 下标位index处的元素不为空，即元素为node链表</span></span><br><span class="line">                (first = tab[(n - <span class="number">1</span>) &amp;amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 首先判断node链表中中第一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;amp;&amp;amp; <span class="comment">// always check first node</span></span><br><span class="line">                    <span class="comment">// 分别判断key为null和key不为null的情况</span></span><br><span class="line">                    ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// key相等则返回第一个</span></span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">// 第一个节点key不同且node链表不止包含一个节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断node链表是否转为红黑树。</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">                    <span class="comment">// 则在红黑树中进行查找。</span></span><br><span class="line">                    <span class="keyword">return</span> ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 循环遍历node链表中的节点，判断key是否相等</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;amp;&amp;amp;</span><br><span class="line">                            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;amp;&amp;amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key在table中不存在则返回null。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>get(key)方法首先获取key的hash值，</li><li>计算hash &amp; (table.len - 1)得到在链表数组中的位置，</li><li>先判断node链表（桶）中的第一个节点的key是否与参数key相等，</li><li>不等则判断是否已经转为红黑树，若转为红黑树则在红黑树中查找，</li><li>如没有转为红黑树就遍历后面的链表找到相同的key值返回对应的Value值即可。</li></ul><h3 id="resize-操作源码解析"><a href="#resize-操作源码解析" class="headerlink" title="resize()操作源码解析"></a>resize()操作源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化或者扩容之后的元素调整</span></span><br><span class="line">    <span class="keyword">final</span> HashMap.Node&amp;lt;K,V&amp;gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">// 获取旧table</span></span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">// 旧table容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">// 旧table扩容临界值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">// 定义新table容量和临界值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果原table不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果table容量达到最大值，则修改临界值为Integer.MAX_VALUE</span></span><br><span class="line">            <span class="comment">// MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;</span></span><br><span class="line">            <span class="comment">// Integer.MAX_VALUE = 1 &amp;lt;&amp;lt; 31 - 1;</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &amp;gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// Map达到最大容量，这时还要向map中放数据，则直接设置临界值为整数的最大值</span></span><br><span class="line">                <span class="comment">// 在容量没有达到最大值之前不会再resize。</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">// 结束操作</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面就是扩容操作（2倍）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &amp;lt;&amp;lt; <span class="number">1</span>) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;</span><br><span class="line">                    oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">// 临界值也变为两倍</span></span><br><span class="line">                newThr = oldThr &amp;lt;&amp;lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &amp;gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 进入此if证明创建HashMap时用的带参构造：public HashMap(int initialCapacity)</span></span><br><span class="line"><span class="comment">             * 或 public HashMap(int initialCapacity, float loadFactor)</span></span><br><span class="line"><span class="comment">             * 注：带参的构造中initialCapacity（初始容量值）不管是输入几都会通过</span></span><br><span class="line"><span class="comment">             * tableSizeFor(initialCapacity)方法计算出接近initialCapacity</span></span><br><span class="line"><span class="comment">             * 参数的2^n来作为初始化容量。</span></span><br><span class="line"><span class="comment">             * 所以实际创建的容量并不等于设置的初始容量。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">// 进入此if证明创建map时用的无参构造：</span></span><br><span class="line">            <span class="comment">// 然后将参数newCap（新的容量）、newThr(新的扩容阀界值)进行初始化</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 进入这代表有两种可能。</span></span><br><span class="line">            <span class="comment">// 1. 说明old table容量大于0但是小于16.</span></span><br><span class="line">            <span class="comment">// 2. 创建HashMap时用的带参构造，根据loadFactor计算临界值。</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改临界值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;&amp;quot;rawtypes&amp;quot;,&amp;quot;unchecked&amp;quot;&#125;)</span><br><span class="line">        <span class="comment">// 根据新的容量生成新的 table</span></span><br><span class="line">        HashMap.Node&amp;lt;K,V&amp;gt;[] newTab = (HashMap.Node&amp;lt;K,V&amp;gt;[])<span class="keyword">new</span> HashMap.Node[newCap];</span><br><span class="line">        <span class="comment">// 替换成新的table</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">// 如果oldTab不为null说明是扩容，否则直接返回newTab</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 遍历原来的table */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; oldCap; ++j) &#123;</span><br><span class="line">                HashMap.Node&amp;lt;K,V&amp;gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 判断这个桶（链表）中就只有一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// 根据新的容量重新计算在table中的位置index，并把当前元素赋值给他。</span></span><br><span class="line">                        newTab[e.hash &amp;amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">// 判断这个链表是否已经转为红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">                        <span class="comment">// 在split函数中可能由于红黑树的长度小于等于UNTREEIFY_THRESHOLD（6）</span></span><br><span class="line">                        <span class="comment">// 则把红黑树重新转为链表</span></span><br><span class="line">                        ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">// 运行到这里证明桶中有多个节点。</span></span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        HashMap.Node&amp;lt;K,V&amp;gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">// 对桶进行遍历</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp;amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-的工作原理是什么"><a href="#HashMap-的工作原理是什么" class="headerlink" title="HashMap 的工作原理是什么?"></a>HashMap 的工作原理是什么?</h2><p>HashMap基于hashing原理，我们通过put()和get()方法存储和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来存储值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会存储在链表的第一个节点，链接原先的对象节点，HashMap在每个链表节点中存储键值对对象。</p><h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？"></a>快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？</h2><ul><li>1、快速失败（fail-fast）<br>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行修改（增加、删除、修改），则会抛出Concurrent Modification Exception.<br>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。<br>注意：这里异常的抛出条件是检测到modCount!=expectedmodCount这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。<br>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</li><li>2、安全失败（fail-safe）<br>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<br>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。<br>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception,但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的<br>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li></ul><p><img src="https://img1.sycdn.imooc.com/5d56493300011c0e19151612.png" alt="源码导读"></p><p><a href="https://blog.csdn.net/weixin_44460333/article/details/86770169" target="_blank" rel="noopener">HashMap？ConcurrentHashMap？相信看完这篇没人能难住你</a></p>]]></content>
    
    <summary type="html">
    
      Find Everything about HashMap IN There.
    
    </summary>
    
    
      <category term="Analyst of SourceCode" scheme="http://yoursite.com/tags/Analyst-of-SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms, Part I | Princeton Online</title>
    <link href="http://yoursite.com/2020/01/16/Algorithms-Part-I-Princeton-Online/"/>
    <id>http://yoursite.com/2020/01/16/Algorithms-Part-I-Princeton-Online/</id>
    <published>2020-01-16T14:19:13.000Z</published>
    <updated>2020-01-16T14:29:42.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Princeton-Online-course"><a href="#Princeton-Online-course" class="headerlink" title="Princeton Online course"></a><a href="https://algs4.cs.princeton.edu/" target="_blank" rel="noopener">Princeton Online course</a></h2><h2 id="You-can-find-all-the-code-and-comments-details-in-this-Repository"><a href="#You-can-find-all-the-code-and-comments-details-in-this-Repository" class="headerlink" title="You can find all the code and comments details in this Repository"></a><a href="https://github.com/Williamren97/Alg4" target="_blank" rel="noopener">You can find all the code and comments details in this Repository</a></h2><h3 id="What-algorithms-and-data-structures-will-be-covered-in-this-course"><a href="#What-algorithms-and-data-structures-will-be-covered-in-this-course" class="headerlink" title="What algorithms and data structures will be covered in this course?"></a>What algorithms and data structures will be covered in this course?</h3><h4 id="The-first-part-will-focus-on-the-basic-data-structure-sorting-and-searching"><a href="#The-first-part-will-focus-on-the-basic-data-structure-sorting-and-searching" class="headerlink" title="The first part will focus on the basic data structure, sorting, and searching."></a>The first part will focus on the basic data structure, sorting, and searching.</h4><ul><li>Topics include: parallel search algorithm, binary search, stack, queue, backpack, insert sort, select sort, hill sort, fast sort, three-way fast sort, merge sort, heap sort, binary heap, binary search tree, red-black tree , Split link and linear probe hash tables, Graham scans, kd trees.</li></ul><h4 id="The-second-part-will-focus-on-graph-and-string-processing-algorithms"><a href="#The-second-part-will-focus-on-graph-and-string-processing-algorithms" class="headerlink" title="The second part will focus on graph and string processing algorithms."></a>The second part will focus on graph and string processing algorithms.</h4><ul><li>Topics include: depth-first search, width-first search, topology sorting, Kosaraju-Sharir algorithm, Kruskal algorithm, Prim algorithm, Dijkistra algorithm, Bellman-Ford algorithm, Ford-Fulkerson algorithm, LSD cardinality ranking algorithm, MSD cardinality ranking algorithm, three-way Cardinality fast sorting algorithm, multi-path trie algorithm, ternary search trie algorithm, Knuth-Morris-Pratt algorithm, Boyer-Moore algorithm, Rabin-Karp algorithm, regular matching, run-length encoding, Huffman encoding, LZW compression, Burrows-Wheeler transform .</li></ul><h4 id="The-Imp-of-Algorithm-in-Princeton-University"><a href="#The-Imp-of-Algorithm-in-Princeton-University" class="headerlink" title="The Imp of Algorithm in Princeton University."></a>The Imp of Algorithm in Princeton University.</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Princeton-Online-course&quot;&gt;&lt;a href=&quot;#Princeton-Online-course&quot; class=&quot;headerlink&quot; title=&quot;Princeton Online course&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
      <category term="Algorithms," scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>EveryThing About MySQL</title>
    <link href="http://yoursite.com/2020/01/14/EveryThing-About-MySQL/"/>
    <id>http://yoursite.com/2020/01/14/EveryThing-About-MySQL/</id>
    <published>2020-01-14T15:37:44.000Z</published>
    <updated>2020-02-23T16:59:23.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><p><a href="https://blog.csdn.net/chai471793/article/details/99563704" target="_blank" rel="noopener">彻底搞懂系列B-树、B+树、B-树、B*树</a></p><p><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">B树和B+树的插入、删除图文详解</a></p><h3 id="关系型数据库和非关系型数据库为什么用B树或B-树"><a href="#关系型数据库和非关系型数据库为什么用B树或B-树" class="headerlink" title="关系型数据库和非关系型数据库为什么用B树或B+树"></a><a href="https://baijiahao.baidu.com/s?id=1658675762218129560&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">关系型数据库和非关系型数据库为什么用B树或B+树</a></h3><blockquote><p>==B+树的数据只出现在叶子节点上==，因此在查询单条数据的时候，查询速度非常稳定。因此，==在做单一数据的查询上，其平均性能并不如B树==。但是，B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，==只需要对叶子节点进行遍历即可，这个特性使得B+树非常适合做范围查询==。</p></blockquote><ul><li>没准是==Mysql中数据遍历操作比较多，所以用B+树作为索引结构==。凡做这种关联查询，你躲不开join操作的！既然涉及到了<code>Join</code>操作，无外乎从一个表中取一个数据，去另一个表中逐行匹配，如果索引结构是B+树，叶子节点上是有指针的，能够极大的提高这种一行一行的匹配速度</li><li>==而Mongodb是做单一查询比较多，数据遍历操作比较少==，所以用B树作为索引结构。</li></ul><p>那么为什么Mysql做数据遍历操作多？而Mongodb做数据遍历操作少呢？因为Mysql是关系型数据库，而Mongodb是非关系型数据。</p><p>平衡二叉树则是子树高读不能超过2，B树非叶子节点也可以存储数据，B+树则是叶子节点才可以存储数据。</p><ul><li>我们说的==平衡二叉树结构，指的是逻辑结构上的平衡二叉树，其物理实现是数组==。然后由于在逻辑结构上相近的节点在物理结构上可能会差很远。因此，每次读取的磁盘页的数据中有许多是用不上的。因此，查找过程中要进行许多次的磁盘读取操作。而适合作为索引的结构应该是尽可能少的执行磁盘IO操作，因为执行磁盘IO操作非常的耗时。因此，平衡二叉树并不适合作为索引结构</li><li>红黑树这种结构==h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性==，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。也就是说，使用红黑树（平衡二叉树）结构的话，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。</li><li>==B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能==。每次读取磁盘页时就会读取一整个节点。==也正因每个节点存储着非常多个关键字，树的深度就会非常的小==。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</li><li>==B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中==。因此，虽然B树查询查询的次数不比平衡二叉树的次数少，但是相比起磁盘IO速度，内存中比较的耗时就可以忽略不计了。因此，B树更适合作为索引。</li></ul><h1 id="一步步分析为什么B-树适合作为索引的结构-以及索引原理-阿里面试，写的很好"><a href="#一步步分析为什么B-树适合作为索引的结构-以及索引原理-阿里面试，写的很好" class="headerlink" title="一步步分析为什么B+树适合作为索引的结构 以及索引原理(阿里面试，写的很好"></a><a href="https://www.cnblogs.com/aspirant/p/9214485.html" target="_blank" rel="noopener">一步步分析为什么B+树适合作为索引的结构 以及索引原理(阿里面试，写的很好</a></h1><p>B+Tree是mysql使用最频繁的一个索引数据结构，是Inodb和Myisam存储引擎模式的索引类型。相对Hash索引，B+Tree在查找单条记录的速度比不上Hash索引(Memory表只存在内存中)，但是因为更适合排序等操作，所以它更受欢迎。毕竟不可能只对数据库进行单条记录的操作。</p><ul><li><p>带顺序访问指针的B+Tree</p><blockquote><p>B+Tree所有索引数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。这样做是为了提高区间效率，例如查询key为从18到49的所有数据记录，当找到18后，只要顺着节点和指针顺序遍历就可以以此向访问到所有数据节点，极大提高了区间查询效率。</p></blockquote></li><li><p>大大减少磁盘I/O读取</p><blockquote><p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点需要一次I/O就可以完全载入</p></blockquote></li></ul><p><strong>全文索引（FULLTEXT）=mysql的myISAM搜索引擎默认的索引类型</strong>==不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法==。</p><p>文本字段上的普通索引只能加快对出现在字段内容最前面的字符串(也就是字段内容开头的字符)进行检索操作。如果字段里存放的是由几个、甚至是多个单词构成的较大段文字，普通索引就没什么作用了。这种检索往往以LIKE%word%的形式出现，这对MySQL来说很复杂，如果需要处理的数据量很大，响应时间就会很长。</p><p>这类场合正是全文索引(full-textindex)可以大显身手的地方。在生成这种类型的索引时，MySQL将把在文本中出现的所有单词创建为一份清单，查询操作将根据这份清单去检索有关的数据记录。全文索引即可以随数据表一同创建，也可以等日后有必要时再使用下面这条命令添加：<br><code>ALTER TABLE table_name ADD FULLTEXT(column1, column2)</code></p><p>有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。下面是这类查询命令的基本语法：<br>　　<br><code>SELECT * FROM table_name WHERE MATCH(column1, column2) AGAINST(&#39;word1&#39;, &#39;word2&#39;, &#39;word3&#39;)</code></p><p>上面这条命令将把column1和column2字段里有word1、word2和word3的数据记录全部查询出来。</p><p><a href="https://blog.csdn.net/qq_33330687/article/details/89004462" target="_blank" rel="noopener">InnoDB如何解决幻读</a></p><blockquote><p>使用MVCC</p></blockquote><p><a href="https://www.jianshu.com/p/bbaeab492a64" target="_blank" rel="noopener">一条SQL语句是如何执行的</a></p><p>由server层和存储引擎组成</p><blockquote><p>server 层包括连接器、分析器、优化器、执行器，涵盖 MySQL的核心服务，以及所有的内置函数（如日期、时间、数学、加密函数等），还有所有跨存储引擎的功能，例如存储过程、触发器、视图等。</p></blockquote><p><a href="https://blog.csdn.net/zxp0727/article/details/84580277" target="_blank" rel="noopener">一条SQL更新语句是如何执行的？</a></p><blockquote><p>里面包含binlog和redolog,两阶段提交</p></blockquote><h4 id="什么叫视图？游标是什么？"><a href="#什么叫视图？游标是什么？" class="headerlink" title="什么叫视图？游标是什么？"></a>什么叫视图？游标是什么？</h4><ul><li>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</li><li>游标是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</li></ul><h3 id="请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</h3><h3 id="在Mysql中ENUM的用法是什么？"><a href="#在Mysql中ENUM的用法是什么？" class="headerlink" title="在Mysql中ENUM的用法是什么？"></a>在Mysql中ENUM的用法是什么？</h3><blockquote><p>同一个属性里面包含多个字段，每个字段都有自己的索引.enum 在数据库底层以整型方式储存，从 1 开始，0 用于指代空或错误的字符串。</p></blockquote><h3 id="CHAR和VARCHAR的区别？"><a href="#CHAR和VARCHAR的区别？" class="headerlink" title="CHAR和VARCHAR的区别？"></a>CHAR和VARCHAR的区别？</h3><p>char 固定长度255，不足的部分补空格，取出时再去掉空格。varchar 不定长度</p><h3 id="drop-delete与truncate的区别"><a href="#drop-delete与truncate的区别" class="headerlink" title="drop,delete与truncate的区别"></a>drop,delete与truncate的区别</h3><p>drop删除表，truncate清空表，delete删除表、drop和truncate不能回滚。</p><h3 id="存储过程与触发器的区别"><a href="#存储过程与触发器的区别" class="headerlink" title="存储过程与触发器的区别"></a>存储过程与触发器的区别</h3><ul><li>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</li><li>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。可以供外部程序调用，比如：java程序。<blockquote><p>存储过程是预编译过的，执行效率高。存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。安全性高，执行存储过程需要有一定权限的用户。存储过程可以重复使用，可减少数据库开发人员的工作量。==缺点：移植性差==。</p></blockquote></li></ul><p>2）可以供外部程序调用，比如：java程序。</p><h3 id="完整性约束包括哪些？"><a href="#完整性约束包括哪些？" class="headerlink" title="完整性约束包括哪些？"></a><a href="https://www.cnblogs.com/hwlong/p/9009311.html" target="_blank" rel="noopener">完整性约束包括哪些</a>？</h3><p>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</p><ul><li>实体完整性：规定表的每一行在表中是惟一的实体。</li><li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li><li>参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</li><li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li></ul><p>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE)</p><p>MySql不支持check</p><h3 id="Mysql-的存储引擎-myisam和innodb的区别。"><a href="#Mysql-的存储引擎-myisam和innodb的区别。" class="headerlink" title="Mysql 的存储引擎,myisam和innodb的区别。"></a>Mysql 的存储引擎,myisam和innodb的区别。</h3><pre><code>NULL | myisam | innodb</code></pre><p>   —|—|—<br>事务支持|不支持| 支持| row 2 col 2<br>存储结构     |三种文件  | 一种文件<br>存储空间     |体积小 | 体积大<br>可移植性     |方便 | 困难<br>锁力度     |表级锁| 表级锁，行级锁<br>全文索引     |支持 | 不支持<br>表主键     |可以没有|必须有，没有就自动生成<br>外键     |不支持 | 支持</p><h2 id="1-锁"><a href="#1-锁" class="headerlink" title="1.锁"></a>1.锁</h2><ul><li>MyISAM 是非事务的存储引擎，适合用于频繁查询的应用。表锁，不会出现死锁，适合小数据，小并发。</li><li>Innodb是支持事务的存储引擎，合于插入和更新操作比较多的应用，设计合理的话是行锁（最大区别就在锁的级别上），适合大数据，大并发<br><img src="https://upload-images.jianshu.io/upload_images/2604566-27832dbe20e803fa.png" alt="image"><h3 id="表锁和行锁的区别"><a href="#表锁和行锁的区别" class="headerlink" title="表锁和行锁的区别"></a>表锁和行锁的区别</h3><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5></li><li>特点：开销小、加锁快、<strong>无死锁</strong>；锁粒度大，发生锁冲突的概率高，<strong>高并发下性能低</strong></li><li>加锁的方式：自动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5></li><li>特点：锁的粒度小，发生锁冲突的概率低、<strong>处理并发的能力强</strong>；开销大、加锁慢、<strong>会出现死锁</strong></li><li><p>加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁。</p></li><li><p>乐观锁：不加锁，只有在更新时验证数据是否被其他线程更新，吞吐量较高，适用于多读场景。它==假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚==。</p><blockquote><p>乐观锁实现方式是：版本号version和CAS(compare and swap)</p></blockquote></li><li>悲观锁：读取时加锁，更新完释放锁，再此过程中会造成其他线程阻塞，导致吞吐量低，适用于多写场景。当事务A对某行数据应用了锁，==并且当这个事务把锁释放后，其他事务才能够执行与该锁冲突的操作==，这里事务A所施加的锁就叫悲观锁。</li></ul><blockquote><p>行锁(共享锁和排他锁),间隙锁(next-keylock）都属于悲观锁。<br>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：==允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁==。</li><li>排他锁（X)：==允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。==<br>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</li></ul></blockquote><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁* ，事务在给一个数据行加排他锁前必须先取得该表的IX锁。<h5 id="间隙锁（Next-Key锁）"><a href="#间隙锁（Next-Key锁）" class="headerlink" title="间隙锁（Next-Key锁）:"></a>间隙锁（Next-Key锁）:</h5></li><li>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；</li><li>对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key)锁。</li></ul><hr><ul><li>1:<strong>表级锁不会死锁,行级锁和页级锁可能死锁</strong></li><li>2:在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。</li><li>3:==从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应==用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</li><li>4:意向锁是InnoDB自动加的，不需用户干预。==对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)==；对于普通SELECT语句，InnoDB不会加任何锁；</li><li>5:InnoDB行锁实现方式: ==InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁==</li></ul><h3 id="Mysql中MVCC的使用及原理详解"><a href="#Mysql中MVCC的使用及原理详解" class="headerlink" title="Mysql中MVCC的使用及原理详解"></a><a href="https://blog.csdn.net/w2064004678/article/details/83012387" target="_blank" rel="noopener">Mysql中MVCC的使用及原理详解</a></h3><p>MVCC是一种多版本并发控制机制。MVCC是通过保存数据在某个时间点的快照来实现的。在每个表后添加创建版本号和删除版本号，版本号为修改该项的事务版本号。</p><ul><li>SELECT:InnoDB会根据以下两个条件检查每行记录<blockquote><p>InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的.</p></blockquote></li></ul><blockquote><p>行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除.<br>只有a,b同时满足的记录，才能返回作为查询结果.</p></blockquote><ul><li><p>DELETE:InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识.</p></li><li><p>UPDATE:InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间。</p></li></ul><h2 id="锁策略"><a href="#锁策略" class="headerlink" title="锁策略"></a><a href="https://www.nowcoder.com/discuss/151430" target="_blank" rel="noopener">锁策略</a></h2><h2 id="2-日志"><a href="#2-日志" class="headerlink" title="2.日志"></a>2.日志</h2><h3 id="redolog，binlog，undolog对事务的影响"><a href="#redolog，binlog，undolog对事务的影响" class="headerlink" title="redolog，binlog，undolog对事务的影响"></a>redolog，binlog，undolog对事务的影响</h3><ul><li>binlog</li><li>redolog,保证事务的持久性，缓存区中数据会慢慢更新到数据库的硬盘上。</li><li>undolog，记录了修改几率，可以随便回滚，保证原子性。</li></ul><h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h2><p>MVCC (MultiVersion Concurrency Control) 叫做==多版本并发==控制。==由undolog和记录版本的一个东西组成==。</p><blockquote><p>InnoDB的 MVCC，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，当然存储的并不是实际的时间值，而是系统版本号。</p></blockquote><p>以上片段摘自《高性能Mysql》这本书对MVCC的定义。他的主要实现思想是通过==数据多版本==来做到==读写分离==。从而实现不加锁读进而做到读写并行。</p><p><strong>MVCC在mysql中的实现依赖的是undo log与read view</strong></p><ul><li>undolog :undolog中记录某行数据的多个版本的数据。</li><li>read view :用来判断当前版本数据的可见性<h3 id="ACID特性中的一致性是如何实现的"><a href="#ACID特性中的一致性是如何实现的" class="headerlink" title="ACID特性中的一致性是如何实现的"></a>ACID特性中的一致性是如何实现的</h3></li><li>事务的原子性是通过 undo log 来实现的</li><li>事务的持久性性是通过 redo log 来实现的</li><li>事务的隔离性是通过 (读写锁+MVCC)来实现的</li><li>而事务的终极大boss一致性是通过原子性，持久性，隔离性来实现的！！！<blockquote><p>原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性</p></blockquote></li><li><a href="https://www.sohu.com/a/316482862_663371" target="_blank" rel="noopener">事务是如何通过日志实现的</a></li><li>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Buffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。<blockquote><p>redolog来记录已成功提交事务的修改信息，并且会把redolog持久化到磁盘，系统重启之后在读取redo log恢复最新数据。redolog是用来恢复数据的 用于保障，已提交事务的持久化特性</p></blockquote></li></ul><blockquote><p>undolog 叫做回滚日志，用于记录数据被修改前的信息。<strong>他正好跟前面所说的重做日志所记录的相反，redolog记录数据被修改后的信息。undolog主要记录的是数据的逻辑变化</strong>，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。undolog记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undolog的信息来进行回滚到没被修改前的状态。</p></blockquote><p><code>redo和undo</code>基本流程如下：<br>因为事务在修改页时，要先记 undo，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 Redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。 当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的状态，崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。 如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。</p><h2 id="4-索引"><a href="#4-索引" class="headerlink" title="4.索引"></a>4.索引</h2><h3 id="MySQL索引背后的数据结构及算法原理"><a href="#MySQL索引背后的数据结构及算法原理" class="headerlink" title="MySQL索引背后的数据结构及算法原理"></a><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></h3><h3 id="多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）"><a href="#多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）" class="headerlink" title="多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）"></a>多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）</h3><ul><li><p>唯一索引</p><blockquote><p>唯一索引是<strong>不允许其中任何两行具有相同索引值的索引</strong>。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p></blockquote></li><li><p>主键索引</p><blockquote><p>数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p></blockquote></li><li><p>聚集索引</p><blockquote><p>表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p></blockquote><h3 id="建索引有哪些原则"><a href="#建索引有哪些原则" class="headerlink" title="建索引有哪些原则"></a>建索引有哪些原则</h3><blockquote><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说应该在这些列上创建索引：</p></blockquote></li><li><p>在经常需要搜索的列上，可以加快搜索的速度</p></li><li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li><li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li></ul><h3 id="什么情况下设置了索引但无法使用"><a href="#什么情况下设置了索引但无法使用" class="headerlink" title="什么情况下设置了索引但无法使用"></a>什么情况下设置了索引但无法使用</h3><ul><li>条件中使用了 or，而相关列不全有索引</li><li>条件中使用了and，而相关列不满足最左原则</li><li>索引列的数据类型出现隐形转换，如varchar不加单引号的话可能会自动转换为int型）</li><li>like查询是以%开头</li><li>where 子句里对索引列上有数学运算/函数</li><li>mysql估计使用全表扫描要比使用索引快<h3 id="什么情况下不宜建立索引？"><a href="#什么情况下不宜建立索引？" class="headerlink" title="什么情况下不宜建立索引？"></a>什么情况下不宜建立索引？</h3></li><li>对于那些在查询中==很少使用或者参考的列不应该创建索引==。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>对于那些==只有很少数据值的列==也不应该增加索引。举例比如性别只有男和女</li><li>对于==那些定义为text,image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少==。</li><li>经==常频繁更新的列==不要建立索引，因为肯定会影响插入或更新的效率</li><li>尽量避==免在 where 子句中使用 ！= 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫==描。</li><li>当==修改性能远远大于检索性能时，不应该创建索引==。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li><li>尽量避免NULL：在MySQL中，==含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂==。可以采用0、一个特殊的值或者一个空串代替空值<blockquote><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p></blockquote><h3 id="为什么用B-树"><a href="#为什么用B-树" class="headerlink" title="为什么用B-树"></a>为什么用B-树</h3>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了==磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入== 为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</li></ul><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>为什么不用红黑树</p><blockquote><p>红黑树这种结构，h(层数)明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p></blockquote><h3 id="MySQL索引失效的情形很多。"><a href="#MySQL索引失效的情形很多。" class="headerlink" title="MySQL索引失效的情形很多。"></a>MySQL索引失效的情形很多。</h3><p>例如： 在WHERE条件的LIKE关键字匹配的字符串以”%“开头，这种情况下，索引是不会起到作用的；WHERE条件中使用OR关键字来连接多个查询条件，如果有一个条件没有使用索引，那么其他的索引也不会起作用；多列索引的第一个字段没有使用，那么这个多列索引也不会起作用。 使用in查询时，in查询条件超过数据库表的一半的时候也会失效。</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><ul><li>索引字段要尽量的小</li><li>索引的最左匹配特性（即从左往右匹配）：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</li></ul><h3 id="MySQL索引优化深入分析执行计划"><a href="#MySQL索引优化深入分析执行计划" class="headerlink" title="MySQL索引优化深入分析执行计划"></a><a href="https://mp.weixin.qq.com/s/TSbfdC6G-r8pvgpQ3qyjMA" target="_blank" rel="noopener">MySQL索引优化深入分析执行计划</a></h3><h3 id="如果有2级索引怎么存"><a href="#如果有2级索引怎么存" class="headerlink" title="如果有2级索引怎么存"></a>如果有2级索引怎么存</h3><h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，==磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。==这样做的理论依据是计算机科学中著名的==<br>局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中==。</p><p><strong>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效</strong>率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，<strong>会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行</strong></p><h2 id="5-SQL语句"><a href="#5-SQL语句" class="headerlink" title="5.SQL语句"></a>5.SQL语句</h2><p> <a href="https://www.runoob.com/sql/sql-groupby.html" target="_blank" rel="noopener">SQL语句菜鸟教程</a></p><h4 id="SQL教程"><a href="#SQL教程" class="headerlink" title="SQL教程"></a>SQL教程</h4><ul><li><code>AND</code>运算符，如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</li><li><p><code>OR运算符</code>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Websites</span><br><span class="line">WHERE alexa &gt; 15</span><br><span class="line">AND (country=&apos;CN&apos; OR country=&apos;USA&apos;);</span><br></pre></td></tr></table></figure></li><li><p><code>ORDER BY</code> 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p></li><li><code>IN</code>操作符IN操作符允许在WHERE子句中规定多个值。</li><li><p><code>BETWEEN</code>操作符用于选取介于两个值之间的数据范围内的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Websites</span><br><span class="line">WHERE (alexa BETWEEN 1 AND 20)</span><br><span class="line">AND country NOT IN (&apos;USA&apos;, &apos;IND&apos;);</span><br></pre></td></tr></table></figure></li><li><p>INNER JOIN：如果表中有至少一个匹配，则返回行</p></li><li>LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN：只要其中一个表中存在匹配，则返回行</li></ul><h4 id="SQL高级教程"><a href="#SQL高级教程" class="headerlink" title="SQL高级教程"></a>SQL高级教程</h4><ul><li>模糊查询(like)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Websites</span><br><span class="line">以&quot;G&quot;开始的所有客户WHERE name LIKE &apos;G%&apos;;</span><br><span class="line">以&quot;k&quot;结尾的所有客户WHERE name LIKE &apos;%k&apos;;</span><br><span class="line">还可以写NOT LIKE做反向查询</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://blog.csdn.net/lu0422/article/details/78892497" target="_blank" rel="noopener">解释MySQL外连接、内连接(outer join和inner join)与自连接的区别外连接</a><br><img src="https://www.runoob.com/wp-content/uploads/2019/01/sql-join.png" alt="SQL JOINS"></p><ul><li>左连接：连接两张表，左表数据完全显示，右表匹配，匹配不上的补null；在这里，t_employee就是左表，也就是基准表，==用基准表的数据去匹配右表的数据，所以左表的记录是全部会查询出来的，如果右表没有记录对应的话就显示null==。<blockquote><p>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</p></blockquote></li><li>右连接：同上，换个方向；<br>全外连接：两表字段都匹配，匹配不上的补null；</li><li>内连接：所有查询出的结果都是能够在连接的表中有对应记录的。这就是内连接的特点，==只查询在连接的表中能够有对应的记录==，<blockquote><p>INNER JOIN关键字在表中存在至少一个匹配时返回行。</p></blockquote></li><li>全外连接：==mysql是没有全外连接的==(mysql中没有<code>full outer join</code>关键字)，==想要达到全外连接的效果，可以使用<code>union</code>关键字连接左外连接和右外连接==。<strong>如果在Oracle中，直接就使用<code>full outer join</code>关键字连接两表就行了。</strong></li><li><p>UNION</p><blockquote><p>SQL UNION 操作符合并两个或多个 SELECT 语句的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT country FROM Websites</span><br><span class="line">UNION</span><br><span class="line">SELECT country FROM apps</span><br><span class="line">ORDER BY country;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>SELECT INTO</p><blockquote><p>通过 SQL，您可以从一个表复制信息到另一个表。SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 新表</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM 旧表</span><br></pre></td></tr></table></figure><ul><li><p>INSERT INTO SELECT</p><blockquote><p>通过 SQL，您可以从一个表复制信息到另一个表。INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table2</span><br><span class="line">SELECT * FROM table1;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>自连接：找到两表的公共字段，然后和内连接一样。</p></li><li>交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</li></ul><p><code>SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</code></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a><a href="https://www.cnblogs.com/wz123/p/9722942.html" target="_blank" rel="noopener">子查询</a></h3><p>一个SELECT语句嵌套在另一个SELECT语句中，子查询也叫做内部查询，而包含子查询的语句又称为外部查询或主查询，子查询自身可以包含一个或多个子查询，一个查询语句中可以嵌套任意数量的子查询。</p><h4 id="SQL查询重复记录"><a href="#SQL查询重复记录" class="headerlink" title="SQL查询重复记录"></a><a href="https://www.cnblogs.com/njccqx/p/9672504.html" target="_blank" rel="noopener">SQL查询重复记录</a></h4><hr><p><a href="https://blog.csdn.net/a755199443/article/details/88723685" target="_blank" rel="noopener">MySQL两道经典SQL面试题(行转列/列转行/求最值)</a></p><h3 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h3><ul><li>GROUP BY<blockquote><p>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">统计 access_log 各个 site_id 的访问量：</span><br><span class="line">SELECT site_id, SUM(access_log.count) AS nums</span><br><span class="line">FROM access_log GROUP BY site_id;</span><br></pre></td></tr></table></figure></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Websites.name,COUNT(access_log.aid) AS nums FROM access_log</span><br><span class="line">LEFT JOIN Websites</span><br><span class="line">ON access_log.site_id=Websites.id</span><br><span class="line">GROUP BY Websites.name;</span><br></pre></td></tr></table></figure><ul><li>HAVING<blockquote><p>在 SQL 中增加 HAVING 子句原因是，==WHERE 关键字无法与聚合函数一起使用==。HAVING 子句可以让我们筛选分组后的各组数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查找总访问量大于 200 的网站。</span><br><span class="line">SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_log INNER JOIN Websites</span><br><span class="line">ON access_log.site_id=Websites.id)</span><br><span class="line">GROUP BY Websites.name</span><br><span class="line">HAVING SUM(access_log.count) &gt; 200;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="6-SQL优化"><a href="#6-SQL优化" class="headerlink" title="6.SQL优化"></a>6.SQL优化</h2><h6 id="慢查询解决的基本步骤"><a href="#慢查询解决的基本步骤" class="headerlink" title="慢查询解决的基本步骤"></a>慢查询解决的基本步骤</h6><h6 id="500万数量级查询优化"><a href="#500万数量级查询优化" class="headerlink" title="500万数量级查询优化"></a><a href="https://mp.weixin.qq.com/s/-ZSBoPVYUY5UN_lrwqQKVw" target="_blank" rel="noopener">500万数量级查询优化</a></h6><h6 id="我们是如何对实际项目进行查询优化的"><a href="#我们是如何对实际项目进行查询优化的" class="headerlink" title="我们是如何对实际项目进行查询优化的"></a><a href="https://mp.weixin.qq.com/s/zhvN31uYtm-507k3GKJeKg" target="_blank" rel="noopener">我们是如何对实际项目进行查询优化的</a></h6><h6 id="巧用这19条MySQL优化，效率至少提高3倍"><a href="#巧用这19条MySQL优化，效率至少提高3倍" class="headerlink" title="巧用这19条MySQL优化，效率至少提高3倍"></a><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485120&amp;idx=2&amp;sn=c80bd2698209858d86975d551b2144f3&amp;source=41#wechat_redirect" target="_blank" rel="noopener">巧用这19条MySQL优化，效率至少提高3倍</a></h6><h6 id="为什么要分区，分表和分库？"><a href="#为什么要分区，分表和分库？" class="headerlink" title="为什么要分区，分表和分库？"></a><a href="https://www.cnblogs.com/tuhooo/p/9582223.html" target="_blank" rel="noopener">为什么要分区，分表和分库？</a></h6><h6 id="一次SQL查询优化原理分析（900W-数据，从17s到300ms"><a href="#一次SQL查询优化原理分析（900W-数据，从17s到300ms" class="headerlink" title="一次SQL查询优化原理分析（900W+数据，从17s到300ms"></a><a href="https://www.jianshu.com/p/0768ebc4e28d" target="_blank" rel="noopener">一次SQL查询优化原理分析（900W+数据，从17s到300ms</a></h6><h6 id="面试官：给我讲一下分库分表方案"><a href="#面试官：给我讲一下分库分表方案" class="headerlink" title="面试官：给我讲一下分库分表方案"></a><a href="https://www.jianshu.com/p/bf27be3fd448" target="_blank" rel="noopener">面试官：给我讲一下分库分表方案</a></h6><h6 id="数据库如何保证数据不丢失"><a href="#数据库如何保证数据不丢失" class="headerlink" title="数据库如何保证数据不丢失"></a><a href="https://www.cnblogs.com/a-phper/p/10313948.html" target="_blank" rel="noopener">数据库如何保证数据不丢失</a></h6><h6 id="MYSQL的主从同步延迟的原因及解决方案"><a href="#MYSQL的主从同步延迟的原因及解决方案" class="headerlink" title="MYSQL的主从同步延迟的原因及解决方案"></a><a href="https://blog.csdn.net/hao_yunfeng/article/details/82392261" target="_blank" rel="noopener">MYSQL的主从同步延迟的原因及解决方案</a></h6><ul><li>mysql主从复制用途<blockquote><p>从库生成两个线程，一个I/O线程，一个SQL线程；i/o线程去请求主库的binlog，并将得到的binlog日志写到relaylog（中继日志）文件中；主库会生成一个 log dump 线程，用来给从库i/o线程传binlog；<br>SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；</p></blockquote></li></ul><p>实时灾备，用于故障切换,==读写分离(主写从读比例为10：1)==，提供查询服务<br>备份，避免影响业务</p><ul><li>主从部署必要条件：<br>主库开启binlog日志（设置log-bin参数）,主从server-id不同,从库服务器能连通主库<h6 id="数据库如何保证高可用"><a href="#数据库如何保证高可用" class="headerlink" title="数据库如何保证高可用"></a><a href="https://blog.csdn.net/dhfzhishi/article/details/82561939" target="_blank" rel="noopener">数据库如何保证高可用</a></h6><h6 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a><a href="https://blog.csdn.net/qq_42234452/article/details/90906692?fps=1&amp;locationNum=2" target="_blank" rel="noopener">灰度发布</a></h6>在灰度发布开始后，先启动一个新版本应用，但是并不直接将流量切过来，而是测试人员对新版本进行线上测试，启动的这个新版本应用，就是我们的金丝雀。如果没有问题，那么可以将少量的用户流量导入到新版本上，然后再对新版本做运行状态观察，收集各种运行时数据，如果此时对新旧版本做各种数据对比，就是所谓的A/B测试。</li></ul><p>当确认新版本运行良好后，再逐步将更多的流量导入到新版本上，在此期间，还可以不断地调整新旧两个版本的运行的服务器副本数量，以使得新版本能够承受越来越大的流量压力。直到将100%的流量都切换到新版本上，最后关闭剩下的老版本服务，完成灰度发布。</p><p>如果在灰度发布过程中（灰度期）发现了新版本有问题，就应该立即将流量切回老版本上，这样，就会将负面影响控制在最小范围内。</p><h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h2><h6 id="创建表时候的优化"><a href="#创建表时候的优化" class="headerlink" title="创建表时候的优化"></a>创建表时候的优化</h6><ul><li>整数TinyInt,SmallInt,MediumInt,Int,BigInt 使用的存储 8,16,24,32,64 位存储空间。使用 Unsigned 表示不允许负数，可以使正数的上线提高一倍。</li><li>实数Float,Double , 支持近似的浮点运算。<br>Decimal，用于存储精确的小数。</li><li>字符串VarChar，存储变长的字符串。需要 1 或 2 个额外的字节记录字符串的长度。Char，定长，适合存储固定长度的字符串，如 MD5 值。</li><li>Blob，Text为了存储很大的数据而设计的。分别采用二进制和字符的方式。</li><li>时间类型DateTime，保存大范围的值，占 8 个字节。TimeStamp，推荐，与 UNIX 时间戳相同，占 4 个字节。<h6 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h6></li><li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<code>select id from t where num is null</code>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<code>select id from t where num=0</code></li><li>用EXISTS替代IN、用NOT EXISTS替代NOT IN</li><li>用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤。</li><li>尽量避免在where子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</li><li>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。</li><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引<h6 id="索引优化-选择索引的数据类型"><a href="#索引优化-选择索引的数据类型" class="headerlink" title="索引优化(选择索引的数据类型)"></a>索引优化(选择索引的数据类型)</h6>MySQL支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。</li><li>越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和cpu缓存中都需要更少的空间，处理起来更快。</li><li>简单的数据类型更好：整形数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应用内置的日期和时间数据类型，而不是字符串来存储时间；以及用整形数据存储IP地址。</li><li>尽量避免NULL：应该制定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为他们使得索引、索引的统计信息以及比较运算更加复杂。</li><li>为了更多的提高mysql效率可建立组合索引，遵循“最左前缀”原则。创建复合索引应该将最常用（频率）做限制条件的列放在最左边，一次递减。组合索引最左字段用in是可以用到索引的。相当于建立了col1,col1col2,col1col2col3三个索引。<h6 id="分库分表优化"><a href="#分库分表优化" class="headerlink" title="分库分表优化"></a>分库分表优化</h6></li><li><p>垂直拆分：解决问题：表与表之间的io竞争 不解决问题：单表中数据量增长出现的压力</p><blockquote><p>方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上。</p></blockquote></li><li><p>水平拆分： 解决问题：单表中数据量增长出现的压力 不解决问题：表与表之间的io争夺</p><blockquote><p>用户表通过性别拆分为男用户表和女用户表 订单表通过已完成和完成中拆分为已完成订单和未完成订单 产品表 未完成订单放一个server上 已完成订单表盒男用户表放一个server上 女用户表放一个server上(女的爱购物 哈哈)，<br><strong>==可以把学校范围内的用户单独独立出来一张表==。</strong></p></blockquote></li></ul><p>MySQL不需要执行后面的复杂操作，就可以直接返回结果，效率很高，==但是查询缓存失效非常频繁，只要有对一个表的更新，这个表的所有查询缓存都会被清空，因此可能你费力地把结果缓存起来，还没使用，就被一个更新全部清空了。除非你的业务是一张静态表，很长时间才会更新一次，这种情况下可以使用查询缓存==。(==把管理员信息放进去==)</p><h2 id="7-三范式"><a href="#7-三范式" class="headerlink" title="7.三范式"></a>7.三范式</h2><h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>==如果一个关系模式的所有属性的域都是原子的是指数据库表的每一列都是不可分割的基本数据项==，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。（2NF）==要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性==，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p><h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><ul><li>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。（我的理解是消除冗余）</li><li>优点:可以尽量得减少数据冗余，使得更新快，体积小</li><li>缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化</li></ul>]]></content>
    
    <summary type="html">
    
      U can find everything  be need in here.
    
    </summary>
    
    
      <category term="MySQL, DataBase" scheme="http://yoursite.com/tags/MySQL-DataBase/"/>
    
  </entry>
  
  <entry>
    <title>SortAlgorithms</title>
    <link href="http://yoursite.com/2020/01/13/SortAlgorithm/"/>
    <id>http://yoursite.com/2020/01/13/SortAlgorithm/</id>
    <published>2020-01-13T14:19:13.000Z</published>
    <updated>2020-02-17T10:23:38.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SortAlgorithms"><a href="#SortAlgorithms" class="headerlink" title="SortAlgorithms"></a>SortAlgorithms</h1><blockquote><p>原文链接： <a href="https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener"><strong>八大排序算法总结与java实现</strong> - iTimeTraveler</a></p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/big-o.png" alt></p><ul><li><a href="#一直接插入排序insertion-sort">直接插入排序</a></li><li><a href="#二希尔排序shell-sort">希尔排序</a></li><li><a href="#三选择排序selection-sort">简单选择排序</a></li><li><a href="#四堆排序heap-sort">堆排序</a></li><li><a href="#五冒泡排序bubble-sort">冒泡排序</a></li><li><a href="#六快速排序quick-sort">快速排序</a></li><li><a href="#七归并排序merging-sort">归并排序</a></li><li><a href="#八基数排序radix-sort">基数排序</a></li></ul><a id="more"></a><p>其中我们讨论的这八大排序算法的实现可以参考<a href="https://github.com/iTimeTraveler/SortAlgorithms" target="_blank" rel="noopener">我的Github：<strong>SortAlgorithms</strong></a>，其中包括了排序测试模块<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Test.java" target="_blank" rel="noopener">[Test.java]</a>和排序算法对比模块<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/src/main/java/com/example/Bench.java" target="_blank" rel="noopener">[Bench.java]</a>，大家可以试运行。</p><p>它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/1156494-ab4cecff133d87b3.png" alt></p><h3 id="一、直接插入排序（Insertion-Sort）"><a href="#一、直接插入排序（Insertion-Sort）" class="headerlink" title="一、直接插入排序（Insertion Sort）"></a>一、直接插入排序（Insertion Sort）</h3><hr><p>插入排序的设计初衷是<strong>往有序的数组中快速插入一个新的元素</strong>。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.</p><p>插入排序由于操作不尽相同, 可分为 <code>直接插入排序</code> , <code>折半插入排序</code>(又称二分插入排序), <code>链表插入排序</code> , <code>希尔排序</code> 。我们先来看下直接插入排序。</p><h4 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/Insertion-sort-example-300px.gif" alt="使用插入排序为一列数字进行排序的过程"></p><h4 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><p>①. 从第一个元素开始，该元素可以认为已经被排序<br><br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br><br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br><br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br><br>⑤. 将新元素插入到该位置后<br><br>⑥. 重复步骤②~⑤<br></p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/insert-sort.gif" alt="直接插入排序演示"></p><p>算法实现中比较有意思的一点是，在每次比较操作发现取出来的新元素小于等于已排序的元素时，可以将已排序的元素移到下一位置，然后将取出来的新元素插入该位置（即相邻位置对调），接着再与前面的已排序的元素进行比较，如上图所示，这样做缺点是交换操作代价比较大。另一种做法是：将新元素取出（挖坑），从左到右依次与已排序的元素比较，如果已排序的元素大于取出的新元素，那么将该元素移动到下一个位置（填坑），接着再与前面的已排序的元素比较，直到找到已排序的元素小于等于新元素的位置，这时再将新元素插入进去。就像基本思想中的动图演示的那样。</p><p>如果<em>比较操作</em>的代价比<em>交换操作</em>大的话，可以采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95" target="_blank" rel="noopener">二分查找法</a>来减少<em>比较操作</em>的数目。可以认为是<strong>插入排序</strong>的一个变种，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">二分查找插入排序</a>。</p><h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 从第一个元素开始，该元素可以认为已经被排序</span></span><br><span class="line"><span class="comment"> * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class="line"><span class="comment"> * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置</span></span><br><span class="line"><span class="comment"> * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span></span><br><span class="line"><span class="comment"> * 5. 将新元素插入到该位置后</span></span><br><span class="line"><span class="comment"> * 6. 重复步骤2~5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];    <span class="comment">// 取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j-- ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( j &gt; <span class="number">0</span> &amp;&amp; arr[j-<span class="number">1</span>] &gt; temp ) &#123;</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];    <span class="comment">// 如果该元素（已排序）大于取出的元素temp，将该元素移到下一位置</span></span><br><span class="line">                System.out.println(<span class="string">"Temping:  "</span> + Arrays.toString(arr));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将新元素插入到该位置后</span></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换次数较多的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span>; j-- ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( arr[j-<span class="number">1</span>] &lt;= arr[j] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];      <span class="comment">//交换操作</span></span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">            System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入排序复杂度如下：</p><ul><li>最好情况下，排序前对象已经按照要求的有序。比较次数(KCN)：n−1；移动次数(RMN)为0。则对应的时间复杂度为O(n)。</li><li>最坏情况下，排序前对象为要求的顺序的反序。第i趟时第i个对象必须与前面i个对象都做排序码比较，并且每做1次比较就要做1次数据移动（从上面给出的代码中看出）。比较次数(KCN)：n²/2 ; 移动次数(RMN)为：n²/2。则对应的时间复杂度为O(n²)。</li><li>如果排序记录是随机的，那么根据概率相同的原则，在平均情况下的排序码比较次数和对象移动次数约为n²/2，因此，<strong>直接插入排序的平均时间复杂度</strong>为O(n²)。</li></ul><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>Tips: 由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。</p><h3 id="二、希尔排序（Shell-Sort）"><a href="#二、希尔排序（Shell-Sort）" class="headerlink" title="二、希尔排序（Shell Sort）"></a>二、希尔排序（Shell Sort）</h3><hr><blockquote><p>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p></blockquote><p>希尔排序，也称<strong>递减增量排序算法</strong>，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。</p><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h4 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/shell-sort.jpg" alt></p><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p><p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97" target="_blank" rel="noopener">维基百科</a>。</p><h4 id="2、算法描述-1"><a href="#2、算法描述-1" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（<strong>一般初次取数组半长，之后每次再减半，直到增量为1</strong>）<br><br>②. 按增量序列个数k，对序列进行k 趟排序；<br><br>③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br></p><h4 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>以下是我自己的实现，可以看到实现很幼稚，但是好处是理解起来很简单。因为没有经过任何的优化，所以不建议大家直接使用。建议对比下方的维基百科官方实现代码，特别是步长取值策略部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1）</span></span><br><span class="line"><span class="comment"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span></span><br><span class="line"><span class="comment"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span></span><br><span class="line"><span class="comment"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;      <span class="comment">//不断缩小gap，直到1为止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; (j+gap) &lt; arr.length; j++)&#123;     <span class="comment">//使用当前gap进行组内插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; (k+gap)&lt; arr.length; k += gap)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[k] &gt; arr[k+gap]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[k+gap];      <span class="comment">//交换操作</span></span><br><span class="line">                    arr[k+gap] = arr[k];</span><br><span class="line">                    arr[k] = temp;</span><br><span class="line">                    System.out.println(<span class="string">"    Sorting:  "</span> + Arrays.toString(arr));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是维基百科官方实现，大家注意gap步长取值部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序（Wiki官方版）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（注意此算法的gap取值）</span></span><br><span class="line"><span class="comment"> * 2. 按增量序列个数k，对序列进行k 趟排序；</span></span><br><span class="line"><span class="comment"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span></span><br><span class="line"><span class="comment"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">1</span>, i, j, len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>)</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;      <span class="comment">// &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span></span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是希尔排序复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog2 n)</td><td>O(nlog2 n)</td><td>O(nlog2 n)</td><td>O(1)</td></tr></tbody></table><h3 id="三、选择排序（Selection-Sort）"><a href="#三、选择排序（Selection-Sort）" class="headerlink" title="三、选择排序（Selection Sort）"></a>三、选择排序（Selection Sort）</h3><hr><blockquote><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/Selection-Sort-Animation.gif" alt="选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。"></p></blockquote><p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p><h4 id="1、基本思想-2"><a href="#1、基本思想-2" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>选择排序的基本思想：比较 + 交换。</p><p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h4 id="2、算法描述-2"><a href="#2、算法描述-2" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 从待排序序列中，找到关键字最小的元素；<br><br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br><br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。<br></p><h4 id="3、代码实现-2"><a href="#3、代码实现-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 从待排序序列中，找到关键字最小的元素；</span></span><br><span class="line"><span class="comment"> * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</span></span><br><span class="line"><span class="comment"> * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</span></span><br><span class="line"><span class="comment"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++)&#123;    <span class="comment">//选出之后待排序中值最小的位置</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[min];      <span class="comment">//交换操作</span></span><br><span class="line">            arr[min] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是选择排序复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><h3 id="四、堆排序（Heap-Sort）"><a href="#四、堆排序（Heap-Sort）" class="headerlink" title="四、堆排序（Heap Sort）"></a>四、堆排序（Heap Sort）</h3><hr><blockquote><p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p></blockquote><p>堆的定义如下：n个元素的序列{k1,k2,···,kn}，当且仅当满足下关系时，称之为堆。</p><p>ki &lt;= k(2i)  且   ki &lt;= k(2i+1) <br></p><p>或：   ki &gt;= k(2i)  且  ki &gt;=  k(2i+1) <br></p><p>把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：<strong>完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。</strong>由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p><h4 id="1、基本思想-3"><a href="#1、基本思想-3" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p><h4 id="2、算法描述-3"><a href="#2、算法描述-3" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.<br><br>②. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n-1]和有序区K[n], 且满足K[1..n-1].keys &lt;= K[n].key <br><br>③. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n-1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止. <br></p><p>动图效果如下所示：</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/heap_sort_gif.gif" alt="堆排序过程"></p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_heapsort_anim.gif" alt="堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。"></p><h4 id="3、代码实现-3"><a href="#3、代码实现-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p><p>总结起来就是定义了以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>对于堆节点的访问：</p><ul><li>父节点i的左子节点在位置：<code>(2*i+1)</code>;</li><li>父节点i的右子节点在位置：<code>(2*i+2)</code>;</li><li>子节点i的父节点在位置：<code>floor((i-1)/2)</code>;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.</span></span><br><span class="line"><span class="comment"> * 2. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n−1]和有序区K[n], 且满足K[1..n−1].keys⩽K[n].key</span></span><br><span class="line"><span class="comment"> * 3. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        max_heapify(arr, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = arr[<span class="number">0</span>];      <span class="comment">//堆顶元素(第一个元素)与Kn交换</span></span><br><span class="line">        arr[<span class="number">0</span>] = arr[i-<span class="number">1</span>];</span><br><span class="line">        arr[i-<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span> || arr.length &lt; limit) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIdx = limit / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; parentIdx &gt;= <span class="number">0</span>; parentIdx--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parentIdx * <span class="number">2</span> &gt;= limit)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = parentIdx * <span class="number">2</span>;       <span class="comment">//左子节点位置</span></span><br><span class="line">        <span class="keyword">int</span> right = (left + <span class="number">1</span>) &gt;= limit ? left : (left + <span class="number">1</span>);    <span class="comment">//右子节点位置，如果没有右节点，默认为左节点位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxChildId = arr[left] &gt;= arr[right] ? left : right;</span><br><span class="line">        <span class="keyword">if</span>(arr[maxChildId] &gt; arr[parentIdx])&#123;   <span class="comment">//交换父节点与左右子节点中的最大值</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[parentIdx];</span><br><span class="line">            arr[parentIdx] = arr[maxChildId];</span><br><span class="line">            arr[maxChildId] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Max_Heapify: "</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注:</strong> x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 == Math.floor(x/2) .</p></blockquote><p>以上,<br>①. 建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);<br>②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);<br>③. 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn).</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td></tr></tbody></table><p>Tips: <strong>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列.</strong> 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p><h3 id="五、冒泡排序（Bubble-Sort）"><a href="#五、冒泡排序（Bubble-Sort）" class="headerlink" title="五、冒泡排序（Bubble Sort）"></a>五、冒泡排序（Bubble Sort）</h3><hr><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort02.gif" alt="冒泡排序的思想"></p><blockquote><p>我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。</p></blockquote><h4 id="1、基本思想-4"><a href="#1、基本思想-4" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/bubble-sort.gif" alt="冒泡排序演示"></p><h4 id="2、算法描述-4"><a href="#2、算法描述-4" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>冒泡排序算法的运作如下：</p><p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br><br>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br><br>③. 针对所有的元素重复以上的步骤，除了最后一个。<br><br>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。<br></p><h4 id="3、代码实现-4"><a href="#3、代码实现-4" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>冒泡排序需要两个嵌套的循环. 其中, <strong>外层循环</strong>移动游标; <strong>内层循环</strong>遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span></span><br><span class="line"><span class="comment"> * ②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span></span><br><span class="line"><span class="comment"> * ③. 针对所有的元素重复以上的步骤，除了最后一个。</span></span><br><span class="line"><span class="comment"> * ④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;      <span class="comment">//外层循环移动游标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;    <span class="comment">//内层循环遍历游标及之后(或之前)的元素</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是冒泡排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p><p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p><h3 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a>六、快速排序（Quick Sort）</h3><hr><p>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。</p><h4 id="1、基本思想-5"><a href="#1、基本思想-5" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p><p>首先选一个轴值(pivot，也有叫基准的)，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/Sorting_quicksort_anim.gif" alt="使用快速排序法对一列数字进行排序的过程"></p><h4 id="2、算法描述-5"><a href="#2、算法描述-5" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p><p>①. 从数列中挑出一个元素，称为”基准”（pivot）。<br><br>②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br><br>③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br></p><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/quick-sort09.gif" alt="快速排序演示"></p><h4 id="3、代码实现-5"><a href="#3、代码实现-5" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>用伪代码描述如下：</p><p>①. <code>i = L; j = R;</code> 将基准数挖出形成第一个坑<code>a[i]</code>。<br><br>②．<code>j--</code>，由后向前找比它小的数，找到后挖出此数填前一个坑<code>a[i]</code>中。<br><br>③．<code>i++</code>，由前向后找比它大的数，找到后也挖出此数填到前一个坑<code>a[j]</code>中。<br><br>④．再重复执行②，③二步，直到<code>i==j</code>，将基准数填入<code>a[i]</code>中 <br></p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/200px-Partition_example.svg.png" alt="快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序（递归）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ①. 从数列中挑出一个元素，称为"基准"（pivot）。</span></span><br><span class="line"><span class="comment"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span></span><br><span class="line"><span class="comment"> * ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> low   左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> high  右边界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> left = low;</span><br><span class="line">    <span class="keyword">int</span> right = high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = arr[left];   <span class="comment">//挖坑1：保存基准的值</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  <span class="comment">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   <span class="comment">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = temp;   <span class="comment">//基准值填补到坑3中，准备分治递归快排</span></span><br><span class="line">    System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</span><br><span class="line">    quickSort(arr, low, left-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, left+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是递归版的快速排序：通过把基准temp插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？</p><p>因为<strong>递归的本质是栈</strong>，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序（非递归）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ①. 从数列中挑出一个元素，称为"基准"（pivot）。</span></span><br><span class="line"><span class="comment"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</span></span><br><span class="line"><span class="comment"> * ③. 把分区之后两个区间的边界（low和high）压入栈保存，并循环①、②步骤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortByStack</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态的左右指针入栈</span></span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    stack.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> high = stack.pop();     <span class="comment">//出栈进行划分</span></span><br><span class="line">        <span class="keyword">int</span> low = stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivotIdx = partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存中间变量</span></span><br><span class="line">        <span class="keyword">if</span>(pivotIdx &gt; low) &#123;</span><br><span class="line">            stack.push(low);</span><br><span class="line">            stack.push(pivotIdx - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pivotIdx &lt; high &amp;&amp; pivotIdx &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            stack.push(pivotIdx + <span class="number">1</span>);</span><br><span class="line">            stack.push(high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = low;</span><br><span class="line">    <span class="keyword">int</span> r = high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[l];    <span class="comment">//挖坑1：保存基准的值</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[r] &gt;= pivot)&#123;  <span class="comment">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt;= pivot)&#123;   <span class="comment">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[r] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = pivot;   <span class="comment">//基准值填补到坑3中，准备分治递归快排</span></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p><p>以下是快速排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(1)（原地分区递归版）</td></tr></tbody></table><p>快速排序排序效率非常高。 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常平均来看, 它的时间复杂为O(nlogn), 比同样为O(nlogn)时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高.</p><p>Tips: 同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定.</p><h3 id="七、归并排序（Merging-Sort）"><a href="#七、归并排序（Merging-Sort）" class="headerlink" title="七、归并排序（Merging Sort）"></a>七、归并排序（Merging Sort）</h3><hr><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort_sample.jpg" alt></p><p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><h4 id="1、基本思想-6"><a href="#1、基本思想-6" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/2016-07-15_归并排序.gif" alt="这个图很有概括性，来自维基"></p><h4 id="2、算法描述-6"><a href="#2、算法描述-6" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p><strong>归并排序可通过两种方式实现：</strong></p><ul><li>自上而下的递归</li><li>自下而上的迭代</li></ul><p><strong>一、递归法</strong>（假设序列共有n个元素）：</p><p>①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；<br><br>②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；<br><br>③. 重复步骤②，直到所有元素排序完毕。<br></p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/merging-sort.gif" alt></p><p><strong>二、迭代法</strong></p><p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 <br><br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置 <br><br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 <br><br>④. 重复步骤③直到某一指针到达序列尾 <br><br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾 <br></p><h4 id="3、代码实现-6"><a href="#3、代码实现-6" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>归并排序其实要做两件事：</p><ul><li>分解：将序列每次折半拆分</li><li>合并：将划分后的序列段两两排序合并</li></ul><p>因此，归并排序实际上就是两个操作，拆分+合并</p><p><strong>如何合并？</strong></p><p>L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。</p><p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]<br><br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]<br><br>此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序<br></p><p><strong>如何分解？</strong></p><p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p><p>这里我写了递归算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序（递归）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</span></span><br><span class="line"><span class="comment"> * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</span></span><br><span class="line"><span class="comment"> * ③. 重复步骤②，直到所有元素排序完毕。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergingSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = arr.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] leftArr = Arrays.copyOfRange(arr, <span class="number">0</span>, num);</span><br><span class="line">    <span class="keyword">int</span>[] rightArr = Arrays.copyOfRange(arr, num, arr.length);</span><br><span class="line">    System.out.println(<span class="string">"split two array: "</span> + Arrays.toString(leftArr) + <span class="string">" And "</span> + Arrays.toString(rightArr));</span><br><span class="line">    <span class="keyword">return</span> mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      <span class="comment">//不断拆分为最小单元，再排序合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeTwoArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length + arr2.length];  <span class="comment">//申请额外的空间存储合并之后的数组</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;      <span class="comment">//选取两个序列中的较小值放入新数组</span></span><br><span class="line">        <span class="keyword">if</span>(arr1[i] &lt;= arr2[j])&#123;</span><br><span class="line">            result[k++] = arr1[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[k++] = arr2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.length)&#123;     <span class="comment">//序列1中多余的元素移入新数组</span></span><br><span class="line">        result[k++] = arr1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; arr2.length)&#123;     <span class="comment">//序列2中多余的元素移入新数组</span></span><br><span class="line">        result[k++] = arr2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Merging: "</span> + Arrays.toString(result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上, 长度为n的数组, 最终会调用mergeSort函数2n-1次。<strong>通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</strong></p><p>以下是归并排序算法复杂度:</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n)</td></tr></tbody></table><p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p><blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(n log n）</code>的时间复杂度。代价是需要额外的内存空间。</p></blockquote><h3 id="八、基数排序（Radix-Sort）"><a href="#八、基数排序（Radix-Sort）" class="headerlink" title="八、基数排序（Radix Sort）"></a>八、基数排序（Radix Sort）</h3><hr><p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。</p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h4 id="1、基本思想-7"><a href="#1、基本思想-7" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>基数排序按照优先从高位或低位来排序有两种实现方案：</p><ul><li><p><strong>MSD（Most significant digital） 从最左侧高位开始进行排序</strong>。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<em>MSD方式适用于位数多的序列</em>。</p></li><li><p><strong>LSD （Least significant digital）从最右侧低位开始进行排序</strong>。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<em>LSD方式适用于位数少的序列</em>。</p></li></ul><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/radix-sort_sample.gif" alt="基数排序LSD动图演示"></p><h4 id="2、算法描述-7"><a href="#2、算法描述-7" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>我们以LSD为例，从最低位开始，具体算法描述如下：</p><p>①. 取得数组中的最大数，并取得位数；<br><br>②. arr为原始数组，从最低位开始取每个位组成radix数组；<br><br>③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；<br></p><h4 id="3、代码实现-7"><a href="#3、代码实现-7" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p><ul><li><p><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p></li><li><p><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序（LSD 从低位开始）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 基数排序适用于：</span></span><br><span class="line"><span class="comment"> *  (1)数据范围较小，建议在小于1000</span></span><br><span class="line"><span class="comment"> *  (2)每个数值都要大于等于0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ①. 取得数组中的最大数，并取得位数；</span></span><br><span class="line"><span class="comment"> * ②. arr为原始数组，从最低位开始取每个位组成radix数组；</span></span><br><span class="line"><span class="comment"> * ③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    待排序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取得数组中的最大数，并取得位数</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; arr[i])&#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(max / <span class="number">10</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        maxDigit++;</span><br><span class="line">        max = max / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"maxDigit: "</span> + maxDigit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请一个桶空间</span></span><br><span class="line">    <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从低位到高位，对每一位遍历，将所有元素分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];        <span class="comment">//存储各个桶中存储元素的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配：将所有元素分配到桶中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> whichBucket = (arr[j] % base) / (base / <span class="number">10</span>);</span><br><span class="line">            buckets[whichBucket][bktLen[whichBucket]] = arr[j];</span><br><span class="line">            bktLen[whichBucket]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; buckets.length; b++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; bktLen[b]; p++)&#123;</span><br><span class="line">                arr[k++] = buckets[b][p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是基数排序算法复杂度，其中k为最大数的位数：</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(n+r)</td></tr></tbody></table><p>其中，<strong>d 为位数，r 为基数，n 为原数组个数</strong>。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 <code>O(d*(n + r))</code>。</p><p>基数排序更适合用于对时间, 字符串等这些<strong>整体权值未知的数据</strong>进行排序。</p><p>Tips: 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ol><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>各种排序性能对比如下图，有些排序未详细介绍，暂且放到这里。<br>实例测试结果可以看这里：<a href="https://github.com/iTimeTraveler/SortAlgorithms/blob/master/BENCH_RESULT.md" target="_blank" rel="noopener"><strong>八大排序算法耗时对比</strong></a> 。</p><table><thead><tr><th>排序类型</th><th>平均情况</th><th>最好情况</th><th>最坏情况</th><th>辅助空间</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.3)</td><td>O(nlogn)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(nlog₂n)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n²)</td><td>O(n+k)</td><td>(不)稳定</td></tr><tr><td>基数排序</td><td>O(d(n+k))</td><td>O(d(n+k))</td><td>O(d(n+kd))</td><td>O(n+kd)</td><td>稳定</td></tr></tbody></table><p>从时间复杂度来说：</p><p>(1). 平方阶O(n²)排序：<strong><code>各类简单排序：直接插入、直接选择和冒泡排序</code></strong>；</p><p>(2). 线性对数阶O(nlog₂n)排序：<strong><code>快速排序、堆排序和归并排序</code></strong>；</p><p>(3). O(n1+§))排序，§是介于0和1之间的常数：<strong><code>希尔排序</code></strong></p><p>(4). 线性阶O(n)排序：<strong><code>基数排序，此外还有桶、箱排序</code></strong>。</p><p>到此，很多人会注意到<strong>基数排序</strong>的时间复杂度是最小的，那么为什么却没有快排、堆排序流行呢？我们看看下图算法导论的相关说明：</p><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/radixsort-comparison.jpg" alt></p><p>基数排序只适用于有基数的情况，而基于比较的排序适用范围就广得多。另一方面是内存上的考虑。作为一种通用的排序方法，最好不要带来意料之外的内存开销，所以各语言的默认实现都没有用基数排序，但是不能否认基数排序在各领域的应用。</p><h4 id="时间复杂度极限"><a href="#时间复杂度极限" class="headerlink" title="时间复杂度极限"></a>时间复杂度极限</h4><p><strong>当被排序的数有一些性质的时候</strong>（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于O(nlgn)的。比如：</p><ol><li>计数排序 复杂度O( k+n)     要求：被排序的数是0~k范围内的整数</li><li>基数排序 复杂度O( d(k+n) )  要求：d位数，每个数位有k个取值</li><li>桶排序    复杂度 O( n ) （平均） 要求：被排序数在某个范围内，并且服从均匀分布</li></ol><p>但是，当被排序的数不具有任何性质的时候，一般使用基于比较的排序算法，而<strong>基于比较的排序算法时间复杂度的下限必须是O(nlgn)</strong>。 参考<a href="https://www.zhihu.com/question/24516934" target="_blank" rel="noopener">很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？</a></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li><li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</li><li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li></ul><p><img src="https://itimetraveler.github.io/gallery/sort-algorithms/2016-07-15_常用排序算法.png" alt></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>数据结构可视化：<a href="https://visualgo.net/zh" target="_blank" rel="noopener">visualgo</a>，<a href="https://www.toptal.com/developers/sorting-algorithms/" target="_blank" rel="noopener">Sorting Algorithms Animations</a>，<a href="https://codepen.io/iTimeTraveler/pen/dRrwZr" target="_blank" rel="noopener">CodePen</a> &amp; <a href="https://codepen.io/iTimeTraveler/pen/weORyW" target="_blank" rel="noopener">sort it out</a></li><li><a href="https://coolshell.cn/articles/536.html" target="_blank" rel="noopener">一个显示排序过程的PYTHON脚本</a></li><li>排序算法测试：<a href="http://www.cse.chalmers.se/edu/course/DIT960/lab1-sorting.html" target="_blank" rel="noopener">Lab 1: Sorting - 哥德堡大学课件（University of Gothenburg）</a></li><li><a href="http://www.sorting-algorithms.com/" target="_blank" rel="noopener">Sorting Algorithm Animations - 一个排序算法比较的网站</a></li><li><a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html" target="_blank" rel="noopener">Sorting - 卡内基梅隆大学课件</a></li><li><a href="http://www.jianshu.com/p/7d037c332a9d" target="_blank" rel="noopener">数据结构常见的八大排序算法（详细整理）</a></li><li><a href="http://www.jianshu.com/p/8c915179fd02" target="_blank" rel="noopener">必须知道的八大种排序算法【java实现】</a></li><li><a href="http://web.jobbole.com/87968/" target="_blank" rel="noopener">十大经典排序算法</a></li><li><a href="http://blog.jobbole.com/11745/" target="_blank" rel="noopener">视觉直观感受 7 种常用的排序算法</a></li><li><a href="http://louiszhai.github.io/2016/12/23/sort/" target="_blank" rel="noopener">JS中可能用得到的全部的排序算法</a></li><li><a href="http://www.cnblogs.com/minkaihui/p/4077888.html" target="_blank" rel="noopener">总结5种比较高效常用的排序算法</a></li><li><a href="http://www.cnblogs.com/zyb428/p/5673738.html" target="_blank" rel="noopener">常见排序算法C++总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      因为健忘，加上对各种排序算法理解不深刻，过段时间面对排序就蒙了。所以决定对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法
    
    </summary>
    
    
      <category term="Algorithms," scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>EveryThing About Operation System</title>
    <link href="http://yoursite.com/2019/12/27/EveryThing-About-Operation-System/"/>
    <id>http://yoursite.com/2019/12/27/EveryThing-About-Operation-System/</id>
    <published>2019-12-27T09:13:56.000Z</published>
    <updated>2020-02-27T09:17:33.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表。堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些堆可以被看成是一棵树，如：堆排序。</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>由操作系统（编译器）自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放。一种先进后出的数据结构</li></ul><h3 id="用户态，内核态以及如何切换。"><a href="#用户态，内核态以及如何切换。" class="headerlink" title="用户态，内核态以及如何切换。"></a>用户态，内核态以及如何切换。</h3><ul><li><p>内核态：运行操作系统程序，控制计算机的硬件资源，并提供上层应用程序运行的环境，运行在高特权级上。<strong>内核态切换到用户态的途径——&gt;设置程序状态字</strong>。</p></li><li><p>用户态：运行用户程序上层应用程序的活动空间，运行在低特权级别上。为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。<strong>用户态切换到内核态的唯一途径(申请外部资源)——&gt;中断/异常/系统调用</strong>(读写文件,申请堆内存,缺页(虚拟内存地址没有映射到物理内存地址,在Java中New一个对象))。系统调用 System， Callaccept:套接字的客户端连接套接字，bind套接字的服务端监听端口</p></li></ul><h2 id="信号和信号量的关系"><a href="#信号和信号量的关系" class="headerlink" title="信号和信号量的关系"></a>信号和信号量的关系</h2><ul><li>信号：（signal）是一种处理异步事件的方式。信号时比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。linux除了支持unix早期的信号语义函数，还支持语义符合posix.1标准的信号函数sigaction。</li><li>信号量：（Semaphore）进程间通信处理同步互斥的机制。是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。<h2 id="进程和线程，进程之间的通信方式等"><a href="#进程和线程，进程之间的通信方式等" class="headerlink" title="进程和线程，进程之间的通信方式等"></a>进程和线程，进程之间的通信方式等</h2>啥是进程，啥是线程，他们的本质区别？我们运行一个程序时，数据放在哪里？代码放在哪里？咋就还要分堆和栈？线程切换时是上下文是啥意思？</li></ul><p>虚拟地址是什么鬼东西？线程需要那么多种状态干啥子？什么是乐观锁、悲观锁？死锁是怎么造成的？解决死锁的策略有哪些？等等<br>2、进程、线程究竟是由什么组成的？有哪些数据？</p><p>3、内存管理，包括：虚拟内存（重点）、分页、分段、分页系统地址映射、内存置换算法（重点）。</p><p>安全系统不会死锁</p><h2 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h2><p>进程是具有一定独立功能的程序，它是系统进行资源分配和调度的一个独立单位，重点在系统调度和独立的单位，也就是说进程是可以独立运行的一段程序。</p><h2 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h2><p>线程是进程的一个实体，是CPU调度和分配的基本单位，它是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，在运行时，只是暂用一些计数器，寄存器，和栈。</p><h2 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h2><ul><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。</li><li>资源分配给进程，同一进程的所有线程共享该进程的所有资源。</li><li>线程在执行过程中，需要协作同步，不同进程的线程间要利用消息通信的方法实现同步。</li><li>处理机分配给线程，即真正在处理机上运行的是线程。</li><li>线程是指进程内的一个执行单元，也是进程内的可调度实体。</li><li>进程会释放资源，线程不会。<h2 id="从4个角度来分析进程与线程之间的区别"><a href="#从4个角度来分析进程与线程之间的区别" class="headerlink" title="从4个角度来分析进程与线程之间的区别"></a>从4个角度来分析进程与线程之间的区别</h2></li><li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li><li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行</li><li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源</li><li>系统开销：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销<h2 id="进程有几种状态"><a href="#进程有几种状态" class="headerlink" title="进程有几种状态"></a>进程有几种状态</h2></li><li>就绪状态：进程已经获得除处理机以外的所有资源，等待分配处理机资源</li><li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数目</li><li>阻塞状态：进程等待某种条件，在条件满足之前无法运行<h2 id="线程有几种状态"><a href="#线程有几种状态" class="headerlink" title="线程有几种状态"></a>线程有几种状态</h2></li><li>执行状态：表示线程已经获得处理机而正在运行</li><li>就绪状态：指线程已经具备了各种执行条件，只需再获得CPU便可以立即执行难</li><li>阻塞状态：线程在执行过程中因某事受阻而处于暂停状态<h2 id="操作系统进程调度有哪几种"><a href="#操作系统进程调度有哪几种" class="headerlink" title="操作系统进程调度有哪几种"></a>操作系统进程调度有哪几种</h2></li><li>非抢占式方式：采用这种调度方式时，一旦把处理机分配给某个进程后，就一直让它运行下去，决不会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机，直至该进程完成，或发生某种事件而被阻塞时，才把处理机分配给其他进程</li><li>抢占式方式：这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将已经分配给该进程的处理机重新分配给另一进程，在现代OS中广泛采用抢占方式。<br>进程为什么需要同步<br>进程同步机制的主要任务是对多个相关进程在执行次序上进行协调，使得并发执行的各个进程之间能按照一定的规则或时序共享系统资源，并能很好的相互合作，从而使得程序的执行具有可再现性</li></ul><h2 id="列举几种进程同步机制，并说明其优缺点"><a href="#列举几种进程同步机制，并说明其优缺点" class="headerlink" title="列举几种进程同步机制，并说明其优缺点"></a>列举几种进程同步机制，并说明其优缺点</h2><ul><li>硬件同步机制：</li><li>信号量机制：</li><li>管程机制：<h2 id="进程之间通信的途径"><a href="#进程之间通信的途径" class="headerlink" title="进程之间通信的途径"></a>进程之间通信的途径</h2><a href="https://mp.weixin.qq.com/s/5CbYGrylSKx1JwtOiW3aOQ" target="_blank" rel="noopener">进程之间通信方向</a></li><li>管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，进程的亲缘关系通常是指父子进程关系</li><li>有名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系的进程间的通信</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问，它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源，因此，主要作为进程间以及同一进程内不同线程之间的同步手段</li><li>消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</li><li>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程通信方式运行效率低而专门设计的，它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信</li><li>Socket(套接字)：套接字可以用于不同的进程间的通信<h2 id="线程之间通信的途径"><a href="#线程之间通信的途径" class="headerlink" title="线程之间通信的途径"></a>线程之间通信的途径</h2></li><li>锁机制：包括互斥锁，条件变量，读写锁 互斥锁提供了以排他方式防止数据结构被并发修改的方法 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止，对条件的测试是在互斥锁的保护下进行的，条件变量始终与互斥锁一起使用 读写锁允许多个线程同时读共享数据，而对写操作是互斥的</li><li>信号量机制：包括无名线程信号量和命名线程信号量</li><li>信号机制：类似进程间的信号处理 <strong>注意：线程间的通信的目的主要是用于线程的同步，所以线程没有像进程通信中的用于数据交换的通信机制</strong></li></ul><h2 id="多线程如何同步"><a href="#多线程如何同步" class="headerlink" title="多线程如何同步"></a>多线程如何同步</h2><blockquote><p>临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphore）、事件（Event）的区别</p></blockquote><h3 id="临界区："><a href="#临界区：" class="headerlink" title="临界区："></a>临界区：</h3><p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</p><h3 id="互斥量："><a href="#互斥量：" class="headerlink" title="互斥量："></a>互斥量：</h3><p>采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 .互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p><h3 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h3><p>它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 .信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</p><p>PV操作及信号量的概念都是由荷兰科学家E.W.Dijkstra提出的。信号量S是一个整数，S大于等于零时代表可供并发进程使用的资源实体数，但S小于零时则表示正在等待使用共享资源的进程数。</p><h6 id="P操作申请资源："><a href="#P操作申请资源：" class="headerlink" title="P操作申请资源："></a>P操作申请资源：</h6><ul><li>S减1；</li><li>若S减1后仍大于等于零，则进程继续执行；</li><li><p>若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转入进程调度。　　</p><h5 id="V操作释放资源："><a href="#V操作释放资源：" class="headerlink" title="V操作释放资源："></a>V操作释放资源：</h5></li><li><p>S加1；</p></li><li>若相加结果大于零，则进程继续执行；</li><li>若相加结果小于等于零，则从该信号的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转入进程调度。　　<h3 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h3>通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作 .</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</li><li>互斥量（Mutex），信号灯（Semaphore），事件（Event）都可以被跨越进程使用来进行同步数据操作，而其他的对象与数据同步操作无关，但对于进程和线程来讲，如果进程和线程在运行状态则为无信号状态，在退出后为有信号状态。所以可以使用WaitForSingleObject来等待进程和线程退出。</li><li>通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号灯对象可以说是一种资源计数器。　　</li></ul><h2 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h2><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的</p><h2 id="进程死锁的原因"><a href="#进程死锁的原因" class="headerlink" title="进程死锁的原因"></a>进程死锁的原因</h2><p>多个进程对资源的争夺，包括对不可抢占资源和对可消耗资源</p><h2 id="进程死锁的4个必要条件"><a href="#进程死锁的4个必要条件" class="headerlink" title="进程死锁的4个必要条件"></a>进程死锁的4个必要条件</h2><ul><li>互斥条件：进程对所分配到的资源进行排它性使用，即在一段时间内，其资源只能被一个进程占用，如果此时还有其它进程请求该资源，则请求进程只能等待，直至占有该资源的进程用完释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已经被其它进程占有，此时请求进程被阻塞，但对自己已经获得的资源保持不放</li><li>不可抢占条件：进程已经获得的资源在未使用完之前不能被抢占，只能在进程使用完时由自己释放</li><li>循环等待条件：在发生死锁时，必然存在一个进程-资源循环链，即进程集合｛P0,P1,……,PN｝中的P0正在等待一个P1占用的资源，P1正在等待P2占用的资源，……，PN 正在等待P0占用的资源<h2 id="进程死锁的处理"><a href="#进程死锁的处理" class="headerlink" title="进程死锁的处理"></a>进程死锁的处理</h2></li><li>预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一种</li><li>避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态</li><li>检测死锁：通过检测机构及时检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来</li><li>解除死锁：当检测到系统中已经发生死锁时，采取相应的措施，将进程从死锁状态解脱出来，常用的方法是撤销一些进程，回收他们的资源，将它们分配给已经处于阻塞状态的进程，使其能够继续运行<h2 id="描述实时操作系统的基本特征"><a href="#描述实时操作系统的基本特征" class="headerlink" title="描述实时操作系统的基本特征"></a>描述实时操作系统的基本特征</h2>实时操作系统是指操作系统工作时，其各种资源可以根据需要随时进行动态分配，由于各种资源可以进行动态分配，因此，其处理事务的能力较强 换言之，在特定时间内完成特定的任务，具有实时性与可靠性</li></ul><h2 id="操作系统中断与轮询的基本特点"><a href="#操作系统中断与轮询的基本特点" class="headerlink" title="操作系统中断与轮询的基本特点"></a>操作系统中断与轮询的基本特点</h2><ul><li>轮询：对I/O设备的程序轮询的方式是早期的计算机系统对I/O设备的一种管理方式，它定时对各种设备轮流询问一遍有无处理要求。轮询占据了CPU相当一部分处理时间，因此，程序轮询是一种效率较低的方式，在现代计算机系统中已经很少应用</li><li><p>中断：中断是指CPU在正常运行程序的过程中，由于发生的内部或外部的特定的事件，使得CPU中断正在运行的程序，而转到响应的服务程序去处理</p><h2 id="什么是临界区，如何解决冲突"><a href="#什么是临界区，如何解决冲突" class="headerlink" title="什么是临界区，如何解决冲突"></a>什么是临界区，如何解决冲突</h2><p>每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入 解决冲突的方法：</p></li><li><p>如果有若干个进程要求进入空闲的临界区，一次仅允许一个进程进入</p></li><li>任何时候，处于临界区内的进程不可以多于一个，如果已经有进程进入自己的临界区，则其他所有试图进入临界区的进程必须等待</li><li>进入临界区内的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区</li><li>如果进程不能进入自己的临界区，则应该让出CPU，避免进程出现“忙碌”现象。<h2 id="windows下内存是如何管理的"><a href="#windows下内存是如何管理的" class="headerlink" title="windows下内存是如何管理的"></a>windows下内存是如何管理的</h2>windows操纵内存可以分为两个层面，物理内存和虚拟内存。</li></ul><h3 id="进程调度算法-长中短"><a href="#进程调度算法-长中短" class="headerlink" title="进程调度算法(长中短)"></a>进程调度算法(长中短)</h3><ul><li>时间片轮转调度算法（RR）：给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，时间片轮转调度不考虑进程等待时间和执行时间，属于抢占式调度。优点是兼顾长短作业；缺点是平均等待时间较长，上下文切换较费时。适用于分时系统。</li><li>先来先服务调度算法（FCFS）：根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间，会产生饥饿现象。属于非抢占式调度，优点是公平，实现简单；缺点是不利于短作业。</li><li>优先级调度算法（HPF）：在进程等待队列中选择优先级最高的来执行。</li><li>多级反馈队列调度算法：将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。</li><li>高响应比优先调度算法：根据“响应比=（进程执行时间+进程等待时间）/ 进程执行时间”这个公式得到的响应比来进行调度。高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足段任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。</li></ul><h3 id="进程调度算法-长中短-1"><a href="#进程调度算法-长中短-1" class="headerlink" title="进程调度算法(长中短)"></a>进程调度算法(长中短)</h3><ul><li><strong>长程调度，把作业后背队列调入内存</strong>，又称为作业调度或高级调度，这种调度将已进入系统并处于后备状态的作业按某种算法选择一个或一批，为其建立进程，并进入主机，当该作业执行完毕时，还负责回收系统资源，在批处理系统中，需要有作业调度的过程，以便将它们分批地装入内存，在分时系统和实时系统中，通常不需要长期调度。它的频率比较低，主要用来控制内存中进程的数量。</li><li><strong>中程调度，内外存阻塞进程来回切换</strong>，又称为交换调度。它的核心思想是能将进程从内存或从CPU竞争中移出，从而降低多道程序设计的程度，之后进程能被重新调入内存，并从中断处继续执行，这种交换的***作可以调整进程在内存中的存在数量和时机。其主要任务是按照给定的原则和策略，将处于外存交换区中的就绪状态或等待状态的进程调入内存，或把处于内存就绪状态或内存等待状态的进程交换到外存交换区。</li><li><strong>短程调度，把进程分配给CPU执行</strong>。又称为进程调度、低级调度或微观调度。这也是通常所说的调度，一般情况下使用最多的就是短期调度。它的主要任务是按照某种策略和算法将处理机分配给一个处于就绪状态的进程，分为抢占式和非抢占式。 可以从下图中清晰的看到这些调度之间的区别。</li></ul><h3 id="磁盘寻道算法"><a href="#磁盘寻道算法" class="headerlink" title="磁盘寻道算法"></a>磁盘寻道算法</h3><ul><li>先来先服务算法（FCFS）First Come First Service</li></ul><p>这是一种比较简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。此算法由于未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低设备服务的吞吐量，致使平均寻道时间可能较长，但各进程得到服务的响应时间的变化幅度较小。<strong>在单用户系统环境中，I/O队列的长度通常为1，因此，先来先服务FCFS算法是最经济实惠的磁盘调度算法</strong>.</p><p>先来先服务 （125）86.147.91.177.94.150.102.175.130</p><ul><li>最短寻道时间优先算法（SSTF） Shortest Seek Time First</li></ul><p>该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，该算法可以得到比较好的吞吐量，但却不能保证平均寻道时间最短。其缺点是对用户的服务请求的响应机会不是均等的，因而导致响应时间的变化幅度很大。在服务请求很多的情况下，对内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期。最短寻道时间优先（125）130.147.150.175.177.102.94.91.86</p><ul><li>扫描算法（SCAN）电梯调度</li></ul><p>扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。例如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁道之内，从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律颇似电梯的运行，故又称为电梯调度算法。此算法基本上克服了最短寻道时间优先算法的服务集中于中间磁道和响应时间变化比较大的缺点，而具有最短寻道时间优先算法的优点即吞吐量较大，平均响应时间较小，但由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道。电梯调度（125）102.94.91.86.130.147.150.175.177</p><ul><li>循环扫描算法（CSCAN）</li></ul><p>循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。循环扫描 （125）130.147.150.175.177.86.91.94.102</p><h3 id="學長筆記連結"><a href="#學長筆記連結" class="headerlink" title="學長筆記連結"></a>學長筆記連結</h3><ul><li><p><a href="https://kim85326.github.io/2018/01/09/CH6-%E8%A1%8C%E7%A8%8B%E6%8E%92%E7%8F%AD-(Process-Scheduling)/" target="_blank" rel="noopener">https://kim85326.github.io/2018/01/09/CH6-%E8%A1%8C%E7%A8%8B%E6%8E%92%E7%8F%AD-(Process-Scheduling)/</a><br>信號</p></li><li><p><a href="https://kim85326.github.io/2018/01/10/CH10-%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1-(File-System)/" target="_blank" rel="noopener">https://kim85326.github.io/2018/01/10/CH10-%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1-(File-System)/</a></p></li><li><p>檔案系統<br><a href="https://kim85326.github.io/2018/01/09/CH8-%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86-(Memory-Management-Strategies)/" target="_blank" rel="noopener">https://kim85326.github.io/2018/01/09/CH8-%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86-(Memory-Management-Strategies)/</a><br>記憶體管理</p></li><li><p><a href="https://kim85326.github.io/2018/01/09/CH9-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86-(Virtual-Memory-Management)/" target="_blank" rel="noopener">https://kim85326.github.io/2018/01/09/CH9-%E8%99%9B%E6%93%AC%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86-(Virtual-Memory-Management)/</a><br>虛擬記憶裡 lru</p></li></ul>]]></content>
    
    <summary type="html">
    
      EveryThing About Operation System
    
    </summary>
    
    
      <category term="Operation System" scheme="http://yoursite.com/tags/Operation-System/"/>
    
  </entry>
  
  <entry>
    <title>SDN_OpenFlow</title>
    <link href="http://yoursite.com/2019/11/06/SDN-OpenFlow/"/>
    <id>http://yoursite.com/2019/11/06/SDN-OpenFlow/</id>
    <published>2019-11-06T06:00:03.000Z</published>
    <updated>2020-02-17T10:24:20.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="107-SDN"><a href="#107-SDN" class="headerlink" title="107 SDN"></a>107 SDN</h1><h2 id="a10715005-任偉"><a href="#a10715005-任偉" class="headerlink" title="a10715005 任偉"></a>a10715005 任偉</h2><h3 id="Boot-onosproject"><a href="#Boot-onosproject" class="headerlink" title="Boot onosproject"></a>Boot onosproject</h3><p><img src="https://imgur.com/GBqQTM5.png" alt></p><h3 id="Configuration-Json-file-and-Create-Topo-using-command-line"><a href="#Configuration-Json-file-and-Create-Topo-using-command-line" class="headerlink" title="Configuration Json file and Create Topo using command line"></a>Configuration Json file and Create Topo using command line</h3><p><img src="https://imgur.com/ZBZABkv.png" alt></p><h1 id="已經解決"><a href="#已經解決" class="headerlink" title="已經解決"></a>已經解決</h1><h2 id="ONOS-GUI中的topology"><a href="#ONOS-GUI中的topology" class="headerlink" title="ONOS GUI中的topology"></a>ONOS GUI中的topology</h2><p><img src="https://imgur.com/meGhS42.png" alt></p><h2 id="Ping-成功的畫面"><a href="#Ping-成功的畫面" class="headerlink" title="Ping 成功的畫面"></a>Ping 成功的畫面</h2><p><img src="https://imgur.com/gvkVOIL.png" alt></p><h2 id="Switch-s3的forwarding-table"><a href="#Switch-s3的forwarding-table" class="headerlink" title="Switch s3的forwarding table"></a>Switch s3的forwarding table</h2><p><img src="https://imgur.com/VpZQL2l.png" alt></p><h1 id="還沒有解決"><a href="#還沒有解決" class="headerlink" title="還沒有解決"></a>還沒有解決</h1><p><del>h1 ping h2</del><br><del>產生有兩條路徑的topology</del></p><ul><li>讓ping packet走較長的路徑</li></ul><p>原来是<br><img src="https://imgur.com/fX9oXev.png" alt></p><p>现在想让他变成<br><img src="https://imgur.com/LJETsWO.png" alt></p><h2 id="Pre-requisites"><a href="#Pre-requisites" class="headerlink" title="Pre-requisites:"></a>Pre-requisites:</h2><p><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener"><code>VirtualBox</code></a></p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration:"></a>Configuration:</h3><p><a href="https://jingyan.baidu.com/article/e2284b2b61a2efe2e6118d39.html" target="_blank" rel="noopener">JDK Configuration in Ubuntu</a></p><p><a href="https://blog.csdn.net/u010558281/article/details/78419321" target="_blank" rel="noopener">Install ONOS on Ubuntu</a></p><h3 id="Using-Linux-command"><a href="#Using-Linux-command" class="headerlink" title="Using Linux command:"></a>Using Linux command:</h3><p>modification file in Linux <code>gedit</code></p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h4><ul><li><p><a href="https://wiki.onosproject.org/display/ONOS/Basic+ONOS+Tutorial" target="_blank" rel="noopener"><code>Basic ONOS Tutorial</code></a></p></li><li><p><a href="https://www.youtube.com/watch?v=l25Ukkmk6Sk" target="_blank" rel="noopener"><code>OpenFlow</code></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;107-SDN&quot;&gt;&lt;a href=&quot;#107-SDN&quot; class=&quot;headerlink&quot; title=&quot;107 SDN&quot;&gt;&lt;/a&gt;107 SDN&lt;/h1&gt;&lt;h2 id=&quot;a10715005-任偉&quot;&gt;&lt;a href=&quot;#a10715005-任偉&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="ONOS OpenFlow SDN" scheme="http://yoursite.com/tags/ONOS-OpenFlow-SDN/"/>
    
  </entry>
  
  <entry>
    <title>CV</title>
    <link href="http://yoursite.com/2019/11/05/CV/"/>
    <id>http://yoursite.com/2019/11/05/CV/</id>
    <published>2019-11-05T06:10:01.000Z</published>
    <updated>2019-11-05T06:55:17.236Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/@xiaosean5408/pix2pixhd%E7%B0%A1%E4%BB%8B-high-resolution-image-synthesis-and-semantic-manipulation-with-conditional-gans-2099bd492f5" target="_blank" rel="noopener">pix2pixHD簡介 — High-Resolution Image Synthesis and Semantic Manipulation with Conditional GANs</a></p><p><a href="https://www.bilibili.com/video/av5987715" target="_blank" rel="noopener">【熟肉】线性代数的本质 - 01 - 向量究竟是什么？</a></p><p><a href="https://wei2624.github.io/machine%20learning/Machine-Learning-Notes/" target="_blank" rel="noopener">Machine-Learning-Notes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://medium.com/@xiaosean5408/pix2pixhd%E7%B0%A1%E4%BB%8B-high-resolution-image-synthesis-and-semantic-manipulation-with-cond
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>108FALL</title>
    <link href="http://yoursite.com/2019/10/18/108FALL/"/>
    <id>http://yoursite.com/2019/10/18/108FALL/</id>
    <published>2019-10-18T06:29:50.000Z</published>
    <updated>2019-12-05T05:00:43.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CS5095701-Advanced-Database-Systems"><a href="#CS5095701-Advanced-Database-Systems" class="headerlink" title="CS5095701 Advanced Database Systems"></a>CS5095701 Advanced Database Systems</h1><ul><li><p><a href="http://faculty.csie.ntust.edu.tw/~ywu/cs5095701/index.html" target="_blank" rel="noopener">CourseInfo</a></p></li><li><p><a href="https://docs.google.com/presentation/d/1HP7sgi0ClYdZmHQpGbO5SYVTYlU4V5MpYIx4xEOi4Co/edit" target="_blank" rel="noopener">PrensentationSlides</a></p></li><li><p>11/15 Proposal presentation (all 14 groups)</p></li><li>11/22 Mid-term exam</li><li>11/29 paper presentation (4 groups)(sequence        1~4)</li></ul><h2 id="Project-proposal"><a href="#Project-proposal" class="headerlink" title="Project proposal:"></a>Project proposal:</h2><p>You are required to propose a database related research project in this course. You are encouraged to have a publication as a goal for your project. A list of project ideas is listed below.</p><h2 id="You-proposal-should-include-the-following-aspects"><a href="#You-proposal-should-include-the-following-aspects" class="headerlink" title="You proposal should include the following aspects:"></a>You proposal should include the following aspects:</h2><ul><li><p>importance of the proposed project</p></li><li><p>your algorithm and ideas</p></li><li><p>main contributions</p></li><li><p>the design of the software you propose to build</p></li><li><p>how you propose to evaluate your ideas</p></li><li><p>the design of the experiments</p></li><li><p>literature survey</p></li></ul><h3 id="You-will-present-to-the-class-about-your-proposal-5-minutes-and-write-a-proposal-report-2-4-pages-in-IEEE-format"><a href="#You-will-present-to-the-class-about-your-proposal-5-minutes-and-write-a-proposal-report-2-4-pages-in-IEEE-format" class="headerlink" title="You will present to the class about your proposal (~ 5 minutes) and write a proposal report (2~4 pages in IEEE format)."></a>You will present to the class about your proposal (~ 5 minutes) and write a proposal report (2~4 pages in IEEE format).</h3><h1 id="CS5014701-電腦與機器人視覺-Computer-and-Robot-Vision"><a href="#CS5014701-電腦與機器人視覺-Computer-and-Robot-Vision" class="headerlink" title="CS5014701 電腦與機器人視覺 Computer and Robot Vision"></a>CS5014701 電腦與機器人視覺 Computer and Robot Vision</h1><ul><li><p><a href="https://docs.google.com/presentation/d/1IGnx-zBDaD7oFmCo3vJa4of-yKDxCmiLzA4EswjaXX0/edit" target="_blank" rel="noopener">Everybody Dance NOW<br></a></p></li><li><p><a href="https://docs.google.com/presentation/d/1KySt5eAGNONS2xu5TM4nkeAA_78sE_DKQ-Eq6oCJjJE/edit#slide=id.p" target="_blank" rel="noopener">Joint Discriminative and Generative Learning for Person Re-identification</a></p></li></ul><h1 id="CS5146701-虛擬化網路及應用-Virtualized-Networks-and-Applications"><a href="#CS5146701-虛擬化網路及應用-Virtualized-Networks-and-Applications" class="headerlink" title="CS5146701 虛擬化網路及應用 Virtualized Networks and Applications"></a>CS5146701 虛擬化網路及應用 Virtualized Networks and Applications</h1><ul><li>Proposal</li></ul><h2 id="Catch-up-from-Flick"><a href="#Catch-up-from-Flick" class="headerlink" title="Catch up from Flick"></a>Catch up from Flick</h2><p><a href="https://www.youtube.com/watch?v=wLDK8ZCnuBc&t=2s" target="_blank" rel="noopener">network virtualization</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/WenaxhSv35c?start=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h1 id="CS5023701-Knowledge-Based-Systems"><a href="#CS5023701-Knowledge-Based-Systems" class="headerlink" title="CS5023701  Knowledge-Based Systems"></a>CS5023701  Knowledge-Based Systems</h1><p><a href="https://docs.google.com/presentation/d/1qY_z_h-IgD5GLm81VX1pLvkQcwI_KNSnJgOVYtuUyJY/edit#slide=id.p" target="_blank" rel="noopener">Revisit Fuzzy Neural Network: Demystifying Batch Normalization and ReLU with Generalized Hamming Network</a></p><h1 id="CS5141701-深度學習導論及其應用-Introduction-to-Deep-Learning-and-Its-Applications"><a href="#CS5141701-深度學習導論及其應用-Introduction-to-Deep-Learning-and-Its-Applications" class="headerlink" title="CS5141701 深度學習導論及其應用 Introduction to Deep Learning and Its Applications"></a>CS5141701 深度學習導論及其應用 Introduction to Deep Learning and Its Applications</h1><p><a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLSD15_2.html" target="_blank" rel="noopener">Hung-yi Lee’S CourseInfo</a></p><p><a href="https://datawhalechina.github.io/leeml-notes/#/" target="_blank" rel="noopener">李宏毅机器学习笔记(LeeML-Notes)</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/videoseries?list=PLXVfgk9fNX2I7tB6oIINGBmW50rrmFTqf" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><iframe width="560" height="315" src="https://www.youtube.com/embed/videoseries?list=PLXVfgk9fNX2IQOYPmqjqWsNUFl2kpk1U2" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><iframe width="560" height="315" src="https://www.youtube.com/embed/CXgbekl66jc?start=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><iframe width="560" height="315" src="https://www.youtube.com/embed/JGZFYJFoxDA?start=3947" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h1 id="【財金學程】FBG006301-品牌價值創新講座-Seminar-on-Brand-Value-Innovation"><a href="#【財金學程】FBG006301-品牌價值創新講座-Seminar-on-Brand-Value-Innovation" class="headerlink" title="【財金學程】FBG006301 品牌價值創新講座 Seminar on Brand Value Innovation"></a>【財金學程】FBG006301 品牌價值創新講座 Seminar on Brand Value Innovation</h1><p><a href="https://docs.google.com/presentation/d/1EokcapXuKWdFcqMF8_RCJ9WLSpPHzAfqs9S3ddTh7A0/edit?usp=sharing" target="_blank" rel="noopener">柯達企業失敗個案分析</a></p><h1 id="TCG037301-親近經典智慧-Wisdom-in-Classics"><a href="#TCG037301-親近經典智慧-Wisdom-in-Classics" class="headerlink" title="TCG037301 親近經典智慧 Wisdom in Classics"></a>TCG037301 親近經典智慧 Wisdom in Classics</h1><p><a href="https://docs.google.com/presentation/d/1VrzqySkwp_2s_XxrMa3tAunXpURI08F3ZUdXqflCeE8/edit?usp=sharing" target="_blank" rel="noopener">畜牧業的陰謀</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CS5095701-Advanced-Database-Systems&quot;&gt;&lt;a href=&quot;#CS5095701-Advanced-Database-Systems&quot; class=&quot;headerlink&quot; title=&quot;CS5095701 Advanced Dat
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Recommend System</title>
    <link href="http://yoursite.com/2019/10/03/Recommend-System/"/>
    <id>http://yoursite.com/2019/10/03/Recommend-System/</id>
    <published>2019-10-03T09:50:23.000Z</published>
    <updated>2020-01-07T02:27:23.303Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://wepon.me/" target="_blank" rel="noopener">http://wepon.me/</a> pku<br><a href="https://coladrill.github.io/about/" target="_blank" rel="noopener">https://coladrill.github.io/about/</a> seu<br><a href="https://github.com/ColaDrill/2018spa" target="_blank" rel="noopener">https://github.com/ColaDrill/2018spa</a> 推荐系统</p><p><a href="https://www.zhihu.com/people/coladrill/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/coladrill/activities</a><br>推荐系统 必看</p><p><a href="https://zhuanlan.zhihu.com/p/82671707?utm_source=wechat_session&utm_medium=social&utm_oi=973611927536181248" target="_blank" rel="noopener">手写xgboost</a></p><h1 id="Special-Projects"><a href="#Special-Projects" class="headerlink" title="Special Projects"></a>Special Projects</h1><h2 id="Previous"><a href="#Previous" class="headerlink" title="Previous"></a>Previous</h2><p>The Uni require all the undergraduate student to reach out the Special Projects.</p><h2 id="Mission"><a href="#Mission" class="headerlink" title="Mission:"></a>Mission:</h2><p>Recommend systems based on the Collaborative Filtering</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><ul><li><p><a href="https://spinningup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Reinforcement Spinning Up</a></p></li><li><p><a href="https://d2l.ai/chapter_recommender-systems/index.html" target="_blank" rel="noopener">Introduction to Deep Learning STAT 157, UC Berkeley, Spring, 2019</a><br>Reference By <a href="https://zhuanlan.zhihu.com/p/66062438" target="_blank" rel="noopener">在伯克利教深度学习</a></p></li></ul><p><a href="https://www.bilibili.com/video/av63439164?from=search&seid=3600678311547036502" target="_blank" rel="noopener">Talk in Mandarin</a></p><ul><li><a href="https://zhuanlan.zhihu.com/p/27908027" target="_blank" rel="noopener">Intro CNN</a></li></ul><iframe width="560" height="315" src="https://www.youtube.com/embed/tH9FH1DH5n0?start=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><blockquote class="blockquote-center"><p>Elegant in code, simple in core</p></blockquote><h3 id="IEEE-International-Conference-on-Signal-Information-and-Data-Processing-2019"><a href="#IEEE-International-Conference-on-Signal-Information-and-Data-Processing-2019" class="headerlink" title="IEEE International Conference on Signal, Information and Data Processing 2019"></a>IEEE International Conference on Signal, Information and Data Processing 2019</h3><p><a href="https://www.scribd.com/document/431478280/Automatic-Digital-Recognition-of-Multiple-E-lect-rici-ty-Dash-boar-ds-pdf" target="_blank" rel="noopener">Automatic Digital Recognition of Multiple Electricity Dashboards, (accepted) [EI]</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://wepon.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://wepon.me/&lt;/a&gt; pku&lt;br&gt;&lt;a href=&quot;https://coladrill.github.io/about/&quot; target
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>108_FALL</title>
    <link href="http://yoursite.com/2019/09/28/Prepare4Interview/"/>
    <id>http://yoursite.com/2019/09/28/Prepare4Interview/</id>
    <published>2019-09-28T13:42:12.000Z</published>
    <updated>2019-09-28T14:39:01.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机网络和操作系统"><a href="#计算机网络和操作系统" class="headerlink" title="计算机网络和操作系统"></a>计算机网络和操作系统</h3><ul><li><p>一个浏览器发出请求：把所有流程连起来把想到的知识梳理一遍，http传输，json解析，tomcat收到请求， springmvc解析请求， 传给服务层， 请求数据库， 查询数据库， 数据库查找索引，数据库返回数据。</p></li><li><p>硬盘转速和文件系统读写速度的关系</p></li><li><p>加密为什么不用https</p></li></ul><h1 id="九章算法-《Java入门与基础算法班》"><a href="#九章算法-《Java入门与基础算法班》" class="headerlink" title="九章算法 《Java入门与基础算法班》"></a>九章算法 《Java入门与基础算法班》</h1><ul><li><p>Java语言基础：数组，字符串，函数，类，对象，引用</p></li><li><p>Java算法基础： 枚举法，贪心法，递归，链表，栈，树，递归，哈希表，排序</p></li></ul><h1 id="问题类型"><a href="#问题类型" class="headerlink" title="问题类型"></a>问题类型</h1><ul><li>操作系统：（找手机相册里面的图片）</li></ul><h2 id="素质测试数字推理和图形推理"><a href="#素质测试数字推理和图形推理" class="headerlink" title="素质测试数字推理和图形推理"></a>素质测试数字推理和图形推理</h2><p>字符串排重并排序</p><h2 id="专业测试"><a href="#专业测试" class="headerlink" title="专业测试"></a>专业测试</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="一级中药"><a href="#一级中药" class="headerlink" title="一级中药"></a>一级中药</h4><p>dijkstra<br>lru缓存机制 算法也可以考系统设计<br>链表排序<br>lru如何保证o1的查找和修改</p><p>天哥面试：（必会）</p><ul><li><p>1:写一个二叉树的层次遍历或者链表的取中心点+把链表中心点后的部分反转</p></li><li><p>2:快速排序和二分归并排序有什么不同，最坏和平均时间复杂度分半是多少</p></li><li><p>进程和线程的区别是什么，除了时间片轮转法外，你还知道什么进程调度算法</p></li><li><p>线程持有锁的变量时，线程被切换了（若只有cpu时间片到了的话，不会释放锁，不然也就不存在死锁问题了），锁会被释放吗？<br>不会，进程释放所有资源，线程不会，</p></li><li><p>Java实现b+树，链表和栈，霍夫曼。（Java集合的底层实现）hashmap</p></li><li><p>dp和写正则</p></li><li><p>逻辑回归和svm都可以用来作二分类，他们的lost function有什么不同</p></li><li><p>写一个dnn或者线性回归的反向传播算法的推导</p></li><li><p>svm中核函数起到的作用，</p></li><li><p>信息增益是怎么用于决策树中的特征选择</p></li><li><p>pca的原理是什么</p></li><li><p>cnn中的resnet中的res指什么</p></li><li><p>depthwise有什么好处</p></li><li><p>计算一下一个cnn卷积一次的计算量</p></li><li><p>为什么需要激活函数</p></li></ul><h4 id="二级中药"><a href="#二级中药" class="headerlink" title="二级中药"></a>二级中药</h4><p>红黑树，平衡树，b+树，跳跃表</p><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ul><li>基础数据类型</li><li>protected修饰符</li><li>抽象类和接口区别</li><li>Java内存结构（重要）</li><li>Java并发和线程同步。同步机制和锁解释一下</li><li>synchronized和lock区别</li><li>类，继承，多态的概念</li><li>设计爬虫，你需要设计什么</li><li>wait()和sleep(区别)</li><li>多线程的理解</li><li>hashtable和hashmap区别</li><li><p>synchronized如何保证原子性：<br>monitor ，继续深入：如何保证读取对象头和修改对象头的原子性<br>*</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3></li><li><p>设计模式：手画代理模式</p></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>事务一定会锁表吗</p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>找到一个痛点 难点：<br>（特色模块）：单点登录，全局搜索（搜关键字，快速找到）</p><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><ul><li>6个数找出里面最大的两个数</li><li>一个四则运算字符串写程序运算出结果</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机网络和操作系统&quot;&gt;&lt;a href=&quot;#计算机网络和操作系统&quot; class=&quot;headerlink&quot; title=&quot;计算机网络和操作系统&quot;&gt;&lt;/a&gt;计算机网络和操作系统&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个浏览器发出请求：把所有流程连起来把想到的知识梳理一遍，
      
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
</feed>
